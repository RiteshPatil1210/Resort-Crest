import "react";
import { computed, signal, untracked, useSignalEffect } from "@preact/signals";
import { Component, Component as Component$1, Fragment, Fragment as Fragment$2, cloneElement, createContext as createContext$1, createContext as createContext$2, createElement, createElement as createElement$1, createRef, createRef as createRef$1, h, hydrate, options, render, toChildArray } from "preact";
import { useCallback as useCallback$1, useContext as useContext$1, useDebugValue, useEffect as useEffect$1, useId as useId$1, useImperativeHandle, useLayoutEffect as useLayoutEffect$1, useMemo as useMemo$1, useReducer, useRef as useRef$1, useState as useState$1 } from "preact/hooks";
import { Fragment as Fragment$1, jsx, jsxs } from "preact/jsx-runtime";
var __defProp = /* @__PURE__ */ (() => Object.defineProperty)();
var __getOwnPropDesc = /* @__PURE__ */ (() => Object.getOwnPropertyDescriptor)();
var __getOwnPropNames = /* @__PURE__ */ (() => Object.getOwnPropertyNames)();
var __hasOwnProp = /* @__PURE__ */ (() => Object.prototype.hasOwnProperty)();
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$1 = 0, n$1 = keys.length, key; i$1 < n$1; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k$2) => from[k$2]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
/**
* @license bippy
*
* Copyright (c) Aiden Bai
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const version = "0.3.17";
const BIPPY_INSTRUMENTATION_STRING = `bippy-${version}`;
const objectDefineProperty = /* @__PURE__ */ (() => Object.defineProperty)();
const objectHasOwnProperty = /* @__PURE__ */ (() => Object.prototype.hasOwnProperty)();
const NO_OP = () => {};
const checkDCE = (fn$1) => {
	try {
		const code = Function.prototype.toString.call(fn$1);
		if (code.indexOf("^_^") > -1) setTimeout(() => {
			throw new Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build");
		});
	} catch {}
};
const isRealReactDevtools = (rdtHook$1 = getRDTHook()) => {
	return "getFiberRoots" in rdtHook$1;
};
let isReactRefreshOverride = false;
let injectFnStr = void 0;
const isReactRefresh = (rdtHook$1 = getRDTHook()) => {
	if (isReactRefreshOverride) return true;
	if (typeof rdtHook$1.inject === "function") injectFnStr = rdtHook$1.inject.toString();
	return Boolean(injectFnStr?.includes("(injected)"));
};
const onActiveListeners = /* @__PURE__ */ new Set();
const _renderers = /* @__PURE__ */ new Set();
const installRDTHook = (onActive) => {
	const renderers = /* @__PURE__ */ new Map();
	let i$1 = 0;
	let rdtHook$1 = {
		checkDCE,
		supportsFiber: true,
		supportsFlight: true,
		hasUnsupportedRendererAttached: false,
		renderers,
		onCommitFiberRoot: NO_OP,
		onCommitFiberUnmount: NO_OP,
		onPostCommitFiberRoot: NO_OP,
		inject(renderer) {
			const nextID = ++i$1;
			renderers.set(nextID, renderer);
			_renderers.add(renderer);
			if (!rdtHook$1._instrumentationIsActive) {
				rdtHook$1._instrumentationIsActive = true;
				onActiveListeners.forEach((listener) => listener());
			}
			return nextID;
		},
		_instrumentationSource: BIPPY_INSTRUMENTATION_STRING,
		_instrumentationIsActive: false
	};
	try {
		objectDefineProperty(globalThis, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
			get() {
				return rdtHook$1;
			},
			set(newHook) {
				if (newHook && typeof newHook === "object") {
					const ourRenderers = rdtHook$1.renderers;
					rdtHook$1 = newHook;
					if (ourRenderers.size > 0) {
						ourRenderers.forEach((renderer, id) => {
							_renderers.add(renderer);
							newHook.renderers.set(id, renderer);
						});
						patchRDTHook(onActive);
					}
				}
			},
			configurable: true,
			enumerable: true
		});
		const originalWindowHasOwnProperty = window.hasOwnProperty;
		let hasRanHack = false;
		objectDefineProperty(window, "hasOwnProperty", {
			value: function() {
				try {
					if (!hasRanHack && arguments[0] === "__REACT_DEVTOOLS_GLOBAL_HOOK__") {
						globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = void 0;
						hasRanHack = true;
						return -0;
					}
				} catch {}
				return originalWindowHasOwnProperty.apply(this, arguments);
			},
			configurable: true,
			writable: true
		});
	} catch {
		patchRDTHook(onActive);
	}
	return rdtHook$1;
};
const patchRDTHook = (onActive) => {
	if (onActive) onActiveListeners.add(onActive);
	try {
		const rdtHook$1 = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;
		if (!rdtHook$1) return;
		if (!rdtHook$1._instrumentationSource) {
			rdtHook$1.checkDCE = checkDCE;
			rdtHook$1.supportsFiber = true;
			rdtHook$1.supportsFlight = true;
			rdtHook$1.hasUnsupportedRendererAttached = false;
			rdtHook$1._instrumentationSource = BIPPY_INSTRUMENTATION_STRING;
			rdtHook$1._instrumentationIsActive = false;
			if (rdtHook$1.renderers.size) {
				rdtHook$1._instrumentationIsActive = true;
				onActiveListeners.forEach((listener) => listener());
				return;
			}
			const prevInject = rdtHook$1.inject;
			if (isReactRefresh(rdtHook$1) && !isRealReactDevtools()) {
				isReactRefreshOverride = true;
				const nextID = rdtHook$1.inject({ scheduleRefresh() {} });
				if (nextID) rdtHook$1._instrumentationIsActive = true;
			}
			rdtHook$1.inject = (renderer) => {
				const id = prevInject(renderer);
				_renderers.add(renderer);
				rdtHook$1._instrumentationIsActive = true;
				onActiveListeners.forEach((listener) => listener());
				return id;
			};
		}
		if (rdtHook$1.renderers.size || rdtHook$1._instrumentationIsActive || isReactRefresh()) onActive?.();
	} catch {}
};
const hasRDTHook = () => {
	return objectHasOwnProperty.call(globalThis, "__REACT_DEVTOOLS_GLOBAL_HOOK__");
};
/**
* Returns the current React DevTools global hook.
*/
const getRDTHook = (onActive) => {
	if (!hasRDTHook()) return installRDTHook(onActive);
	patchRDTHook(onActive);
	return globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;
};
const isClientEnvironment = () => {
	return Boolean(typeof window !== "undefined" && (window.document?.createElement || window.navigator?.product === "ReactNative"));
};
/**
* Usually used purely for side effect
*/
const safelyInstallRDTHook = () => {
	try {
		if (isClientEnvironment()) getRDTHook();
	} catch {}
};
const FunctionComponentTag = 0;
const ClassComponentTag = 1;
const HostComponentTag = 5;
const ForwardRefTag = 11;
const SuspenseComponentTag = 13;
const MemoComponentTag = 14;
const SimpleMemoComponentTag = 15;
const HostHoistableTag = 26;
const HostSingletonTag = 27;
const MutationMask = 13366;
/**
* Returns `true` if fiber is a host fiber. Host fibers are DOM nodes in react-dom, `View` in react-native, etc.
*
* @see https://reactnative.dev/architecture/glossary#host-view-tree-and-host-view
*/
const isHostFiber = (fiber) => {
	switch (fiber.tag) {
		case HostComponentTag:
		case HostHoistableTag:
		case HostSingletonTag: return true;
		default: return typeof fiber.type === "string";
	}
};
/**
* Returns `true` if fiber is a composite fiber. Composite fibers are fibers that can render (like functional components, class components, etc.)
*
* @see https://reactnative.dev/architecture/glossary#react-composite-components
*/
const isCompositeFiber = (fiber) => {
	switch (fiber.tag) {
		case FunctionComponentTag:
		case ClassComponentTag:
		case SimpleMemoComponentTag:
		case MemoComponentTag:
		case ForwardRefTag: return true;
		default: return false;
	}
};
/**
* Traverses up or down a {@link Fiber}, return `true` to stop and select a node.
*/
const traverseFiber = (fiber, selector, ascending = false) => {
	if (!fiber) return null;
	if (selector(fiber) === true) return fiber;
	let child = ascending ? fiber.return : fiber.child;
	while (child) {
		const match = traverseFiber(child, selector, ascending);
		if (match) return match;
		child = ascending ? null : child.sibling;
	}
	return null;
};
/**
* Returns the timings of the {@link Fiber}.
*
* @example
* ```ts
* const { selfTime, totalTime } = getTimings(fiber);
* console.log(selfTime, totalTime);
* ```
*/
const getTimings = (fiber) => {
	const totalTime = fiber?.actualDuration ?? 0;
	let selfTime = totalTime;
	let child = fiber?.child ?? null;
	while (totalTime > 0 && child != null) {
		selfTime -= child.actualDuration ?? 0;
		child = child.sibling;
	}
	return {
		selfTime,
		totalTime
	};
};
/**
* Returns `true` if the {@link Fiber} uses React Compiler's memo cache.
*/
const hasMemoCache = (fiber) => {
	return Boolean(fiber.updateQueue?.memoCache);
};
/**
* Returns the type (e.g. component definition) of the {@link Fiber}
*/
const getType = (type) => {
	const currentType = type;
	if (typeof currentType === "function") return currentType;
	if (typeof currentType === "object" && currentType) return getType(currentType.type || currentType.render);
	return null;
};
/**
* Returns the display name of the {@link Fiber} type.
*/
const getDisplayName = (type) => {
	const currentType = type;
	if (typeof currentType === "string") return currentType;
	if (typeof currentType !== "function" && !(typeof currentType === "object" && currentType)) return null;
	const name = currentType.displayName || currentType.name || null;
	if (name) return name;
	const unwrappedType = getType(currentType);
	if (!unwrappedType) return null;
	return unwrappedType.displayName || unwrappedType.name || null;
};
/**
* Returns the build type of the React renderer.
*/
const detectReactBuildType = (renderer) => {
	try {
		if (typeof renderer.version === "string" && renderer.bundleType > 0) return "development";
	} catch {}
	return "production";
};
/**
* Returns `true` if bippy's instrumentation is active.
*/
const isInstrumentationActive = () => {
	const rdtHook$1 = getRDTHook();
	return Boolean(rdtHook$1._instrumentationIsActive) || isRealReactDevtools() || isReactRefresh();
};
var compat_module_exports = {};
import * as import_preact_hooks from "preact/hooks";
function g$1(n$1, t$1) {
	for (var e$1 in t$1) n$1[e$1] = t$1[e$1];
	return n$1;
}
function E$1(n$1, t$1) {
	for (var e$1 in n$1) if ("__source" !== e$1 && !(e$1 in t$1)) return !0;
	for (var r$2 in t$1) if ("__source" !== r$2 && n$1[r$2] !== t$1[r$2]) return !0;
	return !1;
}
function C$1(n$1, t$1) {
	var e$1 = t$1(), r$2 = useState$1({ t: {
		__: e$1,
		u: t$1
	} }), u$1 = r$2[0].t, o$1 = r$2[1];
	return useLayoutEffect$1(function() {
		u$1.__ = e$1, u$1.u = t$1, x$1(u$1) && o$1({ t: u$1 });
	}, [
		n$1,
		e$1,
		t$1
	]), useEffect$1(function() {
		return x$1(u$1) && o$1({ t: u$1 }), n$1(function() {
			x$1(u$1) && o$1({ t: u$1 });
		});
	}, [n$1]), e$1;
}
function x$1(n$1) {
	var t$1, e$1, r$2 = n$1.u, u$1 = n$1.__;
	try {
		var o$1 = r$2();
		return !((t$1 = u$1) === (e$1 = o$1) && (0 !== t$1 || 1 / t$1 == 1 / e$1) || t$1 != t$1 && e$1 != e$1);
	} catch (n$2) {
		return !0;
	}
}
function R(n$1) {
	n$1();
}
function w$1(n$1) {
	return n$1;
}
function k$1() {
	return [!1, R];
}
var I$1 = useLayoutEffect$1;
function N$1(n$1, t$1) {
	this.props = n$1, this.context = t$1;
}
function M(n$1, e$1) {
	function r$2(n$2) {
		var t$1 = this.props.ref, r$3 = t$1 == n$2.ref;
		return !r$3 && t$1 && (t$1.call ? t$1(null) : t$1.current = null), e$1 ? !e$1(this.props, n$2) || !r$3 : E$1(this.props, n$2);
	}
	function u$1(e$2) {
		return this.shouldComponentUpdate = r$2, createElement(n$1, e$2);
	}
	return u$1.displayName = "Memo(" + (n$1.displayName || n$1.name) + ")", u$1.prototype.isReactComponent = !0, u$1.__f = !0, u$1;
}
(N$1.prototype = new Component()).isPureReactComponent = !0, N$1.prototype.shouldComponentUpdate = function(n$1, t$1) {
	return E$1(this.props, n$1) || E$1(this.state, t$1);
};
var T$1 = /* @__PURE__ */ (() => options.__b)();
options.__b = function(n$1) {
	n$1.type && n$1.type.__f && n$1.ref && (n$1.props.ref = n$1.ref, n$1.ref = null), T$1 && T$1(n$1);
};
var A$1 = "undefined" != typeof Symbol && /* @__PURE__ */ (() => Symbol.for)() && /* @__PURE__ */ Symbol.for("react.forward_ref") || 3911;
function D(n$1) {
	function t$1(t$2) {
		var e$1 = g$1({}, t$2);
		return delete e$1.ref, n$1(e$1, t$2.ref || null);
	}
	return t$1.$$typeof = A$1, t$1.render = t$1, t$1.prototype.isReactComponent = t$1.__f = !0, t$1.displayName = "ForwardRef(" + (n$1.displayName || n$1.name) + ")", t$1;
}
var L$1 = function(n$1, t$1) {
	return null == n$1 ? null : toChildArray(toChildArray(n$1).map(t$1));
}, O$1 = {
	map: L$1,
	forEach: L$1,
	count: function(n$1) {
		return n$1 ? toChildArray(n$1).length : 0;
	},
	only: function(n$1) {
		var t$1 = toChildArray(n$1);
		if (1 !== t$1.length) throw "Children.only";
		return t$1[0];
	},
	toArray: toChildArray
}, F$1 = /* @__PURE__ */ (() => options.__e)();
options.__e = function(n$1, t$1, e$1, r$2) {
	if (n$1.then) {
		for (var u$1, o$1 = t$1; o$1 = o$1.__;) if ((u$1 = o$1.__c) && u$1.__c) return t$1.__e ?? (t$1.__e = e$1.__e, t$1.__k = e$1.__k), u$1.__c(n$1, t$1);
	}
	F$1(n$1, t$1, e$1, r$2);
};
var U = /* @__PURE__ */ (() => options.unmount)();
function V(n$1, t$1, e$1) {
	return n$1 && (n$1.__c && n$1.__c.__H && (n$1.__c.__H.__.forEach(function(n$2) {
		"function" == typeof n$2.__c && n$2.__c();
	}), n$1.__c.__H = null), null != (n$1 = g$1({}, n$1)).__c && (n$1.__c.__P === e$1 && (n$1.__c.__P = t$1), n$1.__c.__e = !0, n$1.__c = null), n$1.__k = n$1.__k && n$1.__k.map(function(n$2) {
		return V(n$2, t$1, e$1);
	})), n$1;
}
function W(n$1, t$1, e$1) {
	return n$1 && e$1 && (n$1.__v = null, n$1.__k = n$1.__k && n$1.__k.map(function(n$2) {
		return W(n$2, t$1, e$1);
	}), n$1.__c && n$1.__c.__P === t$1 && (n$1.__e && e$1.appendChild(n$1.__e), n$1.__c.__e = !0, n$1.__c.__P = e$1)), n$1;
}
function P$1() {
	this.__u = 0, this.o = null, this.__b = null;
}
function j(n$1) {
	var t$1 = n$1.__.__c;
	return t$1 && t$1.__a && t$1.__a(n$1);
}
function z(n$1) {
	var e$1, r$2, u$1;
	function o$1(o$2) {
		if (e$1 || (e$1 = n$1()).then(function(n$2) {
			r$2 = n$2.default || n$2;
		}, function(n$2) {
			u$1 = n$2;
		}), u$1) throw u$1;
		if (!r$2) throw e$1;
		return createElement(r$2, o$2);
	}
	return o$1.displayName = "Lazy", o$1.__f = !0, o$1;
}
function B$1() {
	this.i = null, this.l = null;
}
options.unmount = function(n$1) {
	var t$1 = n$1.__c;
	t$1 && t$1.__R && t$1.__R(), t$1 && 32 & n$1.__u && (n$1.type = null), U && U(n$1);
}, (P$1.prototype = new Component()).__c = function(n$1, t$1) {
	var e$1 = t$1.__c, r$2 = this;
	r$2.o ??= [], r$2.o.push(e$1);
	var u$1 = j(r$2.__v), o$1 = !1, i$1 = function() {
		o$1 || (o$1 = !0, e$1.__R = null, u$1 ? u$1(l$1) : l$1());
	};
	e$1.__R = i$1;
	var l$1 = function() {
		if (!--r$2.__u) {
			if (r$2.state.__a) {
				var n$2 = r$2.state.__a;
				r$2.__v.__k[0] = W(n$2, n$2.__c.__P, n$2.__c.__O);
			}
			var t$2;
			for (r$2.setState({ __a: r$2.__b = null }); t$2 = r$2.o.pop();) t$2.forceUpdate();
		}
	};
	r$2.__u++ || 32 & t$1.__u || r$2.setState({ __a: r$2.__b = r$2.__v.__k[0] }), n$1.then(i$1, i$1);
}, P$1.prototype.componentWillUnmount = function() {
	this.o = [];
}, P$1.prototype.render = function(n$1, e$1) {
	if (this.__b) {
		if (this.__v.__k) {
			var r$2 = document.createElement("div"), o$1 = this.__v.__k[0].__c;
			this.__v.__k[0] = V(this.__b, r$2, o$1.__O = o$1.__P);
		}
		this.__b = null;
	}
	var i$1 = e$1.__a && createElement(Fragment, null, n$1.fallback);
	return i$1 && (i$1.__u &= -33), [createElement(Fragment, null, e$1.__a ? null : n$1.children), i$1];
};
var H$1 = function(n$1, t$1, e$1) {
	if (++e$1[1] === e$1[0] && n$1.l.delete(t$1), n$1.props.revealOrder && ("t" !== n$1.props.revealOrder[0] || !n$1.l.size)) for (e$1 = n$1.i; e$1;) {
		for (; e$1.length > 3;) e$1.pop()();
		if (e$1[1] < e$1[0]) break;
		n$1.i = e$1 = e$1[2];
	}
};
function Z(n$1) {
	return this.getChildContext = function() {
		return n$1.context;
	}, n$1.children;
}
function Y(n$1) {
	var e$1 = this, r$2 = n$1.h;
	if (e$1.componentWillUnmount = function() {
		render(null, e$1.v), e$1.v = null, e$1.h = null;
	}, e$1.h && e$1.h !== r$2 && e$1.componentWillUnmount(), !e$1.v) {
		for (var u$1 = e$1.__v; null !== u$1 && !u$1.__m && null !== u$1.__;) u$1 = u$1.__;
		e$1.h = r$2, e$1.v = {
			nodeType: 1,
			parentNode: r$2,
			childNodes: [],
			__k: { __m: u$1.__m },
			contains: function() {
				return !0;
			},
			insertBefore: function(n$2, t$1) {
				this.childNodes.push(n$2), e$1.h.insertBefore(n$2, t$1);
			},
			removeChild: function(n$2) {
				this.childNodes.splice(this.childNodes.indexOf(n$2) >>> 1, 1), e$1.h.removeChild(n$2);
			}
		};
	}
	render(createElement(Z, { context: e$1.context }, n$1.__v), e$1.v);
}
function $$1(n$1, e$1) {
	var r$2 = createElement(Y, {
		__v: n$1,
		h: e$1
	});
	return r$2.containerInfo = e$1, r$2;
}
(B$1.prototype = new Component()).__a = function(n$1) {
	var t$1 = this, e$1 = j(t$1.__v), r$2 = t$1.l.get(n$1);
	return r$2[0]++, function(u$1) {
		var o$1 = function() {
			t$1.props.revealOrder ? (r$2.push(u$1), H$1(t$1, n$1, r$2)) : u$1();
		};
		e$1 ? e$1(o$1) : o$1();
	};
}, B$1.prototype.render = function(n$1) {
	this.i = null, this.l = /* @__PURE__ */ new Map();
	var t$1 = toChildArray(n$1.children);
	n$1.revealOrder && "b" === n$1.revealOrder[0] && t$1.reverse();
	for (var e$1 = t$1.length; e$1--;) this.l.set(t$1[e$1], this.i = [
		1,
		0,
		this.i
	]);
	return n$1.children;
}, B$1.prototype.componentDidUpdate = B$1.prototype.componentDidMount = function() {
	var n$1 = this;
	this.l.forEach(function(t$1, e$1) {
		H$1(n$1, e$1, t$1);
	});
};
var q$1 = "undefined" != typeof Symbol && /* @__PURE__ */ (() => Symbol.for)() && /* @__PURE__ */ Symbol.for("react.element") || 60103, G = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, J = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, K = /[A-Z0-9]/g, Q = "undefined" != typeof document, X = function(n$1) {
	return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n$1);
};
function nn(n$1, t$1, e$1) {
	return t$1.__k ?? (t$1.textContent = ""), render(n$1, t$1), "function" == typeof e$1 && e$1(), n$1 ? n$1.__c : null;
}
function tn(n$1, t$1, e$1) {
	return hydrate(n$1, t$1), "function" == typeof e$1 && e$1(), n$1 ? n$1.__c : null;
}
Component.prototype.isReactComponent = {};
var en = /* @__PURE__ */ (() => options.event)();
function rn() {}
function un() {
	return this.cancelBubble;
}
function on() {
	return this.defaultPrevented;
}
options.event = function(n$1) {
	return en && (n$1 = en(n$1)), n$1.persist = rn, n$1.isPropagationStopped = un, n$1.isDefaultPrevented = on, n$1.nativeEvent = n$1;
};
var ln, cn$1 = {
	enumerable: !1,
	configurable: !0,
	get: function() {
		return this.class;
	}
}, fn = /* @__PURE__ */ (() => options.vnode)();
options.vnode = function(n$1) {
	"string" == typeof n$1.type && function(n$2) {
		var t$1 = n$2.props, e$1 = n$2.type, u$1 = {}, o$1 = -1 === e$1.indexOf("-");
		for (var i$1 in t$1) {
			var l$1 = t$1[i$1];
			if (!("value" === i$1 && "defaultValue" in t$1 && null == l$1 || Q && "children" === i$1 && "noscript" === e$1 || "class" === i$1 || "className" === i$1)) {
				var c$1 = i$1.toLowerCase();
				"defaultValue" === i$1 && "value" in t$1 && null == t$1.value ? i$1 = "value" : "download" === i$1 && !0 === l$1 ? l$1 = "" : "translate" === c$1 && "no" === l$1 ? l$1 = !1 : "o" === c$1[0] && "n" === c$1[1] ? "ondoubleclick" === c$1 ? i$1 = "ondblclick" : "onchange" !== c$1 || "input" !== e$1 && "textarea" !== e$1 || X(t$1.type) ? "onfocus" === c$1 ? i$1 = "onfocusin" : "onblur" === c$1 ? i$1 = "onfocusout" : J.test(i$1) && (i$1 = c$1) : c$1 = i$1 = "oninput" : o$1 && G.test(i$1) ? i$1 = i$1.replace(K, "-$&").toLowerCase() : null === l$1 && (l$1 = void 0), "oninput" === c$1 && u$1[i$1 = c$1] && (i$1 = "oninputCapture"), u$1[i$1] = l$1;
			}
		}
		"select" == e$1 && u$1.multiple && Array.isArray(u$1.value) && (u$1.value = toChildArray(t$1.children).forEach(function(n$3) {
			n$3.props.selected = -1 != u$1.value.indexOf(n$3.props.value);
		})), "select" == e$1 && null != u$1.defaultValue && (u$1.value = toChildArray(t$1.children).forEach(function(n$3) {
			n$3.props.selected = u$1.multiple ? -1 != u$1.defaultValue.indexOf(n$3.props.value) : u$1.defaultValue == n$3.props.value;
		})), t$1.class && !t$1.className ? (u$1.class = t$1.class, Object.defineProperty(u$1, "className", cn$1)) : (t$1.className && !t$1.class || t$1.class && t$1.className) && (u$1.class = u$1.className = t$1.className), n$2.props = u$1;
	}(n$1), n$1.$$typeof = q$1, fn && fn(n$1);
};
var an = /* @__PURE__ */ (() => options.__r)();
options.__r = function(n$1) {
	an && an(n$1), ln = n$1.__c;
};
var sn = /* @__PURE__ */ (() => options.diffed)();
options.diffed = function(n$1) {
	sn && sn(n$1);
	var t$1 = n$1.props, e$1 = n$1.__e;
	null != e$1 && "textarea" === n$1.type && "value" in t$1 && t$1.value !== e$1.value && (e$1.value = null == t$1.value ? "" : t$1.value), ln = null;
};
var hn = { ReactCurrentDispatcher: { current: {
	readContext: function(n$1) {
		return ln.__n[n$1.__c].props.value;
	},
	useCallback: useCallback$1,
	useContext: useContext$1,
	useDebugValue,
	useDeferredValue: w$1,
	useEffect: useEffect$1,
	useId: useId$1,
	useImperativeHandle,
	useInsertionEffect: I$1,
	useLayoutEffect: useLayoutEffect$1,
	useMemo: useMemo$1,
	useReducer,
	useRef: useRef$1,
	useState: useState$1,
	useSyncExternalStore: C$1,
	useTransition: k$1
} } }, vn = "18.3.1";
function dn(n$1) {
	return createElement.bind(null, n$1);
}
function mn(n$1) {
	return !!n$1 && n$1.$$typeof === q$1;
}
function pn(n$1) {
	return mn(n$1) && n$1.type === Fragment;
}
function yn(n$1) {
	return !!n$1 && !!n$1.displayName && ("string" == typeof n$1.displayName || n$1.displayName instanceof String) && n$1.displayName.startsWith("Memo(");
}
function _n(n$1) {
	return mn(n$1) ? cloneElement.apply(null, arguments) : n$1;
}
function bn(n$1) {
	return !!n$1.__k && (render(null, n$1), !0);
}
function Sn(n$1) {
	return n$1 && (n$1.base || 1 === n$1.nodeType && n$1) || null;
}
var gn = function(n$1, t$1) {
	return n$1(t$1);
}, En = function(n$1, t$1) {
	return n$1(t$1);
}, Cn = Fragment, xn = mn, Rn = {
	useState: useState$1,
	useId: useId$1,
	useReducer,
	useEffect: useEffect$1,
	useLayoutEffect: useLayoutEffect$1,
	useInsertionEffect: I$1,
	useTransition: k$1,
	useDeferredValue: w$1,
	useSyncExternalStore: C$1,
	startTransition: R,
	useRef: useRef$1,
	useImperativeHandle,
	useMemo: useMemo$1,
	useCallback: useCallback$1,
	useContext: useContext$1,
	useDebugValue,
	version: "18.3.1",
	Children: O$1,
	render: nn,
	hydrate: tn,
	unmountComponentAtNode: bn,
	createPortal: $$1,
	createElement,
	createContext: createContext$1,
	createFactory: dn,
	cloneElement: _n,
	createRef,
	Fragment,
	isValidElement: mn,
	isElement: xn,
	isFragment: pn,
	isMemo: yn,
	findDOMNode: Sn,
	Component,
	PureComponent: N$1,
	memo: M,
	forwardRef: D,
	flushSync: En,
	unstable_batchedUpdates: gn,
	StrictMode: Cn,
	Suspense: P$1,
	SuspenseList: B$1,
	lazy: z,
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn
};
const Icon = /* @__PURE__ */ D(({ size = 15, name, fill = "currentColor", stroke = "currentColor", className, externalURL = "", style }, ref) => {
	const width = Array.isArray(size) ? size[0] : size;
	const height = Array.isArray(size) ? size[1] || size[0] : size;
	const path = `${externalURL}#${name}`;
	return /* @__PURE__ */ jsxs("svg", {
		ref,
		width: `${width}px`,
		height: `${height}px`,
		fill,
		stroke,
		className,
		style: {
			...style,
			minWidth: `${width}px`,
			maxWidth: `${width}px`,
			minHeight: `${height}px`,
			maxHeight: `${height}px`
		},
		children: [/* @__PURE__ */ jsx("title", { children: name }), /* @__PURE__ */ jsx("use", { href: path })]
	});
});
function r$1(e$1) {
	var t$1, f$1, n$1 = "";
	if ("string" == typeof e$1 || "number" == typeof e$1) n$1 += e$1;
	else if ("object" == typeof e$1) if (Array.isArray(e$1)) {
		var o$1 = e$1.length;
		for (t$1 = 0; t$1 < o$1; t$1++) e$1[t$1] && (f$1 = r$1(e$1[t$1])) && (n$1 && (n$1 += " "), n$1 += f$1);
	} else for (f$1 in e$1) e$1[f$1] && (n$1 && (n$1 += " "), n$1 += f$1);
	return n$1;
}
function clsx() {
	for (var e$1, t$1, f$1 = 0, n$1 = "", o$1 = arguments.length; f$1 < o$1; f$1++) (e$1 = arguments[f$1]) && (t$1 = r$1(e$1)) && (n$1 && (n$1 += " "), n$1 += t$1);
	return n$1;
}
const IS_CLIENT = typeof window !== "undefined";
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
	const classMap = createClassMap(config);
	const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
	const getClassGroupId = (className) => {
		const classParts = className.split(CLASS_PART_SEPARATOR);
		if (classParts[0] === "" && classParts.length !== 1) classParts.shift();
		return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
	};
	const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
		const conflicts = conflictingClassGroups[classGroupId] || [];
		if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
		return conflicts;
	};
	return {
		getClassGroupId,
		getConflictingClassGroupIds
	};
};
const getGroupRecursive = (classParts, classPartObject) => {
	if (classParts.length === 0) return classPartObject.classGroupId;
	const currentClassPart = classParts[0];
	const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
	const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
	if (classGroupFromNextClassPart) return classGroupFromNextClassPart;
	if (classPartObject.validators.length === 0) return void 0;
	const classRest = classParts.join(CLASS_PART_SEPARATOR);
	return classPartObject.validators.find(({ validator }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
	if (arbitraryPropertyRegex.test(className)) {
		const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
		const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
		if (property) return "arbitrary.." + property;
	}
};
/**
* Exported for testing only
*/
const createClassMap = (config) => {
	const { theme, classGroups } = config;
	const classMap = {
		nextPart: /* @__PURE__ */ new Map(),
		validators: []
	};
	for (const classGroupId in classGroups) processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
	return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
	classGroup.forEach((classDefinition) => {
		if (typeof classDefinition === "string") {
			const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
			classPartObjectToEdit.classGroupId = classGroupId;
			return;
		}
		if (typeof classDefinition === "function") {
			if (isThemeGetter(classDefinition)) {
				processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
				return;
			}
			classPartObject.validators.push({
				validator: classDefinition,
				classGroupId
			});
			return;
		}
		Object.entries(classDefinition).forEach(([key, classGroup$1]) => {
			processClassesRecursively(classGroup$1, getPart(classPartObject, key), classGroupId, theme);
		});
	});
};
const getPart = (classPartObject, path) => {
	let currentClassPartObject = classPartObject;
	path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
		if (!currentClassPartObject.nextPart.has(pathPart)) currentClassPartObject.nextPart.set(pathPart, {
			nextPart: /* @__PURE__ */ new Map(),
			validators: []
		});
		currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
	});
	return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const createLruCache = (maxCacheSize) => {
	if (maxCacheSize < 1) return {
		get: () => void 0,
		set: () => {}
	};
	let cacheSize = 0;
	let cache = /* @__PURE__ */ new Map();
	let previousCache = /* @__PURE__ */ new Map();
	const update = (key, value) => {
		cache.set(key, value);
		cacheSize++;
		if (cacheSize > maxCacheSize) {
			cacheSize = 0;
			previousCache = cache;
			cache = /* @__PURE__ */ new Map();
		}
	};
	return {
		get(key) {
			let value = cache.get(key);
			if (value !== void 0) return value;
			if ((value = previousCache.get(key)) !== void 0) {
				update(key, value);
				return value;
			}
		},
		set(key, value) {
			if (cache.has(key)) cache.set(key, value);
			else update(key, value);
		}
	};
};
const IMPORTANT_MODIFIER = "!";
const MODIFIER_SEPARATOR = ":";
const MODIFIER_SEPARATOR_LENGTH = 1;
const createParseClassName = (config) => {
	const { prefix, experimentalParseClassName } = config;
	/**
	* Parse class name into parts.
	*
	* Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
	* @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
	*/
	let parseClassName = (className) => {
		const modifiers = [];
		let bracketDepth = 0;
		let parenDepth = 0;
		let modifierStart = 0;
		let postfixModifierPosition;
		for (let index = 0; index < className.length; index++) {
			let currentCharacter = className[index];
			if (bracketDepth === 0 && parenDepth === 0) {
				if (currentCharacter === MODIFIER_SEPARATOR) {
					modifiers.push(className.slice(modifierStart, index));
					modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
					continue;
				}
				if (currentCharacter === "/") {
					postfixModifierPosition = index;
					continue;
				}
			}
			if (currentCharacter === "[") bracketDepth++;
			else if (currentCharacter === "]") bracketDepth--;
			else if (currentCharacter === "(") parenDepth++;
			else if (currentCharacter === ")") parenDepth--;
		}
		const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
		const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
		const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
		const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
		return {
			modifiers,
			hasImportantModifier,
			baseClassName,
			maybePostfixModifierPosition
		};
	};
	if (prefix) {
		const fullPrefix = prefix + MODIFIER_SEPARATOR;
		const parseClassNameOriginal = parseClassName;
		parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
			isExternal: true,
			modifiers: [],
			hasImportantModifier: false,
			baseClassName: className,
			maybePostfixModifierPosition: void 0
		};
	}
	if (experimentalParseClassName) {
		const parseClassNameOriginal = parseClassName;
		parseClassName = (className) => experimentalParseClassName({
			className,
			parseClassName: parseClassNameOriginal
		});
	}
	return parseClassName;
};
const stripImportantModifier = (baseClassName) => {
	if (baseClassName.endsWith(IMPORTANT_MODIFIER)) return baseClassName.substring(0, baseClassName.length - 1);
	/**
	* In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
	* @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
	*/
	if (baseClassName.startsWith(IMPORTANT_MODIFIER)) return baseClassName.substring(1);
	return baseClassName;
};
/**
* Sorts modifiers according to following schema:
* - Predefined modifiers are sorted alphabetically
* - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
*/
const createSortModifiers = (config) => {
	const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
	const sortModifiers = (modifiers) => {
		if (modifiers.length <= 1) return modifiers;
		const sortedModifiers = [];
		let unsortedModifiers = [];
		modifiers.forEach((modifier) => {
			const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
			if (isPositionSensitive) {
				sortedModifiers.push(...unsortedModifiers.sort(), modifier);
				unsortedModifiers = [];
			} else unsortedModifiers.push(modifier);
		});
		sortedModifiers.push(...unsortedModifiers.sort());
		return sortedModifiers;
	};
	return sortModifiers;
};
const createConfigUtils = (config) => ({
	cache: createLruCache(config.cacheSize),
	parseClassName: createParseClassName(config),
	sortModifiers: createSortModifiers(config),
	...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
	const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } = configUtils;
	/**
	* Set of classGroupIds in following format:
	* `{importantModifier}{variantModifiers}{classGroupId}`
	* @example 'float'
	* @example 'hover:focus:bg-color'
	* @example 'md:!pr'
	*/
	const classGroupsInConflict = [];
	const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
	let result = "";
	for (let index = classNames.length - 1; index >= 0; index -= 1) {
		const originalClassName = classNames[index];
		const { isExternal, modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition } = parseClassName(originalClassName);
		if (isExternal) {
			result = originalClassName + (result.length > 0 ? " " + result : result);
			continue;
		}
		let hasPostfixModifier = !!maybePostfixModifierPosition;
		let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
		if (!classGroupId) {
			if (!hasPostfixModifier) {
				result = originalClassName + (result.length > 0 ? " " + result : result);
				continue;
			}
			classGroupId = getClassGroupId(baseClassName);
			if (!classGroupId) {
				result = originalClassName + (result.length > 0 ? " " + result : result);
				continue;
			}
			hasPostfixModifier = false;
		}
		const variantModifier = sortModifiers(modifiers).join(":");
		const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
		const classId = modifierId + classGroupId;
		if (classGroupsInConflict.includes(classId)) continue;
		classGroupsInConflict.push(classId);
		const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
		for (let i$1 = 0; i$1 < conflictGroups.length; ++i$1) {
			const group = conflictGroups[i$1];
			classGroupsInConflict.push(modifierId + group);
		}
		result = originalClassName + (result.length > 0 ? " " + result : result);
	}
	return result;
};
/**
* The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
*
* Specifically:
* - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
* - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
*
* Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
*/
function twJoin() {
	let index = 0;
	let argument;
	let resolvedValue;
	let string = "";
	while (index < arguments.length) if (argument = arguments[index++]) {
		if (resolvedValue = toValue(argument)) {
			string && (string += " ");
			string += resolvedValue;
		}
	}
	return string;
}
const toValue = (mix) => {
	if (typeof mix === "string") return mix;
	let resolvedValue;
	let string = "";
	for (let k$2 = 0; k$2 < mix.length; k$2++) if (mix[k$2]) {
		if (resolvedValue = toValue(mix[k$2])) {
			string && (string += " ");
			string += resolvedValue;
		}
	}
	return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
	let configUtils;
	let cacheGet;
	let cacheSet;
	let functionToCall = initTailwindMerge;
	function initTailwindMerge(classList) {
		const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
		configUtils = createConfigUtils(config);
		cacheGet = configUtils.cache.get;
		cacheSet = configUtils.cache.set;
		functionToCall = tailwindMerge;
		return tailwindMerge(classList);
	}
	function tailwindMerge(classList) {
		const cachedResult = cacheGet(classList);
		if (cachedResult) return cachedResult;
		const result = mergeClassList(classList, configUtils);
		cacheSet(classList, result);
		return result;
	}
	return function callTailwindMerge() {
		return functionToCall(twJoin.apply(null, arguments));
	};
}
const fromTheme = (key) => {
	const themeGetter = (theme) => theme[key] || [];
	themeGetter.isThemeGetter = true;
	return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value) => fractionRegex.test(value);
const isNumber = (value) => !!value && !Number.isNaN(Number(value));
const isInteger = (value) => !!value && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const isAny = () => true;
const isLengthOnly = (value) => lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
const getIsArbitraryValue = (value, testLabel, testValue) => {
	const result = arbitraryValueRegex.exec(value);
	if (result) {
		if (result[1]) return testLabel(result[1]);
		return testValue(result[2]);
	}
	return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
	const result = arbitraryVariableRegex.exec(value);
	if (result) {
		if (result[1]) return testLabel(result[1]);
		return shouldMatchNoLabel;
	}
	return false;
};
const isLabelPosition = (label) => label === "position" || label === "percentage";
const isLabelImage = (label) => label === "image" || label === "url";
const isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
const isLabelLength = (label) => label === "length";
const isLabelNumber = (label) => label === "number";
const isLabelFamilyName = (label) => label === "family-name";
const isLabelShadow = (label) => label === "shadow";
const getDefaultConfig = () => {
	/**
	* Theme getters for theme variable namespaces
	* @see https://tailwindcss.com/docs/theme#theme-variable-namespaces
	*/
	const themeColor = fromTheme("color");
	const themeFont = fromTheme("font");
	const themeText = fromTheme("text");
	const themeFontWeight = fromTheme("font-weight");
	const themeTracking = fromTheme("tracking");
	const themeLeading = fromTheme("leading");
	const themeBreakpoint = fromTheme("breakpoint");
	const themeContainer = fromTheme("container");
	const themeSpacing = fromTheme("spacing");
	const themeRadius = fromTheme("radius");
	const themeShadow = fromTheme("shadow");
	const themeInsetShadow = fromTheme("inset-shadow");
	const themeTextShadow = fromTheme("text-shadow");
	const themeDropShadow = fromTheme("drop-shadow");
	const themeBlur = fromTheme("blur");
	const themePerspective = fromTheme("perspective");
	const themeAspect = fromTheme("aspect");
	const themeEase = fromTheme("ease");
	const themeAnimate = fromTheme("animate");
	/**
	* Helpers to avoid repeating the same scales
	*
	* We use functions that create a new array every time they're called instead of static arrays.
	* This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.
	*/
	const scaleBreak = () => [
		"auto",
		"avoid",
		"all",
		"avoid-page",
		"page",
		"left",
		"right",
		"column"
	];
	const scalePosition = () => [
		"center",
		"top",
		"bottom",
		"left",
		"right",
		"top-left",
		"left-top",
		"top-right",
		"right-top",
		"bottom-right",
		"right-bottom",
		"bottom-left",
		"left-bottom"
	];
	const scalePositionWithArbitrary = () => [
		...scalePosition(),
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleOverflow = () => [
		"auto",
		"hidden",
		"clip",
		"visible",
		"scroll"
	];
	const scaleOverscroll = () => [
		"auto",
		"contain",
		"none"
	];
	const scaleUnambiguousSpacing = () => [
		isArbitraryVariable,
		isArbitraryValue,
		themeSpacing
	];
	const scaleInset = () => [
		isFraction,
		"full",
		"auto",
		...scaleUnambiguousSpacing()
	];
	const scaleGridTemplateColsRows = () => [
		isInteger,
		"none",
		"subgrid",
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleGridColRowStartAndEnd = () => [
		"auto",
		{ span: [
			"full",
			isInteger,
			isArbitraryVariable,
			isArbitraryValue
		] },
		isInteger,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleGridColRowStartOrEnd = () => [
		isInteger,
		"auto",
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleGridAutoColsRows = () => [
		"auto",
		"min",
		"max",
		"fr",
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleAlignPrimaryAxis = () => [
		"start",
		"end",
		"center",
		"between",
		"around",
		"evenly",
		"stretch",
		"baseline",
		"center-safe",
		"end-safe"
	];
	const scaleAlignSecondaryAxis = () => [
		"start",
		"end",
		"center",
		"stretch",
		"center-safe",
		"end-safe"
	];
	const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
	const scaleSizing = () => [
		isFraction,
		"auto",
		"full",
		"dvw",
		"dvh",
		"lvw",
		"lvh",
		"svw",
		"svh",
		"min",
		"max",
		"fit",
		...scaleUnambiguousSpacing()
	];
	const scaleColor = () => [
		themeColor,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleBgPosition = () => [
		...scalePosition(),
		isArbitraryVariablePosition,
		isArbitraryPosition,
		{ position: [isArbitraryVariable, isArbitraryValue] }
	];
	const scaleBgRepeat = () => ["no-repeat", { repeat: [
		"",
		"x",
		"y",
		"space",
		"round"
	] }];
	const scaleBgSize = () => [
		"auto",
		"cover",
		"contain",
		isArbitraryVariableSize,
		isArbitrarySize,
		{ size: [isArbitraryVariable, isArbitraryValue] }
	];
	const scaleGradientStopPosition = () => [
		isPercent,
		isArbitraryVariableLength,
		isArbitraryLength
	];
	const scaleRadius = () => [
		"",
		"none",
		"full",
		themeRadius,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleBorderWidth = () => [
		"",
		isNumber,
		isArbitraryVariableLength,
		isArbitraryLength
	];
	const scaleLineStyle = () => [
		"solid",
		"dashed",
		"dotted",
		"double"
	];
	const scaleBlendMode = () => [
		"normal",
		"multiply",
		"screen",
		"overlay",
		"darken",
		"lighten",
		"color-dodge",
		"color-burn",
		"hard-light",
		"soft-light",
		"difference",
		"exclusion",
		"hue",
		"saturation",
		"color",
		"luminosity"
	];
	const scaleMaskImagePosition = () => [
		isNumber,
		isPercent,
		isArbitraryVariablePosition,
		isArbitraryPosition
	];
	const scaleBlur = () => [
		"",
		"none",
		themeBlur,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleRotate = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleScale = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleSkew = () => [
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	];
	const scaleTranslate = () => [
		isFraction,
		"full",
		...scaleUnambiguousSpacing()
	];
	return {
		cacheSize: 500,
		theme: {
			animate: [
				"spin",
				"ping",
				"pulse",
				"bounce"
			],
			aspect: ["video"],
			blur: [isTshirtSize],
			breakpoint: [isTshirtSize],
			color: [isAny],
			container: [isTshirtSize],
			"drop-shadow": [isTshirtSize],
			ease: [
				"in",
				"out",
				"in-out"
			],
			font: [isAnyNonArbitrary],
			"font-weight": [
				"thin",
				"extralight",
				"light",
				"normal",
				"medium",
				"semibold",
				"bold",
				"extrabold",
				"black"
			],
			"inset-shadow": [isTshirtSize],
			leading: [
				"none",
				"tight",
				"snug",
				"normal",
				"relaxed",
				"loose"
			],
			perspective: [
				"dramatic",
				"near",
				"normal",
				"midrange",
				"distant",
				"none"
			],
			radius: [isTshirtSize],
			shadow: [isTshirtSize],
			spacing: ["px", isNumber],
			text: [isTshirtSize],
			"text-shadow": [isTshirtSize],
			tracking: [
				"tighter",
				"tight",
				"normal",
				"wide",
				"wider",
				"widest"
			]
		},
		classGroups: {
			aspect: [{ aspect: [
				"auto",
				"square",
				isFraction,
				isArbitraryValue,
				isArbitraryVariable,
				themeAspect
			] }],
			container: ["container"],
			columns: [{ columns: [
				isNumber,
				isArbitraryValue,
				isArbitraryVariable,
				themeContainer
			] }],
			"break-after": [{ "break-after": scaleBreak() }],
			"break-before": [{ "break-before": scaleBreak() }],
			"break-inside": [{ "break-inside": [
				"auto",
				"avoid",
				"avoid-page",
				"avoid-column"
			] }],
			"box-decoration": [{ "box-decoration": ["slice", "clone"] }],
			box: [{ box: ["border", "content"] }],
			display: [
				"block",
				"inline-block",
				"inline",
				"flex",
				"inline-flex",
				"table",
				"inline-table",
				"table-caption",
				"table-cell",
				"table-column",
				"table-column-group",
				"table-footer-group",
				"table-header-group",
				"table-row-group",
				"table-row",
				"flow-root",
				"grid",
				"inline-grid",
				"contents",
				"list-item",
				"hidden"
			],
			sr: ["sr-only", "not-sr-only"],
			float: [{ float: [
				"right",
				"left",
				"none",
				"start",
				"end"
			] }],
			clear: [{ clear: [
				"left",
				"right",
				"both",
				"none",
				"start",
				"end"
			] }],
			isolation: ["isolate", "isolation-auto"],
			"object-fit": [{ object: [
				"contain",
				"cover",
				"fill",
				"none",
				"scale-down"
			] }],
			"object-position": [{ object: scalePositionWithArbitrary() }],
			overflow: [{ overflow: scaleOverflow() }],
			"overflow-x": [{ "overflow-x": scaleOverflow() }],
			"overflow-y": [{ "overflow-y": scaleOverflow() }],
			overscroll: [{ overscroll: scaleOverscroll() }],
			"overscroll-x": [{ "overscroll-x": scaleOverscroll() }],
			"overscroll-y": [{ "overscroll-y": scaleOverscroll() }],
			position: [
				"static",
				"fixed",
				"absolute",
				"relative",
				"sticky"
			],
			inset: [{ inset: scaleInset() }],
			"inset-x": [{ "inset-x": scaleInset() }],
			"inset-y": [{ "inset-y": scaleInset() }],
			start: [{ start: scaleInset() }],
			end: [{ end: scaleInset() }],
			top: [{ top: scaleInset() }],
			right: [{ right: scaleInset() }],
			bottom: [{ bottom: scaleInset() }],
			left: [{ left: scaleInset() }],
			visibility: [
				"visible",
				"invisible",
				"collapse"
			],
			z: [{ z: [
				isInteger,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			basis: [{ basis: [
				isFraction,
				"full",
				"auto",
				themeContainer,
				...scaleUnambiguousSpacing()
			] }],
			"flex-direction": [{ flex: [
				"row",
				"row-reverse",
				"col",
				"col-reverse"
			] }],
			"flex-wrap": [{ flex: [
				"nowrap",
				"wrap",
				"wrap-reverse"
			] }],
			flex: [{ flex: [
				isNumber,
				isFraction,
				"auto",
				"initial",
				"none",
				isArbitraryValue
			] }],
			grow: [{ grow: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			shrink: [{ shrink: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			order: [{ order: [
				isInteger,
				"first",
				"last",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"grid-cols": [{ "grid-cols": scaleGridTemplateColsRows() }],
			"col-start-end": [{ col: scaleGridColRowStartAndEnd() }],
			"col-start": [{ "col-start": scaleGridColRowStartOrEnd() }],
			"col-end": [{ "col-end": scaleGridColRowStartOrEnd() }],
			"grid-rows": [{ "grid-rows": scaleGridTemplateColsRows() }],
			"row-start-end": [{ row: scaleGridColRowStartAndEnd() }],
			"row-start": [{ "row-start": scaleGridColRowStartOrEnd() }],
			"row-end": [{ "row-end": scaleGridColRowStartOrEnd() }],
			"grid-flow": [{ "grid-flow": [
				"row",
				"col",
				"dense",
				"row-dense",
				"col-dense"
			] }],
			"auto-cols": [{ "auto-cols": scaleGridAutoColsRows() }],
			"auto-rows": [{ "auto-rows": scaleGridAutoColsRows() }],
			gap: [{ gap: scaleUnambiguousSpacing() }],
			"gap-x": [{ "gap-x": scaleUnambiguousSpacing() }],
			"gap-y": [{ "gap-y": scaleUnambiguousSpacing() }],
			"justify-content": [{ justify: [...scaleAlignPrimaryAxis(), "normal"] }],
			"justify-items": [{ "justify-items": [...scaleAlignSecondaryAxis(), "normal"] }],
			"justify-self": [{ "justify-self": ["auto", ...scaleAlignSecondaryAxis()] }],
			"align-content": [{ content: ["normal", ...scaleAlignPrimaryAxis()] }],
			"align-items": [{ items: [...scaleAlignSecondaryAxis(), { baseline: ["", "last"] }] }],
			"align-self": [{ self: [
				"auto",
				...scaleAlignSecondaryAxis(),
				{ baseline: ["", "last"] }
			] }],
			"place-content": [{ "place-content": scaleAlignPrimaryAxis() }],
			"place-items": [{ "place-items": [...scaleAlignSecondaryAxis(), "baseline"] }],
			"place-self": [{ "place-self": ["auto", ...scaleAlignSecondaryAxis()] }],
			p: [{ p: scaleUnambiguousSpacing() }],
			px: [{ px: scaleUnambiguousSpacing() }],
			py: [{ py: scaleUnambiguousSpacing() }],
			ps: [{ ps: scaleUnambiguousSpacing() }],
			pe: [{ pe: scaleUnambiguousSpacing() }],
			pt: [{ pt: scaleUnambiguousSpacing() }],
			pr: [{ pr: scaleUnambiguousSpacing() }],
			pb: [{ pb: scaleUnambiguousSpacing() }],
			pl: [{ pl: scaleUnambiguousSpacing() }],
			m: [{ m: scaleMargin() }],
			mx: [{ mx: scaleMargin() }],
			my: [{ my: scaleMargin() }],
			ms: [{ ms: scaleMargin() }],
			me: [{ me: scaleMargin() }],
			mt: [{ mt: scaleMargin() }],
			mr: [{ mr: scaleMargin() }],
			mb: [{ mb: scaleMargin() }],
			ml: [{ ml: scaleMargin() }],
			"space-x": [{ "space-x": scaleUnambiguousSpacing() }],
			"space-x-reverse": ["space-x-reverse"],
			"space-y": [{ "space-y": scaleUnambiguousSpacing() }],
			"space-y-reverse": ["space-y-reverse"],
			size: [{ size: scaleSizing() }],
			w: [{ w: [
				themeContainer,
				"screen",
				...scaleSizing()
			] }],
			"min-w": [{ "min-w": [
				themeContainer,
				"screen",
				"none",
				...scaleSizing()
			] }],
			"max-w": [{ "max-w": [
				themeContainer,
				"screen",
				"none",
				"prose",
				{ screen: [themeBreakpoint] },
				...scaleSizing()
			] }],
			h: [{ h: [
				"screen",
				"lh",
				...scaleSizing()
			] }],
			"min-h": [{ "min-h": [
				"screen",
				"lh",
				"none",
				...scaleSizing()
			] }],
			"max-h": [{ "max-h": [
				"screen",
				"lh",
				...scaleSizing()
			] }],
			"font-size": [{ text: [
				"base",
				themeText,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"font-smoothing": ["antialiased", "subpixel-antialiased"],
			"font-style": ["italic", "not-italic"],
			"font-weight": [{ font: [
				themeFontWeight,
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			"font-stretch": [{ "font-stretch": [
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"normal",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
				isPercent,
				isArbitraryValue
			] }],
			"font-family": [{ font: [
				isArbitraryVariableFamilyName,
				isArbitraryValue,
				themeFont
			] }],
			"fvn-normal": ["normal-nums"],
			"fvn-ordinal": ["ordinal"],
			"fvn-slashed-zero": ["slashed-zero"],
			"fvn-figure": ["lining-nums", "oldstyle-nums"],
			"fvn-spacing": ["proportional-nums", "tabular-nums"],
			"fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
			tracking: [{ tracking: [
				themeTracking,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"line-clamp": [{ "line-clamp": [
				isNumber,
				"none",
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			leading: [{ leading: [themeLeading, ...scaleUnambiguousSpacing()] }],
			"list-image": [{ "list-image": [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"list-style-position": [{ list: ["inside", "outside"] }],
			"list-style-type": [{ list: [
				"disc",
				"decimal",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-alignment": [{ text: [
				"left",
				"center",
				"right",
				"justify",
				"start",
				"end"
			] }],
			"placeholder-color": [{ placeholder: scaleColor() }],
			"text-color": [{ text: scaleColor() }],
			"text-decoration": [
				"underline",
				"overline",
				"line-through",
				"no-underline"
			],
			"text-decoration-style": [{ decoration: [...scaleLineStyle(), "wavy"] }],
			"text-decoration-thickness": [{ decoration: [
				isNumber,
				"from-font",
				"auto",
				isArbitraryVariable,
				isArbitraryLength
			] }],
			"text-decoration-color": [{ decoration: scaleColor() }],
			"underline-offset": [{ "underline-offset": [
				isNumber,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-transform": [
				"uppercase",
				"lowercase",
				"capitalize",
				"normal-case"
			],
			"text-overflow": [
				"truncate",
				"text-ellipsis",
				"text-clip"
			],
			"text-wrap": [{ text: [
				"wrap",
				"nowrap",
				"balance",
				"pretty"
			] }],
			indent: [{ indent: scaleUnambiguousSpacing() }],
			"vertical-align": [{ align: [
				"baseline",
				"top",
				"middle",
				"bottom",
				"text-top",
				"text-bottom",
				"sub",
				"super",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			whitespace: [{ whitespace: [
				"normal",
				"nowrap",
				"pre",
				"pre-line",
				"pre-wrap",
				"break-spaces"
			] }],
			break: [{ break: [
				"normal",
				"words",
				"all",
				"keep"
			] }],
			wrap: [{ wrap: [
				"break-word",
				"anywhere",
				"normal"
			] }],
			hyphens: [{ hyphens: [
				"none",
				"manual",
				"auto"
			] }],
			content: [{ content: [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"bg-attachment": [{ bg: [
				"fixed",
				"local",
				"scroll"
			] }],
			"bg-clip": [{ "bg-clip": [
				"border",
				"padding",
				"content",
				"text"
			] }],
			"bg-origin": [{ "bg-origin": [
				"border",
				"padding",
				"content"
			] }],
			"bg-position": [{ bg: scaleBgPosition() }],
			"bg-repeat": [{ bg: scaleBgRepeat() }],
			"bg-size": [{ bg: scaleBgSize() }],
			"bg-image": [{ bg: [
				"none",
				{
					linear: [
						{ to: [
							"t",
							"tr",
							"r",
							"br",
							"b",
							"bl",
							"l",
							"tl"
						] },
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					],
					radial: [
						"",
						isArbitraryVariable,
						isArbitraryValue
					],
					conic: [
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					]
				},
				isArbitraryVariableImage,
				isArbitraryImage
			] }],
			"bg-color": [{ bg: scaleColor() }],
			"gradient-from-pos": [{ from: scaleGradientStopPosition() }],
			"gradient-via-pos": [{ via: scaleGradientStopPosition() }],
			"gradient-to-pos": [{ to: scaleGradientStopPosition() }],
			"gradient-from": [{ from: scaleColor() }],
			"gradient-via": [{ via: scaleColor() }],
			"gradient-to": [{ to: scaleColor() }],
			rounded: [{ rounded: scaleRadius() }],
			"rounded-s": [{ "rounded-s": scaleRadius() }],
			"rounded-e": [{ "rounded-e": scaleRadius() }],
			"rounded-t": [{ "rounded-t": scaleRadius() }],
			"rounded-r": [{ "rounded-r": scaleRadius() }],
			"rounded-b": [{ "rounded-b": scaleRadius() }],
			"rounded-l": [{ "rounded-l": scaleRadius() }],
			"rounded-ss": [{ "rounded-ss": scaleRadius() }],
			"rounded-se": [{ "rounded-se": scaleRadius() }],
			"rounded-ee": [{ "rounded-ee": scaleRadius() }],
			"rounded-es": [{ "rounded-es": scaleRadius() }],
			"rounded-tl": [{ "rounded-tl": scaleRadius() }],
			"rounded-tr": [{ "rounded-tr": scaleRadius() }],
			"rounded-br": [{ "rounded-br": scaleRadius() }],
			"rounded-bl": [{ "rounded-bl": scaleRadius() }],
			"border-w": [{ border: scaleBorderWidth() }],
			"border-w-x": [{ "border-x": scaleBorderWidth() }],
			"border-w-y": [{ "border-y": scaleBorderWidth() }],
			"border-w-s": [{ "border-s": scaleBorderWidth() }],
			"border-w-e": [{ "border-e": scaleBorderWidth() }],
			"border-w-t": [{ "border-t": scaleBorderWidth() }],
			"border-w-r": [{ "border-r": scaleBorderWidth() }],
			"border-w-b": [{ "border-b": scaleBorderWidth() }],
			"border-w-l": [{ "border-l": scaleBorderWidth() }],
			"divide-x": [{ "divide-x": scaleBorderWidth() }],
			"divide-x-reverse": ["divide-x-reverse"],
			"divide-y": [{ "divide-y": scaleBorderWidth() }],
			"divide-y-reverse": ["divide-y-reverse"],
			"border-style": [{ border: [
				...scaleLineStyle(),
				"hidden",
				"none"
			] }],
			"divide-style": [{ divide: [
				...scaleLineStyle(),
				"hidden",
				"none"
			] }],
			"border-color": [{ border: scaleColor() }],
			"border-color-x": [{ "border-x": scaleColor() }],
			"border-color-y": [{ "border-y": scaleColor() }],
			"border-color-s": [{ "border-s": scaleColor() }],
			"border-color-e": [{ "border-e": scaleColor() }],
			"border-color-t": [{ "border-t": scaleColor() }],
			"border-color-r": [{ "border-r": scaleColor() }],
			"border-color-b": [{ "border-b": scaleColor() }],
			"border-color-l": [{ "border-l": scaleColor() }],
			"divide-color": [{ divide: scaleColor() }],
			"outline-style": [{ outline: [
				...scaleLineStyle(),
				"none",
				"hidden"
			] }],
			"outline-offset": [{ "outline-offset": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"outline-w": [{ outline: [
				"",
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"outline-color": [{ outline: scaleColor() }],
			shadow: [{ shadow: [
				"",
				"none",
				themeShadow,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"shadow-color": [{ shadow: scaleColor() }],
			"inset-shadow": [{ "inset-shadow": [
				"none",
				themeInsetShadow,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"inset-shadow-color": [{ "inset-shadow": scaleColor() }],
			"ring-w": [{ ring: scaleBorderWidth() }],
			"ring-w-inset": ["ring-inset"],
			"ring-color": [{ ring: scaleColor() }],
			"ring-offset-w": [{ "ring-offset": [isNumber, isArbitraryLength] }],
			"ring-offset-color": [{ "ring-offset": scaleColor() }],
			"inset-ring-w": [{ "inset-ring": scaleBorderWidth() }],
			"inset-ring-color": [{ "inset-ring": scaleColor() }],
			"text-shadow": [{ "text-shadow": [
				"none",
				themeTextShadow,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"text-shadow-color": [{ "text-shadow": scaleColor() }],
			opacity: [{ opacity: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"mix-blend": [{ "mix-blend": [
				...scaleBlendMode(),
				"plus-darker",
				"plus-lighter"
			] }],
			"bg-blend": [{ "bg-blend": scaleBlendMode() }],
			"mask-clip": [{ "mask-clip": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }, "mask-no-clip"],
			"mask-composite": [{ mask: [
				"add",
				"subtract",
				"intersect",
				"exclude"
			] }],
			"mask-image-linear-pos": [{ "mask-linear": [isNumber] }],
			"mask-image-linear-from-pos": [{ "mask-linear-from": scaleMaskImagePosition() }],
			"mask-image-linear-to-pos": [{ "mask-linear-to": scaleMaskImagePosition() }],
			"mask-image-linear-from-color": [{ "mask-linear-from": scaleColor() }],
			"mask-image-linear-to-color": [{ "mask-linear-to": scaleColor() }],
			"mask-image-t-from-pos": [{ "mask-t-from": scaleMaskImagePosition() }],
			"mask-image-t-to-pos": [{ "mask-t-to": scaleMaskImagePosition() }],
			"mask-image-t-from-color": [{ "mask-t-from": scaleColor() }],
			"mask-image-t-to-color": [{ "mask-t-to": scaleColor() }],
			"mask-image-r-from-pos": [{ "mask-r-from": scaleMaskImagePosition() }],
			"mask-image-r-to-pos": [{ "mask-r-to": scaleMaskImagePosition() }],
			"mask-image-r-from-color": [{ "mask-r-from": scaleColor() }],
			"mask-image-r-to-color": [{ "mask-r-to": scaleColor() }],
			"mask-image-b-from-pos": [{ "mask-b-from": scaleMaskImagePosition() }],
			"mask-image-b-to-pos": [{ "mask-b-to": scaleMaskImagePosition() }],
			"mask-image-b-from-color": [{ "mask-b-from": scaleColor() }],
			"mask-image-b-to-color": [{ "mask-b-to": scaleColor() }],
			"mask-image-l-from-pos": [{ "mask-l-from": scaleMaskImagePosition() }],
			"mask-image-l-to-pos": [{ "mask-l-to": scaleMaskImagePosition() }],
			"mask-image-l-from-color": [{ "mask-l-from": scaleColor() }],
			"mask-image-l-to-color": [{ "mask-l-to": scaleColor() }],
			"mask-image-x-from-pos": [{ "mask-x-from": scaleMaskImagePosition() }],
			"mask-image-x-to-pos": [{ "mask-x-to": scaleMaskImagePosition() }],
			"mask-image-x-from-color": [{ "mask-x-from": scaleColor() }],
			"mask-image-x-to-color": [{ "mask-x-to": scaleColor() }],
			"mask-image-y-from-pos": [{ "mask-y-from": scaleMaskImagePosition() }],
			"mask-image-y-to-pos": [{ "mask-y-to": scaleMaskImagePosition() }],
			"mask-image-y-from-color": [{ "mask-y-from": scaleColor() }],
			"mask-image-y-to-color": [{ "mask-y-to": scaleColor() }],
			"mask-image-radial": [{ "mask-radial": [isArbitraryVariable, isArbitraryValue] }],
			"mask-image-radial-from-pos": [{ "mask-radial-from": scaleMaskImagePosition() }],
			"mask-image-radial-to-pos": [{ "mask-radial-to": scaleMaskImagePosition() }],
			"mask-image-radial-from-color": [{ "mask-radial-from": scaleColor() }],
			"mask-image-radial-to-color": [{ "mask-radial-to": scaleColor() }],
			"mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }],
			"mask-image-radial-size": [{ "mask-radial": [{
				closest: ["side", "corner"],
				farthest: ["side", "corner"]
			}] }],
			"mask-image-radial-pos": [{ "mask-radial-at": scalePosition() }],
			"mask-image-conic-pos": [{ "mask-conic": [isNumber] }],
			"mask-image-conic-from-pos": [{ "mask-conic-from": scaleMaskImagePosition() }],
			"mask-image-conic-to-pos": [{ "mask-conic-to": scaleMaskImagePosition() }],
			"mask-image-conic-from-color": [{ "mask-conic-from": scaleColor() }],
			"mask-image-conic-to-color": [{ "mask-conic-to": scaleColor() }],
			"mask-mode": [{ mask: [
				"alpha",
				"luminance",
				"match"
			] }],
			"mask-origin": [{ "mask-origin": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }],
			"mask-position": [{ mask: scaleBgPosition() }],
			"mask-repeat": [{ mask: scaleBgRepeat() }],
			"mask-size": [{ mask: scaleBgSize() }],
			"mask-type": [{ "mask-type": ["alpha", "luminance"] }],
			"mask-image": [{ mask: [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			filter: [{ filter: [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			blur: [{ blur: scaleBlur() }],
			brightness: [{ brightness: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			contrast: [{ contrast: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"drop-shadow": [{ "drop-shadow": [
				"",
				"none",
				themeDropShadow,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"drop-shadow-color": [{ "drop-shadow": scaleColor() }],
			grayscale: [{ grayscale: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"hue-rotate": [{ "hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			invert: [{ invert: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			saturate: [{ saturate: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			sepia: [{ sepia: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-filter": [{ "backdrop-filter": [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-blur": [{ "backdrop-blur": scaleBlur() }],
			"backdrop-brightness": [{ "backdrop-brightness": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-contrast": [{ "backdrop-contrast": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-grayscale": [{ "backdrop-grayscale": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-hue-rotate": [{ "backdrop-hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-invert": [{ "backdrop-invert": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-opacity": [{ "backdrop-opacity": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-saturate": [{ "backdrop-saturate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-sepia": [{ "backdrop-sepia": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"border-collapse": [{ border: ["collapse", "separate"] }],
			"border-spacing": [{ "border-spacing": scaleUnambiguousSpacing() }],
			"border-spacing-x": [{ "border-spacing-x": scaleUnambiguousSpacing() }],
			"border-spacing-y": [{ "border-spacing-y": scaleUnambiguousSpacing() }],
			"table-layout": [{ table: ["auto", "fixed"] }],
			caption: [{ caption: ["top", "bottom"] }],
			transition: [{ transition: [
				"",
				"all",
				"colors",
				"opacity",
				"shadow",
				"transform",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"transition-behavior": [{ transition: ["normal", "discrete"] }],
			duration: [{ duration: [
				isNumber,
				"initial",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			ease: [{ ease: [
				"linear",
				"initial",
				themeEase,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			delay: [{ delay: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			animate: [{ animate: [
				"none",
				themeAnimate,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			backface: [{ backface: ["hidden", "visible"] }],
			perspective: [{ perspective: [
				themePerspective,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"perspective-origin": [{ "perspective-origin": scalePositionWithArbitrary() }],
			rotate: [{ rotate: scaleRotate() }],
			"rotate-x": [{ "rotate-x": scaleRotate() }],
			"rotate-y": [{ "rotate-y": scaleRotate() }],
			"rotate-z": [{ "rotate-z": scaleRotate() }],
			scale: [{ scale: scaleScale() }],
			"scale-x": [{ "scale-x": scaleScale() }],
			"scale-y": [{ "scale-y": scaleScale() }],
			"scale-z": [{ "scale-z": scaleScale() }],
			"scale-3d": ["scale-3d"],
			skew: [{ skew: scaleSkew() }],
			"skew-x": [{ "skew-x": scaleSkew() }],
			"skew-y": [{ "skew-y": scaleSkew() }],
			transform: [{ transform: [
				isArbitraryVariable,
				isArbitraryValue,
				"",
				"none",
				"gpu",
				"cpu"
			] }],
			"transform-origin": [{ origin: scalePositionWithArbitrary() }],
			"transform-style": [{ transform: ["3d", "flat"] }],
			translate: [{ translate: scaleTranslate() }],
			"translate-x": [{ "translate-x": scaleTranslate() }],
			"translate-y": [{ "translate-y": scaleTranslate() }],
			"translate-z": [{ "translate-z": scaleTranslate() }],
			"translate-none": ["translate-none"],
			accent: [{ accent: scaleColor() }],
			appearance: [{ appearance: ["none", "auto"] }],
			"caret-color": [{ caret: scaleColor() }],
			"color-scheme": [{ scheme: [
				"normal",
				"dark",
				"light",
				"light-dark",
				"only-dark",
				"only-light"
			] }],
			cursor: [{ cursor: [
				"auto",
				"default",
				"pointer",
				"wait",
				"text",
				"move",
				"help",
				"not-allowed",
				"none",
				"context-menu",
				"progress",
				"cell",
				"crosshair",
				"vertical-text",
				"alias",
				"copy",
				"no-drop",
				"grab",
				"grabbing",
				"all-scroll",
				"col-resize",
				"row-resize",
				"n-resize",
				"e-resize",
				"s-resize",
				"w-resize",
				"ne-resize",
				"nw-resize",
				"se-resize",
				"sw-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"zoom-in",
				"zoom-out",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"field-sizing": [{ "field-sizing": ["fixed", "content"] }],
			"pointer-events": [{ "pointer-events": ["auto", "none"] }],
			resize: [{ resize: [
				"none",
				"",
				"y",
				"x"
			] }],
			"scroll-behavior": [{ scroll: ["auto", "smooth"] }],
			"scroll-m": [{ "scroll-m": scaleUnambiguousSpacing() }],
			"scroll-mx": [{ "scroll-mx": scaleUnambiguousSpacing() }],
			"scroll-my": [{ "scroll-my": scaleUnambiguousSpacing() }],
			"scroll-ms": [{ "scroll-ms": scaleUnambiguousSpacing() }],
			"scroll-me": [{ "scroll-me": scaleUnambiguousSpacing() }],
			"scroll-mt": [{ "scroll-mt": scaleUnambiguousSpacing() }],
			"scroll-mr": [{ "scroll-mr": scaleUnambiguousSpacing() }],
			"scroll-mb": [{ "scroll-mb": scaleUnambiguousSpacing() }],
			"scroll-ml": [{ "scroll-ml": scaleUnambiguousSpacing() }],
			"scroll-p": [{ "scroll-p": scaleUnambiguousSpacing() }],
			"scroll-px": [{ "scroll-px": scaleUnambiguousSpacing() }],
			"scroll-py": [{ "scroll-py": scaleUnambiguousSpacing() }],
			"scroll-ps": [{ "scroll-ps": scaleUnambiguousSpacing() }],
			"scroll-pe": [{ "scroll-pe": scaleUnambiguousSpacing() }],
			"scroll-pt": [{ "scroll-pt": scaleUnambiguousSpacing() }],
			"scroll-pr": [{ "scroll-pr": scaleUnambiguousSpacing() }],
			"scroll-pb": [{ "scroll-pb": scaleUnambiguousSpacing() }],
			"scroll-pl": [{ "scroll-pl": scaleUnambiguousSpacing() }],
			"snap-align": [{ snap: [
				"start",
				"end",
				"center",
				"align-none"
			] }],
			"snap-stop": [{ snap: ["normal", "always"] }],
			"snap-type": [{ snap: [
				"none",
				"x",
				"y",
				"both"
			] }],
			"snap-strictness": [{ snap: ["mandatory", "proximity"] }],
			touch: [{ touch: [
				"auto",
				"none",
				"manipulation"
			] }],
			"touch-x": [{ "touch-pan": [
				"x",
				"left",
				"right"
			] }],
			"touch-y": [{ "touch-pan": [
				"y",
				"up",
				"down"
			] }],
			"touch-pz": ["touch-pinch-zoom"],
			select: [{ select: [
				"none",
				"text",
				"all",
				"auto"
			] }],
			"will-change": [{ "will-change": [
				"auto",
				"scroll",
				"contents",
				"transform",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			fill: [{ fill: ["none", ...scaleColor()] }],
			"stroke-w": [{ stroke: [
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength,
				isArbitraryNumber
			] }],
			stroke: [{ stroke: ["none", ...scaleColor()] }],
			"forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }]
		},
		conflictingClassGroups: {
			overflow: ["overflow-x", "overflow-y"],
			overscroll: ["overscroll-x", "overscroll-y"],
			inset: [
				"inset-x",
				"inset-y",
				"start",
				"end",
				"top",
				"right",
				"bottom",
				"left"
			],
			"inset-x": ["right", "left"],
			"inset-y": ["top", "bottom"],
			flex: [
				"basis",
				"grow",
				"shrink"
			],
			gap: ["gap-x", "gap-y"],
			p: [
				"px",
				"py",
				"ps",
				"pe",
				"pt",
				"pr",
				"pb",
				"pl"
			],
			px: ["pr", "pl"],
			py: ["pt", "pb"],
			m: [
				"mx",
				"my",
				"ms",
				"me",
				"mt",
				"mr",
				"mb",
				"ml"
			],
			mx: ["mr", "ml"],
			my: ["mt", "mb"],
			size: ["w", "h"],
			"font-size": ["leading"],
			"fvn-normal": [
				"fvn-ordinal",
				"fvn-slashed-zero",
				"fvn-figure",
				"fvn-spacing",
				"fvn-fraction"
			],
			"fvn-ordinal": ["fvn-normal"],
			"fvn-slashed-zero": ["fvn-normal"],
			"fvn-figure": ["fvn-normal"],
			"fvn-spacing": ["fvn-normal"],
			"fvn-fraction": ["fvn-normal"],
			"line-clamp": ["display", "overflow"],
			rounded: [
				"rounded-s",
				"rounded-e",
				"rounded-t",
				"rounded-r",
				"rounded-b",
				"rounded-l",
				"rounded-ss",
				"rounded-se",
				"rounded-ee",
				"rounded-es",
				"rounded-tl",
				"rounded-tr",
				"rounded-br",
				"rounded-bl"
			],
			"rounded-s": ["rounded-ss", "rounded-es"],
			"rounded-e": ["rounded-se", "rounded-ee"],
			"rounded-t": ["rounded-tl", "rounded-tr"],
			"rounded-r": ["rounded-tr", "rounded-br"],
			"rounded-b": ["rounded-br", "rounded-bl"],
			"rounded-l": ["rounded-tl", "rounded-bl"],
			"border-spacing": ["border-spacing-x", "border-spacing-y"],
			"border-w": [
				"border-w-x",
				"border-w-y",
				"border-w-s",
				"border-w-e",
				"border-w-t",
				"border-w-r",
				"border-w-b",
				"border-w-l"
			],
			"border-w-x": ["border-w-r", "border-w-l"],
			"border-w-y": ["border-w-t", "border-w-b"],
			"border-color": [
				"border-color-x",
				"border-color-y",
				"border-color-s",
				"border-color-e",
				"border-color-t",
				"border-color-r",
				"border-color-b",
				"border-color-l"
			],
			"border-color-x": ["border-color-r", "border-color-l"],
			"border-color-y": ["border-color-t", "border-color-b"],
			translate: [
				"translate-x",
				"translate-y",
				"translate-none"
			],
			"translate-none": [
				"translate",
				"translate-x",
				"translate-y",
				"translate-z"
			],
			"scroll-m": [
				"scroll-mx",
				"scroll-my",
				"scroll-ms",
				"scroll-me",
				"scroll-mt",
				"scroll-mr",
				"scroll-mb",
				"scroll-ml"
			],
			"scroll-mx": ["scroll-mr", "scroll-ml"],
			"scroll-my": ["scroll-mt", "scroll-mb"],
			"scroll-p": [
				"scroll-px",
				"scroll-py",
				"scroll-ps",
				"scroll-pe",
				"scroll-pt",
				"scroll-pr",
				"scroll-pb",
				"scroll-pl"
			],
			"scroll-px": ["scroll-pr", "scroll-pl"],
			"scroll-py": ["scroll-pt", "scroll-pb"],
			touch: [
				"touch-x",
				"touch-y",
				"touch-pz"
			],
			"touch-x": ["touch"],
			"touch-y": ["touch"],
			"touch-pz": ["touch"]
		},
		conflictingClassGroupModifiers: { "font-size": ["leading"] },
		orderSensitiveModifiers: [
			"*",
			"**",
			"after",
			"backdrop",
			"before",
			"details-content",
			"file",
			"first-letter",
			"first-line",
			"marker",
			"placeholder",
			"selection"
		]
	};
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
const cn = (...inputs) => {
	return twMerge(clsx(inputs));
};
const throttle = (callback, delay) => {
	let lastCall = 0;
	return (e$1) => {
		const now = Date.now();
		if (now - lastCall >= delay) {
			lastCall = now;
			return callback(e$1);
		}
		return void 0;
	};
};
const readLocalStorage = (storageKey) => {
	if (!IS_CLIENT) return null;
	try {
		const stored = localStorage.getItem(storageKey);
		return stored ? JSON.parse(stored) : null;
	} catch {
		return null;
	}
};
const saveLocalStorage = (storageKey, state) => {
	if (!IS_CLIENT) return;
	try {
		window.localStorage.setItem(storageKey, JSON.stringify(state));
	} catch {}
};
const removeLocalStorage = (storageKey) => {
	if (!IS_CLIENT) return;
	try {
		window.localStorage.removeItem(storageKey);
	} catch {}
};
const LazyComponentTag = 24;
const ProfilerTag = 12;
const getExtendedDisplayName = (fiber) => {
	if (!fiber) return {
		name: "Unknown",
		wrappers: [],
		wrapperTypes: []
	};
	const { tag, type, elementType } = fiber;
	let name = getDisplayName(type);
	const wrappers = [];
	const wrapperTypes = [];
	if (hasMemoCache(fiber) || tag === SimpleMemoComponentTag || tag === MemoComponentTag || type?.$$typeof === Symbol.for("react.memo") || elementType?.$$typeof === Symbol.for("react.memo")) {
		const compiler = hasMemoCache(fiber);
		wrapperTypes.push({
			type: "memo",
			title: compiler ? "This component has been auto-memoized by the React Compiler." : "Memoized component that skips re-renders if props are the same",
			compiler
		});
	}
	if (tag === LazyComponentTag) wrapperTypes.push({
		type: "lazy",
		title: "Lazily loaded component that supports code splitting"
	});
	if (tag === SuspenseComponentTag) wrapperTypes.push({
		type: "suspense",
		title: "Component that can suspend while content is loading"
	});
	if (tag === ProfilerTag) wrapperTypes.push({
		type: "profiler",
		title: "Component that measures rendering performance"
	});
	if (typeof name === "string") {
		const wrapperRegex = /^(\w+)\((.*)\)$/;
		let currentName = name;
		while (wrapperRegex.test(currentName)) {
			const match = currentName.match(wrapperRegex);
			if (match?.[1] && match?.[2]) {
				wrappers.unshift(match[1]);
				currentName = match[2];
			} else break;
		}
		name = currentName;
	}
	return {
		name: name || "Unknown",
		wrappers,
		wrapperTypes
	};
};
const SAFE_AREA = 24;
const MIN_SIZE = {
	width: 550,
	height: 350,
	initialHeight: 400
};
const MIN_CONTAINER_WIDTH = 240;
const LOCALSTORAGE_KEY = "react-devtool-widget-settings-v2";
const LOCALSTORAGE_COLLAPSED_KEY = "react-devtool-widget-collapsed-v1";
const LOCALSTORAGE_LAST_VIEW_KEY = "react-devtool-widget-last-view-v1";
const signalIsSettingsOpen = /* @__PURE__ */ signal(false);
const signalRefWidget = /* @__PURE__ */ signal(null);
const defaultWidgetConfig = {
	corner: "bottom-right",
	dimensions: {
		isFullWidth: false,
		isFullHeight: false,
		width: /* @__PURE__ */ (() => MIN_SIZE.width)(),
		height: /* @__PURE__ */ (() => MIN_SIZE.height)(),
		position: {
			x: SAFE_AREA,
			y: SAFE_AREA
		}
	},
	lastDimensions: {
		isFullWidth: false,
		isFullHeight: false,
		width: /* @__PURE__ */ (() => MIN_SIZE.width)(),
		height: /* @__PURE__ */ (() => MIN_SIZE.height)(),
		position: {
			x: SAFE_AREA,
			y: SAFE_AREA
		}
	},
	componentsTree: { width: MIN_CONTAINER_WIDTH }
};
const getInitialWidgetConfig = () => {
	const stored = readLocalStorage(LOCALSTORAGE_KEY);
	if (!stored) {
		saveLocalStorage(LOCALSTORAGE_KEY, {
			corner: defaultWidgetConfig.corner,
			dimensions: defaultWidgetConfig.dimensions,
			lastDimensions: defaultWidgetConfig.lastDimensions,
			componentsTree: defaultWidgetConfig.componentsTree
		});
		return defaultWidgetConfig;
	}
	return {
		corner: stored.corner ?? defaultWidgetConfig.corner,
		dimensions: stored.dimensions ?? defaultWidgetConfig.dimensions,
		lastDimensions: stored.lastDimensions ?? stored.dimensions ?? defaultWidgetConfig.lastDimensions,
		componentsTree: stored.componentsTree ?? defaultWidgetConfig.componentsTree
	};
};
const signalWidget = /* @__PURE__ */ signal(/* @__PURE__ */ getInitialWidgetConfig());
const updateDimensions = () => {
	if (!IS_CLIENT) return;
	const { dimensions } = signalWidget.value;
	const { width, height, position } = dimensions;
	signalWidget.value = {
		...signalWidget.value,
		dimensions: {
			isFullWidth: width >= window.innerWidth - SAFE_AREA * 2,
			isFullHeight: height >= window.innerHeight - SAFE_AREA * 2,
			width,
			height,
			position
		}
	};
};
const signalWidgetViews = /* @__PURE__ */ signal({ view: "none" });
const storedCollapsed = /* @__PURE__ */ readLocalStorage(LOCALSTORAGE_COLLAPSED_KEY);
const signalWidgetCollapsed = /* @__PURE__ */ signal(storedCollapsed ?? null);
const userChildren = /* @__PURE__ */ signal(null);
/**
* Delays a boolean value change by a specified duration.
* Perfect for coordinating animations with state changes.
*
* @param {boolean} value - The boolean value to delay
* @param {number} onDelay - Milliseconds to wait before changing to true
* @param {number} [offDelay] - Milliseconds to wait before changing to false (defaults to onDelay)
* @returns {boolean} The delayed value
*
* @example
* // Delay both transitions by 300ms
* const isVisible = useDelayedValue(show, 300);
*
* @example
* // Quick show (100ms), slow hide (500ms)
* const isVisible = useDelayedValue(show, 100, 500);
*
* @example
* // Use with CSS transitions
* const isVisible = useDelayedValue(show, 300);
* return (
*   <div
*     className="transition-all duration-300"
*     style={{
*       opacity: isVisible ? 1 : 0,
*       transform: isVisible ? 'none' : 'translateY(4px)'
*     }}
*   >
*     {content}
*   </div>
* );
*/
const useDelayedValue = (value, onDelay, offDelay = onDelay) => {
	const [delayedValue, setDelayedValue] = useState$1(value);
	useEffect$1(() => {
		if (value === delayedValue) return;
		const delay = value ? onDelay : offDelay;
		const timeout = setTimeout(() => setDelayedValue(value), delay);
		return () => clearTimeout(timeout);
	}, [
		value,
		onDelay,
		offDelay
	]);
	return delayedValue;
};
const fadeOutTimers = /* @__PURE__ */ new WeakMap();
const trackElementPosition = (element, callback) => {
	const handleScroll = callback.bind(null, element);
	document.addEventListener("scroll", handleScroll, {
		passive: true,
		capture: true
	});
	return () => {
		document.removeEventListener("scroll", handleScroll, { capture: true });
	};
};
const flashManager = {
	activeFlashes: /* @__PURE__ */ new Map(),
	create(container) {
		const existingOverlay = container.querySelector(".react-devtool-flash-overlay");
		const overlay = existingOverlay instanceof HTMLElement ? existingOverlay : (() => {
			const newOverlay = document.createElement("div");
			newOverlay.className = "react-devtool-flash-overlay";
			container.appendChild(newOverlay);
			const scrollCleanup = trackElementPosition(container, () => {
				if (container.querySelector(".react-devtool-flash-overlay")) this.create(container);
			});
			this.activeFlashes.set(container, {
				element: container,
				overlay: newOverlay,
				scrollCleanup
			});
			return newOverlay;
		})();
		const existingTimer = fadeOutTimers.get(overlay);
		if (existingTimer) {
			clearTimeout(existingTimer);
			fadeOutTimers.delete(overlay);
		}
		requestAnimationFrame(() => {
			overlay.style.transition = "none";
			overlay.style.opacity = "0.9";
			const timerId = setTimeout(() => {
				overlay.style.transition = "opacity 150ms ease-out";
				overlay.style.opacity = "0";
				const cleanupTimer = setTimeout(() => {
					if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
					const entry = this.activeFlashes.get(container);
					if (entry?.scrollCleanup) entry.scrollCleanup();
					this.activeFlashes.delete(container);
					fadeOutTimers.delete(overlay);
				}, 150);
				fadeOutTimers.set(overlay, cleanupTimer);
			}, 300);
			fadeOutTimers.set(overlay, timerId);
		});
	},
	cleanup(container) {
		const entry = this.activeFlashes.get(container);
		if (entry) {
			const existingTimer = fadeOutTimers.get(entry.overlay);
			if (existingTimer) {
				clearTimeout(existingTimer);
				fadeOutTimers.delete(entry.overlay);
			}
			if (entry.overlay.parentNode) entry.overlay.parentNode.removeChild(entry.overlay);
			if (entry.scrollCleanup) entry.scrollCleanup();
			this.activeFlashes.delete(container);
		}
	},
	cleanupAll() {
		for (const [, entry] of this.activeFlashes) this.cleanup(entry.element);
	}
};
function isEqual(a$1, b$1) {
	return a$1 === b$1 || a$1 !== a$1 && b$1 !== b$1;
}
/**
*
* @deprecated use getBatchedRectMap
*/
const batchGetBoundingRects = (elements) => {
	return new Promise((resolve) => {
		const results = /* @__PURE__ */ new Map();
		const observer = new IntersectionObserver((entries) => {
			for (const entry of entries) {
				const element = entry.target;
				const bounds = entry.boundingClientRect;
				results.set(element, bounds);
			}
			observer.disconnect();
			resolve(results);
		});
		for (const element of elements) observer.observe(element);
	});
};
let RenderPhase = /* @__PURE__ */ function(RenderPhase$1) {
	RenderPhase$1[RenderPhase$1["Mount"] = 1] = "Mount";
	RenderPhase$1[RenderPhase$1["Update"] = 2] = "Update";
	RenderPhase$1[RenderPhase$1["Unmount"] = 4] = "Unmount";
	return RenderPhase$1;
}({});
const RENDER_PHASE_STRING_TO_ENUM = {
	mount: /* @__PURE__ */ (() => RenderPhase.Mount)(),
	update: /* @__PURE__ */ (() => RenderPhase.Update)(),
	unmount: /* @__PURE__ */ (() => RenderPhase.Unmount)()
};
let fps = 0;
let lastTime = /* @__PURE__ */ performance.now();
let frameCount = 0;
let initedFps = false;
const updateFPS = () => {
	frameCount++;
	const now = performance.now();
	if (now - lastTime >= 1e3) {
		fps = frameCount;
		frameCount = 0;
		lastTime = now;
	}
	requestAnimationFrame(updateFPS);
};
const getFPS = () => {
	if (!initedFps) {
		initedFps = true;
		updateFPS();
		fps = 60;
	}
	return fps;
};
let ChangeReason = /* @__PURE__ */ function(ChangeReason$1) {
	ChangeReason$1[ChangeReason$1["Props"] = 1] = "Props";
	ChangeReason$1[ChangeReason$1["FunctionalState"] = 2] = "FunctionalState";
	ChangeReason$1[ChangeReason$1["ClassState"] = 3] = "ClassState";
	ChangeReason$1[ChangeReason$1["Context"] = 4] = "Context";
	return ChangeReason$1;
}({});
const globalInspectorState = {
	lastRendered: /* @__PURE__ */ new Map(),
	expandedPaths: /* @__PURE__ */ new Set(),
	cleanup: () => {
		globalInspectorState.lastRendered.clear();
		globalInspectorState.expandedPaths.clear();
		flashManager.cleanupAll();
		resetTracking();
		timelineActions.reset();
	}
};
const getFiberFromElement = (element) => {
	if ("__REACT_DEVTOOLS_GLOBAL_HOOK__" in window) {
		const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
		if (!hook?.renderers) return null;
		for (const [, renderer] of Array.from(hook.renderers)) try {
			const fiber = renderer.findFiberByHostInstance?.(element);
			if (fiber) return fiber;
		} catch {}
	}
	if ("_reactRootContainer" in element) {
		const elementWithRoot = element;
		const rootContainer$1 = elementWithRoot._reactRootContainer;
		return rootContainer$1?._internalRoot?.current?.child ?? null;
	}
	for (const key in element) if (key.startsWith("__reactInternalInstance$") || key.startsWith("__reactFiber")) {
		const elementWithFiber = element;
		return elementWithFiber[key];
	}
	return null;
};
const getFirstStateNode = (fiber) => {
	let current = fiber;
	while (current) {
		if (current.stateNode instanceof Element) return current.stateNode;
		if (!current.child) break;
		current = current.child;
	}
	while (current) {
		if (current.stateNode instanceof Element) return current.stateNode;
		if (!current.return) break;
		current = current.return;
	}
	return null;
};
const getNearestFiberFromElement = (element) => {
	if (!element) return null;
	try {
		const fiber = getFiberFromElement(element);
		if (!fiber) return null;
		const res = getParentCompositeFiber(fiber);
		return res ? res[0] : null;
	} catch {
		return null;
	}
};
const getParentCompositeFiber = (fiber) => {
	let current = fiber;
	let prevHost = null;
	while (current) {
		if (isCompositeFiber(current)) return [current, prevHost];
		if (isHostFiber(current) && !prevHost) prevHost = current;
		current = current.return;
	}
	return null;
};
const getAssociatedFiberRect = async (element) => {
	const associatedFiber = getNearestFiberFromElement(element);
	if (!associatedFiber) return null;
	const stateNode = getFirstStateNode(associatedFiber);
	if (!stateNode) return null;
	const rect = (await batchGetBoundingRects([stateNode])).get(stateNode);
	if (!rect) return null;
	return rect;
};
const getCompositeComponentFromElement = (element) => {
	const associatedFiber = getNearestFiberFromElement(element);
	if (!associatedFiber) return {};
	const stateNode = getFirstStateNode(associatedFiber);
	if (!stateNode) return {};
	const parentCompositeFiberInfo = getParentCompositeFiber(associatedFiber);
	if (!parentCompositeFiberInfo) return {};
	const [parentCompositeFiber] = parentCompositeFiberInfo;
	return { parentCompositeFiber };
};
const getChangedPropsDetailed = (fiber) => {
	const currentProps = fiber.memoizedProps ?? {};
	const previousProps = fiber.alternate?.memoizedProps ?? {};
	const changes = [];
	for (const key in currentProps) {
		if (key === "children") continue;
		const currentValue = currentProps[key];
		const prevValue = previousProps[key];
		if (!isEqual(currentValue, prevValue)) changes.push({
			name: key,
			value: currentValue,
			prevValue,
			type: ChangeReason.Props
		});
	}
	return changes;
};
const nonVisualTags = /* @__PURE__ */ new Set([
	"HTML",
	"HEAD",
	"META",
	"TITLE",
	"BASE",
	"SCRIPT",
	"SCRIPT",
	"STYLE",
	"LINK",
	"NOSCRIPT",
	"SOURCE",
	"TRACK",
	"EMBED",
	"OBJECT",
	"PARAM",
	"TEMPLATE",
	"PORTAL",
	"SLOT",
	"AREA",
	"XML",
	"DOCTYPE",
	"COMMENT"
]);
const findComponentDOMNode = (fiber, excludeNonVisualTags = true) => {
	if (fiber.stateNode && "nodeType" in fiber.stateNode) {
		const element = fiber.stateNode;
		if (excludeNonVisualTags && element.tagName && nonVisualTags.has(element.tagName.toLowerCase())) return null;
		return element;
	}
	let child = fiber.child;
	while (child) {
		const result = findComponentDOMNode(child, excludeNonVisualTags);
		if (result) return result;
		child = child.sibling;
	}
	return null;
};
const isExpandable = (value) => {
	if (value === null || typeof value !== "object" || isPromise(value)) return false;
	if (value instanceof ArrayBuffer) return true;
	if (value instanceof DataView) return true;
	if (ArrayBuffer.isView(value)) return true;
	if (value instanceof Map || value instanceof Set) return value.size > 0;
	if (Array.isArray(value)) return value.length > 0;
	return Object.keys(value).length > 0;
};
const isEditableValue = (value, parentPath) => {
	if (value == null) return true;
	if (isPromise(value)) return false;
	if (typeof value === "function") return false;
	if (parentPath) {
		const parts = parentPath.split(".");
		let currentPath = "";
		for (const part of parts) {
			currentPath = currentPath ? `${currentPath}.${part}` : part;
			const obj = globalInspectorState.lastRendered.get(currentPath);
			if (obj instanceof DataView || obj instanceof ArrayBuffer || ArrayBuffer.isView(obj)) return false;
		}
	}
	switch (value.constructor) {
		case Date:
		case RegExp:
		case Error: return true;
		default: switch (typeof value) {
			case "string":
			case "number":
			case "boolean":
			case "bigint": return true;
			default: return false;
		}
	}
};
const sanitizeString = (value) => {
	return value.replace(/[<>]/g, "").replace(/javascript:/gi, "").replace(/data:/gi, "").replace(/on\w+=/gi, "").slice(0, 5e4);
};
const formatValue = (value) => {
	const metadata = ensureRecord(value);
	return metadata.displayValue;
};
const formatForClipboard = (value) => {
	try {
		if (value === null) return "null";
		if (value === void 0) return "undefined";
		if (isPromise(value)) return "Promise";
		if (typeof value === "function") {
			const fnStr = value.toString();
			try {
				const formatted = fnStr.replace(/\s+/g, " ").replace(/{\s+/g, "{\n  ").replace(/;\s+/g, ";\n  ").replace(/}\s*$/g, "\n}").replace(/\(\s+/g, "(").replace(/\s+\)/g, ")").replace(/,\s+/g, ", ");
				return formatted;
			} catch {
				return fnStr;
			}
		}
		switch (true) {
			case value instanceof Date: return value.toISOString();
			case value instanceof RegExp: return value.toString();
			case value instanceof Error: return `${value.name}: ${value.message}`;
			case value instanceof Map: return JSON.stringify(Array.from(value.entries()), null, 2);
			case value instanceof Set: return JSON.stringify(Array.from(value), null, 2);
			case value instanceof DataView: return JSON.stringify(Array.from(new Uint8Array(value.buffer)), null, 2);
			case value instanceof ArrayBuffer: return JSON.stringify(Array.from(new Uint8Array(value)), null, 2);
			case ArrayBuffer.isView(value) && "length" in value: return JSON.stringify(Array.from(value), null, 2);
			case Array.isArray(value): return JSON.stringify(value, null, 2);
			case typeof value === "object": return JSON.stringify(value, null, 2);
			default: return String(value);
		}
	} catch {
		return String(value);
	}
};
const detectValueType = (value) => {
	const trimmed = value.trim();
	switch (trimmed) {
		case "undefined": return {
			type: "undefined",
			value: void 0
		};
		case "null": return {
			type: "null",
			value: null
		};
		case "true": return {
			type: "boolean",
			value: true
		};
		case "false": return {
			type: "boolean",
			value: false
		};
	}
	if (/^".*"$/.test(trimmed)) return {
		type: "string",
		value: trimmed.slice(1, -1)
	};
	if (/^-?\d+(?:\.\d+)?$/.test(trimmed)) return {
		type: "number",
		value: Number(trimmed)
	};
	return {
		type: "string",
		value: `"${trimmed}"`
	};
};
const formatInitialValue = (value) => {
	if (value === void 0) return "undefined";
	if (value === null) return "null";
	if (typeof value === "string") return `"${value}"`;
	return String(value);
};
const updateNestedValue = (obj, path, value) => {
	try {
		if (path.length === 0) return value;
		const [key, ...rest] = path;
		if (Array.isArray(obj) && obj.every((item) => "name" in item && "value" in item)) {
			const index = obj.findIndex((item) => item.name === key);
			if (index === -1) return obj;
			const newArray = [...obj];
			if (rest.length === 0) newArray[index] = {
				...newArray[index],
				value
			};
			else newArray[index] = {
				...newArray[index],
				value: updateNestedValue(newArray[index].value, rest, value)
			};
			return newArray;
		}
		if (obj instanceof Map) {
			const newMap = new Map(obj);
			if (rest.length === 0) newMap.set(key, value);
			else {
				const currentValue = newMap.get(key);
				newMap.set(key, updateNestedValue(currentValue, rest, value));
			}
			return newMap;
		}
		if (Array.isArray(obj)) {
			const index = Number.parseInt(key, 10);
			const newArray = [...obj];
			if (rest.length === 0) newArray[index] = value;
			else newArray[index] = updateNestedValue(obj[index], rest, value);
			return newArray;
		}
		if (obj && typeof obj === "object") {
			if (rest.length === 0) return {
				...obj,
				[key]: value
			};
			return {
				...obj,
				[key]: updateNestedValue(obj[key], rest, value)
			};
		}
		return value;
	} catch {
		return obj;
	}
};
const isPromise = (value) => {
	return !!value && (value instanceof Promise || typeof value === "object" && "then" in value);
};
const ensureRecord = (value, maxDepth = 2, seen = /* @__PURE__ */ new WeakSet()) => {
	if (isPromise(value)) return {
		type: "promise",
		displayValue: "Promise"
	};
	if (value === null) return {
		type: "null",
		displayValue: "null"
	};
	if (value === void 0) return {
		type: "undefined",
		displayValue: "undefined"
	};
	switch (typeof value) {
		case "object": {
			if (seen.has(value)) return {
				type: "circular",
				displayValue: "[Circular Reference]"
			};
			if (!value) return {
				type: "null",
				displayValue: "null"
			};
			seen.add(value);
			try {
				const result = {};
				if (value instanceof Element) {
					result.type = "Element";
					result.tagName = value.tagName.toLowerCase();
					result.displayValue = value.tagName.toLowerCase();
					return result;
				}
				if (value instanceof Map) {
					result.type = "Map";
					result.size = value.size;
					result.displayValue = `Map(${value.size})`;
					if (maxDepth > 0) {
						const entries = {};
						let index = 0;
						for (const [key, val] of value.entries()) {
							if (index >= 50) break;
							try {
								entries[String(key)] = ensureRecord(val, maxDepth - 1, seen);
							} catch {
								entries[String(index)] = {
									type: "error",
									displayValue: "Error accessing Map entry"
								};
							}
							index++;
						}
						result.entries = entries;
					}
					return result;
				}
				if (value instanceof Set) {
					result.type = "Set";
					result.size = value.size;
					result.displayValue = `Set(${value.size})`;
					if (maxDepth > 0) {
						const items = [];
						let count = 0;
						for (const item of value) {
							if (count >= 50) break;
							items.push(ensureRecord(item, maxDepth - 1, seen));
							count++;
						}
						result.items = items;
					}
					return result;
				}
				if (value instanceof Date) {
					result.type = "Date";
					result.value = value.toISOString();
					result.displayValue = value.toLocaleString();
					return result;
				}
				if (value instanceof RegExp) {
					result.type = "RegExp";
					result.value = value.toString();
					result.displayValue = value.toString();
					return result;
				}
				if (value instanceof Error) {
					result.type = "Error";
					result.name = value.name;
					result.message = value.message;
					result.displayValue = `${value.name}: ${value.message}`;
					return result;
				}
				if (value instanceof ArrayBuffer) {
					result.type = "ArrayBuffer";
					result.byteLength = value.byteLength;
					result.displayValue = `ArrayBuffer(${value.byteLength})`;
					return result;
				}
				if (value instanceof DataView) {
					result.type = "DataView";
					result.byteLength = value.byteLength;
					result.displayValue = `DataView(${value.byteLength})`;
					return result;
				}
				if (ArrayBuffer.isView(value)) {
					const typedArray = value;
					result.type = typedArray.constructor.name;
					result.length = typedArray.length;
					result.byteLength = typedArray.buffer.byteLength;
					result.displayValue = `${typedArray.constructor.name}(${typedArray.length})`;
					return result;
				}
				if (Array.isArray(value)) {
					result.type = "array";
					result.length = value.length;
					result.displayValue = `Array(${value.length})`;
					if (maxDepth > 0) result.items = value.slice(0, 50).map((item) => ensureRecord(item, maxDepth - 1, seen));
					return result;
				}
				const keys = Object.keys(value);
				result.type = "object";
				result.size = keys.length;
				result.displayValue = keys.length <= 5 ? `{${keys.join(", ")}}` : `{${keys.slice(0, 5).join(", ")}, ...${keys.length - 5}}`;
				if (maxDepth > 0) {
					const entries = {};
					for (const key of keys.slice(0, 50)) try {
						entries[key] = ensureRecord(value[key], maxDepth - 1, seen);
					} catch {
						entries[key] = {
							type: "error",
							displayValue: "Error accessing property"
						};
					}
					result.entries = entries;
				}
				return result;
			} finally {
				seen.delete(value);
			}
		}
		case "string": return {
			type: "string",
			value,
			displayValue: `"${value}"`
		};
		case "function": return {
			type: "function",
			displayValue: "ƒ()",
			name: value.name || "anonymous"
		};
		default: return {
			type: typeof value,
			value,
			displayValue: String(value)
		};
	}
};
const propsTracker = /* @__PURE__ */ new Map();
const stateTracker = /* @__PURE__ */ new Map();
const contextTracker = /* @__PURE__ */ new Map();
let lastComponentType = null;
const resetTracking = () => {
	propsTracker.clear();
	stateTracker.clear();
	contextTracker.clear();
	lastComponentType = null;
};
const getStateFromFiber = (fiber) => {
	if (!fiber) return {};
	if (fiber.tag === FunctionComponentTag || fiber.tag === ForwardRefTag || fiber.tag === SimpleMemoComponentTag || fiber.tag === MemoComponentTag) {
		let memoizedState = fiber.memoizedState;
		const state = {};
		let index = 0;
		while (memoizedState) {
			if (memoizedState.queue && memoizedState.memoizedState !== void 0) state[index] = memoizedState.memoizedState;
			memoizedState = memoizedState.next;
			index++;
		}
		return state;
	}
	if (fiber.tag === ClassComponentTag) return fiber.memoizedState || {};
	return {};
};
const collectPropsChanges = (fiber) => {
	const currentProps = fiber.memoizedProps || {};
	const prevProps = fiber.alternate?.memoizedProps || {};
	const current = {};
	const prev = {};
	const allProps = Object.keys(currentProps);
	for (const key of allProps) if (key in currentProps) {
		current[key] = currentProps[key];
		prev[key] = prevProps[key];
	}
	const changes = getChangedPropsDetailed(fiber).map((change) => ({
		name: change.name,
		value: change.value,
		prevValue: change.prevValue
	}));
	return {
		current,
		prev,
		changes
	};
};
const collectStateChanges = (fiber) => {
	const current = getStateFromFiber(fiber);
	const prev = fiber.alternate ? getStateFromFiber(fiber.alternate) : {};
	const changes = [];
	for (const [index, value] of Object.entries(current)) {
		const stateKey = fiber.tag === ClassComponentTag ? index : Number(index);
		if (fiber.alternate && !isEqual(prev[index], value)) changes.push({
			name: stateKey,
			value,
			prevValue: prev[index]
		});
	}
	return {
		current,
		prev,
		changes
	};
};
const collectContextChanges = (fiber) => {
	const currentContexts = getAllFiberContexts(fiber);
	const prevContexts = fiber.alternate ? getAllFiberContexts(fiber.alternate) : /* @__PURE__ */ new Map();
	const current = {};
	const prev = {};
	const changes = [];
	const seenContexts = /* @__PURE__ */ new Set();
	for (const [contextType, ctx] of currentContexts) {
		const name = ctx.displayName;
		const contextKey = contextType;
		if (seenContexts.has(contextKey)) continue;
		seenContexts.add(contextKey);
		current[name] = ctx.value;
		const prevCtx = prevContexts.get(contextType);
		if (prevCtx) {
			prev[name] = prevCtx.value;
			if (!isEqual(prevCtx.value, ctx.value)) changes.push({
				name,
				value: ctx.value,
				prevValue: prevCtx.value,
				contextType
			});
		}
	}
	return {
		current,
		prev,
		changes
	};
};
const fiberContextsCache = /* @__PURE__ */ new WeakMap();
const getAllFiberContexts = (fiber) => {
	if (!fiber) return /* @__PURE__ */ new Map();
	const cachedContexts = fiberContextsCache.get(fiber);
	if (cachedContexts) return cachedContexts;
	const contexts = /* @__PURE__ */ new Map();
	let currentFiber = fiber;
	while (currentFiber) {
		const dependencies = currentFiber.dependencies;
		if (dependencies?.firstContext) {
			let contextItem = dependencies.firstContext;
			while (contextItem) {
				const memoizedValue = contextItem.memoizedValue;
				const displayName = contextItem.context?.displayName;
				if (!contexts.has(memoizedValue)) contexts.set(contextItem.context, {
					value: memoizedValue,
					displayName: displayName ?? "UnnamedContext",
					contextType: null
				});
				if (contextItem === contextItem.next) break;
				contextItem = contextItem.next;
			}
		}
		currentFiber = currentFiber.return;
	}
	fiberContextsCache.set(fiber, contexts);
	return contexts;
};
const collectInspectorDataWithoutCounts = (fiber) => {
	const emptySection = () => ({
		current: [],
		changes: /* @__PURE__ */ new Set(),
		changesCounts: /* @__PURE__ */ new Map()
	});
	if (!fiber) return {
		fiberProps: emptySection(),
		fiberState: emptySection(),
		fiberContext: emptySection()
	};
	const propsData = emptySection();
	if (fiber.memoizedProps) {
		const { current: current$1, changes: changes$1 } = collectPropsChanges(fiber);
		for (const [key, value] of Object.entries(current$1)) propsData.current.push({
			name: key,
			value: isPromise(value) ? {
				type: "promise",
				displayValue: "Promise"
			} : value
		});
		for (const change of changes$1) {
			propsData.changes.add(change.name);
			propsData.changesCounts.set(change.name, 1);
		}
	}
	const stateData = emptySection();
	if (fiber.memoizedState) {
		const { current: current$1, changes: changes$1 } = collectStateChanges(fiber);
		for (const [key, value] of Object.entries(current$1)) stateData.current.push({
			name: key,
			value: isPromise(value) ? {
				type: "promise",
				displayValue: "Promise"
			} : value
		});
		for (const change of changes$1) {
			stateData.changes.add(change.name);
			stateData.changesCounts.set(change.name, 1);
		}
	}
	const contextData = emptySection();
	const { current, changes } = collectContextChanges(fiber);
	for (const [key, value] of Object.entries(current)) contextData.current.push({
		name: key,
		value: isPromise(value) ? {
			type: "promise",
			displayValue: "Promise"
		} : value
	});
	for (const change of changes) {
		contextData.changes.add(change.name);
		contextData.changesCounts.set(change.name, 1);
	}
	return {
		fiberProps: propsData,
		fiberState: stateData,
		fiberContext: contextData
	};
};
const TIMELINE_MAX_UPDATES = 1e3;
const timelineStateDefault = {
	updates: [],
	currentFiber: null,
	totalUpdates: 0,
	windowOffset: 0,
	currentIndex: 0,
	isViewingHistory: false,
	latestFiber: null,
	isVisible: false,
	playbackSpeed: 1
};
const timelineState = /* @__PURE__ */ signal(timelineStateDefault);
const inspectorUpdateSignal = /* @__PURE__ */ signal(0);
let pendingUpdates = [];
let batchTimeout = null;
const batchUpdates = () => {
	if (pendingUpdates.length === 0) return;
	const batchedUpdates = [...pendingUpdates];
	const { updates, totalUpdates, currentIndex, isViewingHistory } = timelineState.value;
	const newUpdates = [...updates];
	let newTotalUpdates = totalUpdates;
	for (const { update } of batchedUpdates) {
		if (newUpdates.length >= TIMELINE_MAX_UPDATES) newUpdates.shift();
		newUpdates.push(update);
		newTotalUpdates++;
	}
	const newWindowOffset = Math.max(0, newTotalUpdates - TIMELINE_MAX_UPDATES);
	let newCurrentIndex;
	if (isViewingHistory) if (currentIndex === totalUpdates - 1) newCurrentIndex = newUpdates.length - 1;
	else if (currentIndex === 0) newCurrentIndex = 0;
	else if (newWindowOffset === 0) newCurrentIndex = currentIndex;
	else newCurrentIndex = currentIndex - 1;
	else newCurrentIndex = newUpdates.length - 1;
	const lastUpdate = batchedUpdates[batchedUpdates.length - 1];
	timelineState.value = {
		...timelineState.value,
		latestFiber: lastUpdate.fiber,
		updates: newUpdates,
		totalUpdates: newTotalUpdates,
		windowOffset: newWindowOffset,
		currentIndex: newCurrentIndex,
		isViewingHistory
	};
	pendingUpdates = pendingUpdates.slice(batchedUpdates.length);
};
const timelineActions = {
	showTimeline: () => {
		timelineState.value = {
			...timelineState.value,
			isVisible: true
		};
	},
	hideTimeline: () => {
		timelineState.value = {
			...timelineState.value,
			isVisible: false,
			currentIndex: timelineState.value.updates.length - 1
		};
	},
	updateFrame: (index, isViewingHistory) => {
		timelineState.value = {
			...timelineState.value,
			currentIndex: index,
			isViewingHistory
		};
	},
	updatePlaybackSpeed: (speed) => {
		timelineState.value = {
			...timelineState.value,
			playbackSpeed: speed
		};
	},
	addUpdate: (update, latestFiber) => {
		pendingUpdates.push({
			update,
			fiber: latestFiber
		});
		if (!batchTimeout) {
			const processBatch = () => {
				batchUpdates();
				batchTimeout = null;
				if (pendingUpdates.length > 0) batchTimeout = setTimeout(processBatch, 96);
			};
			batchTimeout = setTimeout(processBatch, 96);
		}
	},
	reset: () => {
		if (batchTimeout) {
			clearTimeout(batchTimeout);
			batchTimeout = null;
		}
		pendingUpdates = [];
		timelineState.value = timelineStateDefault;
	}
};
const headerInspectClassName = /* @__PURE__ */ computed(() => cn("absolute inset-0 flex items-center gap-x-2", "translate-y-0", "transition-transform duration-300", signalIsSettingsOpen.value && "-translate-y-[200%]"));
const HeaderInspect = () => {
	const refReRenders = useRef$1(null);
	const refTiming = useRef$1(null);
	const [currentFiber, setCurrentFiber] = useState$1(null);
	useSignalEffect(() => {
		const state = Store.inspectState.value;
		if (state.kind === "focused") setCurrentFiber(state.fiber);
	});
	useSignalEffect(() => {
		const state = timelineState.value;
		untracked(() => {
			if (Store.inspectState.value.kind !== "focused") return;
			if (!refReRenders.current || !refTiming.current) return;
			const { totalUpdates, currentIndex, updates, isVisible, windowOffset } = state;
			const reRenders = Math.max(0, totalUpdates - 1);
			const headerText = isVisible ? `#${windowOffset + currentIndex} Re-render` : reRenders > 0 ? `×${reRenders}` : "";
			let formattedTime;
			if (reRenders > 0 && currentIndex >= 0 && currentIndex < updates.length) {
				const time = updates[currentIndex]?.fiberInfo?.selfTime;
				formattedTime = time > 0 ? time < .1 - Number.EPSILON ? "< 0.1ms" : `${Number(time.toFixed(1))}ms` : void 0;
			}
			refReRenders.current.dataset.text = headerText ? ` • ${headerText}` : "";
			refTiming.current.dataset.text = formattedTime ? ` • ${formattedTime}` : "";
		});
	});
	const componentName = useMemo$1(() => {
		if (!currentFiber) return null;
		const { name, wrappers, wrapperTypes } = getExtendedDisplayName(currentFiber);
		const title = wrappers.length ? `${wrappers.join("(")}(${name})${")".repeat(wrappers.length)}` : name ?? "";
		const firstWrapperType = wrapperTypes[0];
		return /* @__PURE__ */ jsxs("span", {
			title,
			className: "flex items-center gap-x-1",
			children: [
				name ?? "Unknown",
				/* @__PURE__ */ jsx("span", {
					title: firstWrapperType?.title,
					className: "flex items-center gap-x-1 text-[10px] text-purple-400",
					children: !!firstWrapperType && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("span", {
						className: cn("rounded py-[1px] px-1", "truncate", firstWrapperType.compiler && "bg-purple-800 text-neutral-400", !firstWrapperType.compiler && "bg-neutral-700 text-neutral-300", firstWrapperType.type === "memo" && "bg-[#5f3f9a] text-white"),
						children: firstWrapperType.type
					}, firstWrapperType.type), firstWrapperType.compiler && /* @__PURE__ */ jsx("span", {
						className: "text-yellow-300",
						children: "✨"
					})] })
				}),
				wrapperTypes.length > 1 && /* @__PURE__ */ jsxs("span", {
					className: "text-[10px] text-neutral-400",
					children: ["×", wrapperTypes.length - 1]
				})
			]
		});
	}, [currentFiber]);
	return /* @__PURE__ */ jsxs("div", {
		className: headerInspectClassName,
		children: [componentName, /* @__PURE__ */ jsxs("div", {
			className: "flex items-center gap-x-2 mr-auto text-xs text-[#888]",
			children: [/* @__PURE__ */ jsx("span", {
				ref: refReRenders,
				className: "with-data-text cursor-pointer !overflow-visible",
				title: "Click to toggle between rerenders and total renders"
			}), /* @__PURE__ */ jsx("span", {
				ref: refTiming,
				className: "with-data-text !overflow-visible"
			})]
		})]
	});
};
const Header = () => {
	const isInitialView = useDelayedValue(Store.inspectState.value.kind === "focused", 150, 0);
	const handleClose = () => {
		signalWidgetViews.value = { view: "none" };
		Store.inspectState.value = { kind: "inspect-off" };
	};
	const isHeaderIsNotifications = signalWidgetViews.value.view === "notifications";
	if (isHeaderIsNotifications) return;
	return /* @__PURE__ */ jsxs("div", {
		className: "react-devtool-header",
		children: [/* @__PURE__ */ jsx("div", {
			className: "relative flex-1 h-full",
			children: /* @__PURE__ */ jsx("div", {
				className: cn("react-devtool-header-item is-visible", !isInitialView && "!duration-0"),
				children: /* @__PURE__ */ jsx(HeaderInspect, {})
			})
		}), /* @__PURE__ */ jsx("button", {
			type: "button",
			title: "Close",
			className: "react-devtool-close-button",
			onClick: handleClose,
			children: /* @__PURE__ */ jsx(Icon, { name: "icon-close" })
		})]
	});
};
function Logo(props) {
	return /* @__PURE__ */ jsxs("svg", {
		width: "100%",
		height: "100%",
		viewBox: "-10.5 -9.45 21 18.9",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...props,
		children: [/* @__PURE__ */ jsx("circle", {
			cx: "0",
			cy: "0",
			r: "2",
			fill: "currentColor"
		}), /* @__PURE__ */ jsxs("g", {
			stroke: "currentColor",
			strokeWidth: "1",
			fill: "none",
			children: [
				/* @__PURE__ */ jsx("ellipse", {
					rx: "10",
					ry: "4.5"
				}),
				/* @__PURE__ */ jsx("ellipse", {
					rx: "10",
					ry: "4.5",
					transform: "rotate(60)"
				}),
				/* @__PURE__ */ jsx("ellipse", {
					rx: "10",
					ry: "4.5",
					transform: "rotate(120)"
				})
			]
		})]
	});
}
let e = -1;
const t = (t$1) => {
	addEventListener("pageshow", (n$1) => {
		n$1.persisted && (e = n$1.timeStamp, t$1(n$1));
	}, !0);
}, n = (e$1, t$1, n$1, i$1) => {
	let o$1, s$1;
	return (r$2) => {
		t$1.value >= 0 && (r$2 || i$1) && (s$1 = t$1.value - (o$1 ?? 0), (s$1 || void 0 === o$1) && (o$1 = t$1.value, t$1.delta = s$1, t$1.rating = ((e$2, t$2) => e$2 > t$2[1] ? "poor" : e$2 > t$2[0] ? "needs-improvement" : "good")(t$1.value, n$1), e$1(t$1)));
	};
}, i = (e$1) => {
	requestAnimationFrame(() => requestAnimationFrame(() => e$1()));
}, o = () => {
	const e$1 = performance.getEntriesByType("navigation")[0];
	if (e$1 && e$1.responseStart > 0 && e$1.responseStart < performance.now()) return e$1;
}, s = () => {
	const e$1 = o();
	return e$1?.activationStart ?? 0;
}, r = (t$1, n$1 = -1) => {
	const i$1 = o();
	let r$2 = "navigate";
	e >= 0 ? r$2 = "back-forward-cache" : i$1 && (document.prerendering || s() > 0 ? r$2 = "prerender" : document.wasDiscarded ? r$2 = "restore" : i$1.type && (r$2 = i$1.type.replace(/_/g, "-")));
	return {
		name: t$1,
		value: n$1,
		rating: "good",
		delta: 0,
		entries: [],
		id: `v5-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`,
		navigationType: r$2
	};
}, c = /* @__PURE__ */ new WeakMap();
function a(e$1, t$1) {
	return c.get(e$1) || c.set(e$1, new t$1()), c.get(e$1);
}
var d = class {
	t;
	i = 0;
	o = [];
	h(e$1) {
		if (e$1.hadRecentInput) return;
		const t$1 = this.o[0], n$1 = this.o.at(-1);
		this.i && t$1 && n$1 && e$1.startTime - n$1.startTime < 1e3 && e$1.startTime - t$1.startTime < 5e3 ? (this.i += e$1.value, this.o.push(e$1)) : (this.i = e$1.value, this.o = [e$1]), this.t?.(e$1);
	}
};
const h$1 = (e$1, t$1, n$1 = {}) => {
	try {
		if (PerformanceObserver.supportedEntryTypes.includes(e$1)) {
			const i$1 = new PerformanceObserver((e$2) => {
				Promise.resolve().then(() => {
					t$1(e$2.getEntries());
				});
			});
			return i$1.observe({
				type: e$1,
				buffered: !0,
				...n$1
			}), i$1;
		}
	} catch {}
}, f = (e$1) => {
	let t$1 = !1;
	return () => {
		t$1 || (e$1(), t$1 = !0);
	};
};
let u = -1;
const l = () => "hidden" !== document.visibilityState || document.prerendering ? Infinity : 0, m = (e$1) => {
	"hidden" === document.visibilityState && u > -1 && (u = "visibilitychange" === e$1.type ? e$1.timeStamp : 0, v());
}, g = () => {
	addEventListener("visibilitychange", m, !0), addEventListener("prerenderingchange", m, !0);
}, v = () => {
	removeEventListener("visibilitychange", m, !0), removeEventListener("prerenderingchange", m, !0);
}, p = () => {
	if (u < 0) {
		const e$1 = s(), n$1 = document.prerendering ? void 0 : globalThis.performance.getEntriesByType("visibility-state").filter((t$1) => "hidden" === t$1.name && t$1.startTime > e$1)[0]?.startTime;
		u = n$1 ?? l(), g(), t(() => {
			setTimeout(() => {
				u = l(), g();
			});
		});
	}
	return { get firstHiddenTime() {
		return u;
	} };
}, y = (e$1) => {
	document.prerendering ? addEventListener("prerenderingchange", () => e$1(), !0) : e$1();
}, b = [1800, 3e3], P = (e$1, o$1 = {}) => {
	y(() => {
		const c$1 = p();
		let a$1, d$1 = r("FCP");
		const f$1 = h$1("paint", (e$2) => {
			for (const t$1 of e$2) "first-contentful-paint" === t$1.name && (f$1.disconnect(), t$1.startTime < c$1.firstHiddenTime && (d$1.value = Math.max(t$1.startTime - s(), 0), d$1.entries.push(t$1), a$1(!0)));
		});
		f$1 && (a$1 = n(e$1, d$1, b, o$1.reportAllChanges), t((t$1) => {
			d$1 = r("FCP"), a$1 = n(e$1, d$1, b, o$1.reportAllChanges), i(() => {
				d$1.value = performance.now() - t$1.timeStamp, a$1(!0);
			});
		}));
	});
}, T = [.1, .25], E = (e$1, o$1 = {}) => {
	P(f(() => {
		let s$1, c$1 = r("CLS", 0);
		const f$1 = a(o$1, d), u$1 = (e$2) => {
			for (const t$1 of e$2) f$1.h(t$1);
			f$1.i > c$1.value && (c$1.value = f$1.i, c$1.entries = f$1.o, s$1());
		}, l$1 = h$1("layout-shift", u$1);
		l$1 && (s$1 = n(e$1, c$1, T, o$1.reportAllChanges), document.addEventListener("visibilitychange", () => {
			"hidden" === document.visibilityState && (u$1(l$1.takeRecords()), s$1(!0));
		}), t(() => {
			f$1.i = 0, c$1 = r("CLS", 0), s$1 = n(e$1, c$1, T, o$1.reportAllChanges), i(() => s$1());
		}), setTimeout(s$1));
	}));
};
let _ = 0, L = Infinity, M$1 = 0;
const C = (e$1) => {
	for (const t$1 of e$1) t$1.interactionId && (L = Math.min(L, t$1.interactionId), M$1 = Math.max(M$1, t$1.interactionId), _ = M$1 ? (M$1 - L) / 7 + 1 : 0);
};
let I;
const w = () => I ? _ : performance.interactionCount ?? 0, F = () => {
	"interactionCount" in performance || I || (I = h$1("event", C, {
		type: "event",
		buffered: !0,
		durationThreshold: 0
	}));
};
let k = 0;
var A = class {
	u = [];
	l = /* @__PURE__ */ new Map();
	m;
	v;
	p() {
		k = w(), this.u.length = 0, this.l.clear();
	}
	P() {
		const e$1 = Math.min(this.u.length - 1, Math.floor((w() - k) / 50));
		return this.u[e$1];
	}
	h(e$1) {
		if (this.m?.(e$1), !e$1.interactionId && "first-input" !== e$1.entryType) return;
		const t$1 = this.u.at(-1);
		let n$1 = this.l.get(e$1.interactionId);
		if (n$1 || this.u.length < 10 || e$1.duration > t$1.T) {
			if (n$1 ? e$1.duration > n$1.T ? (n$1.entries = [e$1], n$1.T = e$1.duration) : e$1.duration === n$1.T && e$1.startTime === n$1.entries[0].startTime && n$1.entries.push(e$1) : (n$1 = {
				id: e$1.interactionId,
				entries: [e$1],
				T: e$1.duration
			}, this.l.set(n$1.id, n$1), this.u.push(n$1)), this.u.sort((e$2, t$2) => t$2.T - e$2.T), this.u.length > 10) {
				const e$2 = this.u.splice(10);
				for (const t$2 of e$2) this.l.delete(t$2.id);
			}
			this.v?.(n$1);
		}
	}
};
const B = (e$1) => {
	const t$1 = globalThis.requestIdleCallback || setTimeout;
	"hidden" === document.visibilityState ? e$1() : (e$1 = f(e$1), document.addEventListener("visibilitychange", e$1, { once: !0 }), t$1(() => {
		e$1(), document.removeEventListener("visibilitychange", e$1);
	}));
}, N = [200, 500], S = (e$1, i$1 = {}) => {
	globalThis.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype && y(() => {
		F();
		let o$1, s$1 = r("INP");
		const c$1 = a(i$1, A), d$1 = (e$2) => {
			B(() => {
				for (const t$2 of e$2) c$1.h(t$2);
				const t$1 = c$1.P();
				t$1 && t$1.T !== s$1.value && (s$1.value = t$1.T, s$1.entries = t$1.entries, o$1());
			});
		}, f$1 = h$1("event", d$1, { durationThreshold: i$1.durationThreshold ?? 40 });
		o$1 = n(e$1, s$1, N, i$1.reportAllChanges), f$1 && (f$1.observe({
			type: "first-input",
			buffered: !0
		}), document.addEventListener("visibilitychange", () => {
			"hidden" === document.visibilityState && (d$1(f$1.takeRecords()), o$1(!0));
		}), t(() => {
			c$1.p(), s$1 = r("INP"), o$1 = n(e$1, s$1, N, i$1.reportAllChanges);
		}));
	});
};
var q = class {
	m;
	h(e$1) {
		this.m?.(e$1);
	}
};
const x = [2500, 4e3], O = (e$1, o$1 = {}) => {
	y(() => {
		const c$1 = p();
		let d$1, u$1 = r("LCP");
		const l$1 = a(o$1, q), m$1 = (e$2) => {
			o$1.reportAllChanges || (e$2 = e$2.slice(-1));
			for (const t$1 of e$2) l$1.h(t$1), t$1.startTime < c$1.firstHiddenTime && (u$1.value = Math.max(t$1.startTime - s(), 0), u$1.entries = [t$1], d$1());
		}, g$2 = h$1("largest-contentful-paint", m$1);
		if (g$2) {
			d$1 = n(e$1, u$1, x, o$1.reportAllChanges);
			const s$1 = f(() => {
				m$1(g$2.takeRecords()), g$2.disconnect(), d$1(!0);
			});
			for (const e$2 of [
				"keydown",
				"click",
				"visibilitychange"
			]) addEventListener(e$2, () => B(s$1), {
				capture: !0,
				once: !0
			});
			t((t$1) => {
				u$1 = r("LCP"), d$1 = n(e$1, u$1, x, o$1.reportAllChanges), i(() => {
					u$1.value = performance.now() - t$1.timeStamp, d$1(!0);
				});
			});
		}
	});
}, $ = [800, 1800], D$1 = (e$1) => {
	document.prerendering ? y(() => D$1(e$1)) : "complete" !== document.readyState ? addEventListener("load", () => D$1(e$1), !0) : setTimeout(e$1);
}, H = (e$1, i$1 = {}) => {
	let c$1 = r("TTFB"), a$1 = n(e$1, c$1, $, i$1.reportAllChanges);
	D$1(() => {
		const d$1 = o();
		d$1 && (c$1.value = Math.max(d$1.responseStart - s(), 0), c$1.entries = [d$1], a$1(!0), t(() => {
			c$1 = r("TTFB", 0), a$1 = n(e$1, c$1, $, i$1.reportAllChanges), a$1(!0);
		}));
	});
};
const CopyToClipboard = /* @__PURE__ */ M(({ text, children, onCopy, className, iconSize = 14 }) => {
	const [isCopied, setIsCopied] = useState$1(false);
	useEffect$1(() => {
		if (isCopied) {
			const timeout = setTimeout(() => setIsCopied(false), 600);
			return () => {
				clearTimeout(timeout);
			};
		}
	}, [isCopied]);
	const copyToClipboard = useCallback$1((e$1) => {
		e$1.preventDefault();
		e$1.stopPropagation();
		navigator.clipboard.writeText(text).then(() => {
			setIsCopied(true);
			onCopy?.(true, text);
		}, () => {
			onCopy?.(false, text);
		});
	}, [text, onCopy]);
	const ClipboardIcon = /* @__PURE__ */ jsx("button", {
		onClick: copyToClipboard,
		type: "button",
		className: cn("z-10", "flex items-center justify-center", "hover:text-dev-pink-400", "transition-colors duration-200 ease-in-out", "cursor-pointer", `size-[${iconSize}px]`, className),
		children: /* @__PURE__ */ jsx(Icon, {
			name: `icon-${isCopied ? "check" : "copy"}`,
			size: [iconSize],
			className: cn(isCopied && "text-green-500")
		})
	});
	if (!children) return ClipboardIcon;
	return children({
		ClipboardIcon,
		onClick: copyToClipboard
	});
});
const assignRef = (ref, value) => {
	if (typeof ref === "function") ref(value);
	else if (ref !== null) ref.current = value;
};
const mergeRefs = (...refs) => {
	return (node) => {
		for (const ref of refs) if (ref) assignRef(ref, node);
	};
};
const useMergedRefs = (...refs) => {
	return (0, compat_module_exports.useCallback)(mergeRefs(...refs), [...refs]);
};
const EditableValue = ({ value, onSave, onCancel }) => {
	const refInput = useRef$1(null);
	const [editValue, setEditValue] = useState$1("");
	useEffect$1(() => {
		let initialValue = "";
		try {
			if (value instanceof Date) initialValue = value.toISOString().slice(0, 16);
			else if (value instanceof Map || value instanceof Set || value instanceof RegExp || value instanceof Error || value instanceof ArrayBuffer || ArrayBuffer.isView(value) || typeof value === "object" && value !== null) initialValue = formatValue(value);
			else initialValue = formatInitialValue(value);
		} catch {
			initialValue = String(value);
		}
		const sanitizedValue = sanitizeString(initialValue);
		setEditValue(sanitizedValue);
		requestAnimationFrame(() => {
			if (!refInput.current) return;
			refInput.current.focus();
			if (typeof value === "string") refInput.current.setSelectionRange(1, sanitizedValue.length - 1);
			else refInput.current.select();
		});
	}, [value]);
	const handleChange = useCallback$1((e$1) => {
		const target = e$1.target;
		if (target) setEditValue(target.value);
	}, []);
	const handleKeyDown = (e$1) => {
		if (e$1.key === "Enter") {
			e$1.preventDefault();
			try {
				let newValue;
				if (value instanceof Date) {
					const date = new Date(editValue);
					if (Number.isNaN(date.getTime())) throw new Error("Invalid date");
					newValue = date;
				} else {
					const detected = detectValueType(editValue);
					newValue = detected.value;
				}
				onSave(newValue);
			} catch {
				onCancel();
			}
		} else if (e$1.key === "Escape") {
			e$1.preventDefault();
			e$1.stopPropagation();
			e$1.stopImmediatePropagation();
			onCancel();
		}
	};
	return /* @__PURE__ */ jsx("input", {
		ref: refInput,
		type: value instanceof Date ? "datetime-local" : "text",
		className: "react-devtool-input flex-1 font-text",
		value: editValue,
		onChange: handleChange,
		onKeyDown: handleKeyDown,
		onBlur: onCancel,
		step: value instanceof Date ? 1 : void 0
	});
};
const PropertyElement = ({ name, value, level, parentPath, allowEditing = true, onSave }) => {
	const refElement = useRef$1(null);
	const currentPath = parentPath ? `${parentPath}.${name}` : name;
	const [isExpanded, setIsExpanded] = useState$1(globalInspectorState.expandedPaths.has(currentPath));
	const [isEditing, setIsEditing] = useState$1(false);
	const prevValue = globalInspectorState.lastRendered.get(currentPath);
	const isChanged = !isEqual(prevValue, value);
	useEffect$1(() => {
		if (name === "children") return;
		const isFirstRender = !globalInspectorState.lastRendered.has(currentPath);
		const shouldFlash = isChanged && refElement.current && !isFirstRender;
		globalInspectorState.lastRendered.set(currentPath, value);
		if (shouldFlash && refElement.current && level === 0) flashManager.create(refElement.current);
	}, [
		value,
		isChanged,
		currentPath,
		level,
		name
	]);
	const handleToggleExpand = useCallback$1(() => {
		setIsExpanded((prevState) => {
			const newIsExpanded = !prevState;
			if (newIsExpanded) globalInspectorState.expandedPaths.add(currentPath);
			else globalInspectorState.expandedPaths.delete(currentPath);
			return newIsExpanded;
		});
	}, [currentPath]);
	const valuePreview = useMemo$1(() => {
		if (typeof value === "object" && value !== null) {
			if ("displayValue" in value) return String(value.displayValue);
		}
		return formatValue(value);
	}, [value]);
	const clipboardText = useMemo$1(() => {
		if (typeof value === "object" && value !== null) {
			if ("value" in value) return String(formatForClipboard(value.value));
			if ("displayValue" in value) return String(value.displayValue);
		}
		return String(formatForClipboard(value));
	}, [value]);
	const isExpandableValue = useMemo$1(() => {
		if (!value || typeof value !== "object") return false;
		if ("type" in value) {
			const metadata = value;
			switch (metadata.type) {
				case "array":
				case "Map":
				case "Set": return (metadata.size ?? metadata.length ?? 0) > 0;
				case "object": return (metadata.size ?? 0) > 0;
				case "ArrayBuffer":
				case "DataView": return (metadata.byteLength ?? 0) > 0;
				case "circular":
				case "promise":
				case "function":
				case "error": return false;
				default:
					if ("entries" in metadata || "items" in metadata) return true;
					return false;
			}
		}
		return isExpandable(value);
	}, [value]);
	const canEdit = useMemo$1(() => {
		if (!allowEditing) return false;
		return true;
	}, [allowEditing]);
	const handleEdit = useCallback$1(() => {
		if (canEdit) setIsEditing(true);
	}, [canEdit]);
	const handleSave = (newValue) => {
		const path = currentPath.split(".");
		onSave(path, newValue);
		setIsEditing(false);
	};
	const checkCircularInValue = useMemo$1(() => {
		if (!value || typeof value !== "object" || isPromise(value)) return false;
		return "type" in value && value.type === "circular";
	}, [value]);
	const renderNestedProperties = useCallback$1((obj) => {
		if (!obj || typeof obj !== "object") return null;
		if ("type" in obj) {
			const metadata = obj;
			if ("entries" in metadata && metadata.entries) {
				const entries$1 = Object.entries(metadata.entries);
				if (entries$1.length === 0) return null;
				return /* @__PURE__ */ jsx("div", {
					className: "react-devtool-nested",
					children: entries$1.map(([key, val]) => /* @__PURE__ */ jsx(PropertyElement, {
						name: key,
						value: val,
						level: level + 1,
						parentPath: currentPath,
						allowEditing,
						onSave
					}, `${currentPath}-entry-${key}`))
				});
			}
			if ("items" in metadata && Array.isArray(metadata.items)) {
				if (metadata.items.length === 0) return null;
				return /* @__PURE__ */ jsx("div", {
					className: "react-devtool-nested",
					children: metadata.items.map((item, i$1) => {
						const itemKey = `${currentPath}-item-${item.type}-${i$1}`;
						return /* @__PURE__ */ jsx(PropertyElement, {
							name: `${i$1}`,
							value: item,
							level: level + 1,
							parentPath: currentPath,
							allowEditing,
							onSave
						}, itemKey);
					})
				});
			}
			return null;
		}
		let entries;
		if (obj instanceof ArrayBuffer) {
			const view = new Uint8Array(obj);
			entries = Array.from(view).map((v$1, i$1) => [i$1, v$1]);
		} else if (obj instanceof DataView) {
			const view = new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
			entries = Array.from(view).map((v$1, i$1) => [i$1, v$1]);
		} else if (ArrayBuffer.isView(obj)) if (obj instanceof BigInt64Array || obj instanceof BigUint64Array) entries = Array.from({ length: obj.length }, (_$1, i$1) => [i$1, obj[i$1]]);
		else {
			const typedArray = obj;
			entries = Array.from(typedArray).map((v$1, i$1) => [i$1, v$1]);
		}
		else if (obj instanceof Map) entries = Array.from(obj.entries()).map(([k$2, v$1]) => [String(k$2), v$1]);
		else if (obj instanceof Set) entries = Array.from(obj).map((v$1, i$1) => [i$1, v$1]);
		else if (Array.isArray(obj)) entries = obj.map((value$1, index) => [`${index}`, value$1]);
		else entries = Object.entries(obj);
		if (entries.length === 0) return null;
		const canEditChildren = !(obj instanceof DataView || obj instanceof ArrayBuffer || ArrayBuffer.isView(obj));
		return /* @__PURE__ */ jsx("div", {
			className: "react-devtool-nested",
			children: entries.map(([key, val]) => {
				const itemKey = `${currentPath}-${typeof key === "number" ? `item-${key}` : key}`;
				return /* @__PURE__ */ jsx(PropertyElement, {
					name: String(key),
					value: val,
					level: level + 1,
					parentPath: currentPath,
					allowEditing: canEditChildren,
					onSave
				}, itemKey);
			})
		});
	}, [
		level,
		currentPath,
		allowEditing,
		onSave
	]);
	if (checkCircularInValue) return /* @__PURE__ */ jsx("div", {
		className: "react-devtool-property",
		children: /* @__PURE__ */ jsx("div", {
			className: "react-devtool-property-content",
			children: /* @__PURE__ */ jsxs("div", {
				className: "react-devtool-preview-line",
				children: [/* @__PURE__ */ jsxs("div", {
					className: "react-devtool-key",
					children: [name, ":"]
				}), /* @__PURE__ */ jsx("span", {
					className: "text-yellow-500",
					children: "[Circular Reference]"
				})]
			})
		})
	});
	return /* @__PURE__ */ jsx("div", {
		ref: refElement,
		className: "react-devtool-property",
		children: /* @__PURE__ */ jsxs("div", {
			className: "react-devtool-property-content",
			children: [
				isExpandableValue && /* @__PURE__ */ jsx("button", {
					type: "button",
					onClick: handleToggleExpand,
					className: "react-devtool-arrow",
					children: /* @__PURE__ */ jsx(Icon, {
						name: "icon-chevron-right",
						size: 12,
						className: cn(isExpanded && "rotate-90")
					})
				}),
				/* @__PURE__ */ jsxs("div", {
					className: cn("group", "react-devtool-preview-line", isChanged && "react-devtool-highlight"),
					children: [
						/* @__PURE__ */ jsxs("div", {
							className: "react-devtool-key !text-white z-[99999] font-display",
							children: [name, ":"]
						}),
						isEditing && isEditableValue(value, parentPath) ? /* @__PURE__ */ jsx(EditableValue, {
							value,
							onSave: handleSave,
							onCancel: () => setIsEditing(false)
						}) : typeof value === "boolean" && canEdit ? /* @__PURE__ */ jsxs("div", {
							className: "react-devtool-toggle",
							children: [/* @__PURE__ */ jsx("input", {
								type: "checkbox",
								checked: value,
								onChange: (e$1) => handleSave(e$1.currentTarget.checked)
							}), /* @__PURE__ */ jsx("div", {})]
						}) : /* @__PURE__ */ jsx("button", {
							type: "button",
							className: "truncate",
							onClick: handleEdit,
							children: valuePreview
						}),
						/* @__PURE__ */ jsx(CopyToClipboard, {
							text: clipboardText,
							className: "opacity-0 transition-opacity group-hover:opacity-100",
							children: ({ ClipboardIcon }) => /* @__PURE__ */ jsx(Fragment$1, { children: ClipboardIcon })
						})
					]
				}),
				/* @__PURE__ */ jsx("div", {
					className: cn("react-devtool-expandable", isExpanded && "react-devtool-expanded"),
					children: isExpandableValue && isExpanded && /* @__PURE__ */ jsx("div", {
						className: "react-devtool-nested",
						children: renderNestedProperties(value)
					})
				})
			]
		})
	});
};
const PropertySection = ({ refSticky, isSticky, name, data }) => {
	const refStickyElement = useRef$1(null);
	const [isExpanded, setIsExpanded] = useState$1(true);
	const refs = useMergedRefs(refStickyElement, refSticky);
	const currentData = data.value;
	const handleSave = useCallback$1((path, value) => {
		const newData = updateNestedValue(data.value, path, value);
		if (typeof newData === "object" && newData !== null) data.value = { ...newData };
	}, [data]);
	const toggleExpanded = useCallback$1(() => {
		setIsExpanded((state) => {
			if (isSticky && isExpanded) return state;
			return !state;
		});
	}, [isExpanded, isSticky]);
	if (!currentData || (Array.isArray(currentData) ? currentData.length === 0 : Object.keys(currentData).length === 0)) return null;
	const propertyCount = Array.isArray(currentData) ? currentData.length : Object.keys(currentData).length;
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsxs("button", {
		ref: refs,
		type: "button",
		onClick: toggleExpanded,
		"data-sticky": true,
		className: "react-section-header",
		children: [/* @__PURE__ */ jsx("div", {
			className: "w-4 h-4 flex items-center justify-center",
			children: /* @__PURE__ */ jsx(Icon, {
				name: "icon-chevron-right",
				size: 12,
				className: cn(isExpanded && "rotate-90", isSticky && isExpanded && "rotate-0")
			})
		}), /* @__PURE__ */ jsxs("span", {
			className: "capitalize",
			children: [
				name,
				" ",
				!isExpanded && propertyCount > 0 && `(${propertyCount})`
			]
		})]
	}), /* @__PURE__ */ jsx("div", {
		className: "react-devtool-section",
		children: /* @__PURE__ */ jsx("div", {
			className: cn("react-devtool-expandable", isExpanded && "react-devtool-expanded"),
			children: /* @__PURE__ */ jsx("div", {
				className: "overflow-hidden",
				children: Array.isArray(currentData) ? currentData.map(({ name: name$1, value }) => /* @__PURE__ */ jsx(PropertyElement, {
					name: name$1,
					value,
					level: 0,
					onSave: handleSave
				}, name$1)) : Object.entries(currentData).map(([key, value]) => /* @__PURE__ */ jsx(PropertyElement, {
					name: key,
					value,
					level: 0,
					onSave: handleSave
				}, key))
			})
		})
	})] });
};
function createPropertyRenderer() {
	return {
		renderToDOM: (container, props) => {
			render(h(PropertySection, props), container);
		},
		unmount: (container) => {
			render(null, container);
		}
	};
}
const MainViewHeader = () => {
	return /* @__PURE__ */ jsx("div", {
		className: cn(["w-full flex border-b border-[#27272A] min-h-[48px]"]),
		children: /* @__PURE__ */ jsxs("div", {
			className: cn(["min-w-fit w-full justify-start flex items-center pl-5 pr-2 text-sm gap-x-4"]),
			children: [/* @__PURE__ */ jsxs("div", {
				className: "flex items-center gap-x-2",
				children: [/* @__PURE__ */ jsx(Logo, { className: "text-sm me-0 w-4 h-4 text-brand-dark flex origin-center transition-all ease-in-out" }), /* @__PURE__ */ jsx("span", {
					className: "font-medium font-display text-white",
					children: "React Devtool"
				})]
			}), /* @__PURE__ */ jsx("div", {
				className: cn(["flex items-center gap-x-2 justify-end ml-auto"]),
				children: /* @__PURE__ */ jsx("div", {
					className: cn(["p-2 flex justify-center items-center border-[#27272A]"]),
					children: /* @__PURE__ */ jsx("button", {
						type: "button",
						onClick: () => {
							signalWidgetViews.value = { view: "none" };
						},
						title: "Close",
						children: /* @__PURE__ */ jsx(Icon, {
							name: "icon-close",
							size: 18,
							className: "text-[#6F6F78]"
						})
					})
				})
			})]
		})
	});
};
const TABS = [
	{
		id: "app",
		title: "App"
	},
	{
		id: "layout-shifts",
		title: "Layout Shifts"
	},
	{
		id: "open-graph",
		title: "Open Graph"
	}
];
const ResizablePanel = ({ leftPanel, rightPanel, showLeftPanel }) => {
	const refSidebar = useRef$1(null);
	const refIsResizing = useRef$1(false);
	const [sidebarWidth, setSidebarWidth] = useState$1(150);
	const handleResize = useCallback$1((e$1) => {
		e$1.preventDefault();
		e$1.stopPropagation();
		if (!refSidebar.current) return;
		refIsResizing.current = true;
		refSidebar.current.style.pointerEvents = "none";
		document.body.style.cursor = "col-resize";
		const startWidth = refSidebar.current.offsetWidth;
		const startX = e$1.clientX;
		const maxSidebarWidth = window.innerWidth * .8;
		const handlePointerMove = (e$2) => {
			if (!refIsResizing.current) return;
			const newWidth = startWidth + e$2.clientX - startX;
			if (newWidth > 150 && newWidth < maxSidebarWidth) setSidebarWidth(newWidth);
		};
		const handlePointerUp = () => {
			refIsResizing.current = false;
			if (refSidebar.current) refSidebar.current.style.pointerEvents = "auto";
			document.body.style.cursor = "auto";
			document.removeEventListener("pointermove", handlePointerMove);
			document.removeEventListener("pointerup", handlePointerUp);
		};
		document.addEventListener("pointermove", handlePointerMove);
		document.addEventListener("pointerup", handlePointerUp);
	}, []);
	const rightPanelId = "main-content-panel";
	return /* @__PURE__ */ jsxs("div", {
		className: "flex h-full w-full",
		children: [showLeftPanel && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("div", {
			ref: refSidebar,
			className: "h-full",
			style: { width: `${sidebarWidth}px` },
			children: leftPanel
		}), /* @__PURE__ */ jsx("button", {
			type: "button",
			onPointerDown: handleResize,
			"aria-label": "Resize sidebar",
			className: "group w-2 !cursor-col-resize flex items-center justify-center bg-transparent",
			children: /* @__PURE__ */ jsx("div", { className: "w-[3px] h-8 bg-neutral-700 rounded-full group-hover:bg-brand-dark transition-colors" })
		})] }), /* @__PURE__ */ jsx("div", {
			id: rightPanelId,
			className: "flex-1 h-full overflow-y-scroll",
			children: rightPanel
		})]
	});
};
const ReactContentRenderer = () => {
	const refContainer = useRef$1(null);
	const refRoot = useRef$1(null);
	const [, forceUpdate] = useState$1({});
	useEffect$1(() => {
		const container = refContainer.current;
		if (!container) return;
		let unmounted = false;
		let createRootPromise = null;
		const renderReactContent = (children) => {
			if (!createRootPromise) createRootPromise = import("react-dom/client").catch((err) => {
				console.error("react-devtool: Failed to import 'react-dom/client'. If you are passing React children to <Devtool>, please ensure 'react-dom' is installed.", err);
				if (container && !unmounted) container.innerHTML = `<div style="color: #f87171; padding: 1rem; font-family: sans-serif;"><strong>Devtool Error</strong><br/>Could not render content because <code>react-dom</code> is not installed.</div>`;
				return null;
			});
			createRootPromise.then((ReactDOMClient) => {
				if (unmounted || !ReactDOMClient) return;
				if (!refRoot.current) refRoot.current = ReactDOMClient.createRoot(container);
				refRoot.current.render(children || null);
			});
		};
		const unsubscribe = userChildren.subscribe(renderReactContent);
		if (userChildren.value) renderReactContent(userChildren.value);
		return () => {
			unmounted = true;
			unsubscribe();
			if (refRoot.current) {
				refRoot.current.unmount();
				refRoot.current = null;
			}
		};
	}, []);
	return /* @__PURE__ */ jsx("div", {
		ref: refContainer,
		className: "h-full w-full"
	});
};
const TabSidebar = ({ selectedTab, onSelectTab }) => {
	const handleTabClick = (tabId) => {
		document.startViewTransition(() => {
			onSelectTab(tabId);
		});
	};
	return /* @__PURE__ */ jsx("div", {
		className: "flex flex-col h-full bg-[#1e1e1e] p-2 gap-1 font-text",
		children: TABS.map((tab) => /* @__PURE__ */ jsx("button", {
			type: "button",
			onClick: () => handleTabClick(tab.id),
			className: cn("p-2 rounded text-left text-sm transition-colors w-full truncate", selectedTab === tab.id ? "bg-brand-dark text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white"),
			children: tab.title
		}, tab.id))
	});
};
const useLayoutShifts = () => {
	const [vitals, setVitals] = useState$1({
		cls: 0,
		inp: 0,
		fcp: 0,
		lcp: 0,
		ttfb: 0
	});
	const [shifts, setShifts] = useState$1([]);
	useEffect$1(() => {
		E((metric) => {
			setVitals((prev) => ({
				...prev,
				cls: metric.value
			}));
			setShifts((prev) => [...prev, {
				value: metric.value,
				entries: metric.entries.map((entry) => ({
					name: entry.name || "Unknown",
					startTime: entry.startTime,
					value: entry.value
				})),
				timestamp: Date.now(),
				id: metric.id
			}]);
		});
		S((metric) => {
			setVitals((prev) => ({
				...prev,
				inp: metric.value
			}));
		});
		P((metric) => {
			setVitals((prev) => ({
				...prev,
				fcp: metric.value
			}));
		});
		O((metric) => {
			setVitals((prev) => ({
				...prev,
				lcp: metric.value
			}));
		});
		H((metric) => {
			setVitals((prev) => ({
				...prev,
				ttfb: metric.value
			}));
		});
	}, []);
	return {
		vitals,
		shifts
	};
};
const useOpenGraph = () => {
	const [ogData, setOgData] = useState$1({});
	const [twitterData, setTwitterData] = useState$1({});
	useEffect$1(() => {
		const extractMetaTags = () => {
			const metaTags = document.querySelectorAll("meta");
			const og = {};
			const twitter = {};
			metaTags.forEach((tag) => {
				const property = tag.getAttribute("property") || tag.getAttribute("name");
				const content = tag.getAttribute("content");
				if (property && content) {
					if (property.startsWith("og:")) og[property] = content;
					else if (property.startsWith("twitter:")) twitter[property] = content;
				}
			});
			og["title"] = og["og:title"] || document.title;
			og["description"] = og["og:description"] || document.querySelector("meta[name=\"description\"]")?.getAttribute("content") || "";
			og["url"] = og["og:url"] || window.location.href;
			setOgData(og);
			setTwitterData(twitter);
		};
		extractMetaTags();
		const observer = new MutationObserver(extractMetaTags);
		observer.observe(document.head, {
			childList: true,
			subtree: true
		});
		return () => observer.disconnect();
	}, []);
	return {
		ogData,
		twitterData
	};
};
const TabContent = ({ selectedTab }) => {
	const { vitals, shifts } = useLayoutShifts();
	const { ogData, twitterData } = useOpenGraph();
	const renderTabContent = () => {
		switch (selectedTab) {
			case "layout-shifts": return /* @__PURE__ */ jsxs("div", {
				className: "h-full w-full p-4 text-white space-y-8",
				style: { viewTransitionName: "tab-content" },
				children: [/* @__PURE__ */ jsxs("div", {
					className: "space-y-6",
					children: [/* @__PURE__ */ jsxs("div", {
						className: "flex items-center gap-3",
						children: [/* @__PURE__ */ jsx("div", { className: "w-1 h-6 bg-brand-dark rounded-full" }), /* @__PURE__ */ jsx("h2", {
							className: "text-xl font-display font-semibold text-white",
							children: "Core Web Vitals"
						})]
					}), /* @__PURE__ */ jsxs("div", {
						className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4",
						children: [
							/* @__PURE__ */ jsxs("div", {
								className: "bg-gray-800/50 rounded-lg p-4 border border-gray-700/50 hover:border-yellow-400/30 transition-colors",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-center gap-2 mb-3",
									children: [/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-yellow-400 rounded-full" }), /* @__PURE__ */ jsx("span", {
										className: "text-xs font-medium text-gray-300",
										children: "CLS"
									})]
								}), /* @__PURE__ */ jsx("div", {
									className: "text-md font-mono font-bold text-yellow-400",
									children: vitals.cls.toFixed(2)
								})]
							}),
							/* @__PURE__ */ jsxs("div", {
								className: "bg-gray-800/50 rounded-lg p-4 border border-gray-700/50 hover:border-blue-400/30 transition-colors",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-center gap-2 mb-3",
									children: [/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-blue-400 rounded-full" }), /* @__PURE__ */ jsx("span", {
										className: "text-xs font-medium text-gray-300",
										children: "INP"
									})]
								}), /* @__PURE__ */ jsxs("div", {
									className: "text-md font-mono font-bold text-blue-400",
									children: [vitals.inp.toFixed(0), /* @__PURE__ */ jsx("span", {
										className: "text-xs text-gray-400 ml-1",
										children: "ms"
									})]
								})]
							}),
							/* @__PURE__ */ jsxs("div", {
								className: "bg-gray-800/50 rounded-lg p-4 border border-gray-700/50 hover:border-green-400/30 transition-colors",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-center gap-2 mb-3",
									children: [/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-green-400 rounded-full" }), /* @__PURE__ */ jsx("span", {
										className: "text-xs font-medium text-gray-300",
										children: "FCP"
									})]
								}), /* @__PURE__ */ jsxs("div", {
									className: "text-md font-mono font-bold text-green-400",
									children: [vitals.fcp.toFixed(0), /* @__PURE__ */ jsx("span", {
										className: "text-xs text-gray-400 ml-1",
										children: "ms"
									})]
								})]
							}),
							/* @__PURE__ */ jsxs("div", {
								className: "bg-gray-800/50 rounded-lg p-4 border border-gray-700/50 hover:border-purple-400/30 transition-colors",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-center gap-2 mb-3",
									children: [/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-purple-400 rounded-full" }), /* @__PURE__ */ jsx("span", {
										className: "text-xs font-medium text-gray-300",
										children: "LCP"
									})]
								}), /* @__PURE__ */ jsxs("div", {
									className: "text-md font-mono font-bold text-purple-400",
									children: [vitals.lcp.toFixed(0), /* @__PURE__ */ jsx("span", {
										className: "text-xs text-gray-400 ml-1",
										children: "ms"
									})]
								})]
							}),
							/* @__PURE__ */ jsxs("div", {
								className: "bg-gray-800/50 rounded-lg p-4 border border-gray-700/50 hover:border-red-400/30 transition-colors",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-center gap-2 mb-3",
									children: [/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-red-400 rounded-full" }), /* @__PURE__ */ jsx("span", {
										className: "text-xs font-medium text-gray-300",
										children: "TTFB"
									})]
								}), /* @__PURE__ */ jsxs("div", {
									className: "text-md font-mono font-bold text-red-400",
									children: [vitals.ttfb.toFixed(0), /* @__PURE__ */ jsx("span", {
										className: "text-xs text-gray-400 ml-1",
										children: "ms"
									})]
								})]
							})
						]
					})]
				}), /* @__PURE__ */ jsxs("div", {
					className: "space-y-4",
					children: [/* @__PURE__ */ jsxs("div", {
						className: "flex items-center gap-3",
						children: [
							/* @__PURE__ */ jsx("div", { className: "w-1 h-6 bg-yellow-400 rounded-full" }),
							/* @__PURE__ */ jsx("h2", {
								className: "text-xl font-display font-semibold text-white",
								children: "Layout Shift Events"
							}),
							shifts.length > 0 && /* @__PURE__ */ jsxs("span", {
								className: "px-2 py-1 text-xs font-medium bg-yellow-400/10 text-yellow-400 rounded-full",
								children: [shifts.length, " events"]
							})
						]
					}), shifts.length === 0 ? /* @__PURE__ */ jsxs("div", {
						className: "bg-gray-800/30 rounded-xl p-8 border border-gray-700/30 text-center",
						children: [
							/* @__PURE__ */ jsx("div", {
								className: "w-12 h-12 bg-green-400/10 rounded-full flex items-center justify-center mx-auto mb-3",
								children: /* @__PURE__ */ jsx(Icon, {
									name: "icon-close",
									size: 20,
									className: "text-green-400"
								})
							}),
							/* @__PURE__ */ jsx("div", {
								className: "text-gray-300 font-medium mb-1",
								children: "No layout shifts detected"
							}),
							/* @__PURE__ */ jsx("div", {
								className: "text-sm text-gray-400",
								children: "Try interacting with the page to trigger measurements"
							})
						]
					}) : /* @__PURE__ */ jsx("div", {
						className: "space-y-3",
						children: shifts.map((shift) => /* @__PURE__ */ jsx("div", {
							className: "bg-gray-800/50 rounded-lg border border-gray-700/50 hover:border-yellow-400/30 transition-colors",
							children: /* @__PURE__ */ jsxs("div", {
								className: "p-4",
								children: [/* @__PURE__ */ jsxs("div", {
									className: "flex items-center justify-between mb-3",
									children: [/* @__PURE__ */ jsxs("div", {
										className: "flex items-center gap-2",
										children: [
											/* @__PURE__ */ jsx("div", { className: "w-2 h-2 bg-yellow-400 rounded-full" }),
											/* @__PURE__ */ jsx("span", {
												className: "font-mono text-yellow-400 font-bold",
												children: shift.value.toFixed(4)
											}),
											/* @__PURE__ */ jsx("span", {
												className: "text-xs text-gray-400",
												children: "shift value"
											})
										]
									}), /* @__PURE__ */ jsx("span", {
										className: "text-xs text-gray-400 font-mono",
										children: new Date(shift.timestamp).toLocaleTimeString()
									})]
								}), shift.entries.length > 0 && /* @__PURE__ */ jsx("div", {
									className: "space-y-2",
									children: shift.entries.map((entry, entryIndex) => /* @__PURE__ */ jsxs("div", {
										className: "flex items-center gap-2 text-sm",
										children: [
											/* @__PURE__ */ jsx("div", { className: "w-1 h-1 bg-gray-400 rounded-full" }),
											/* @__PURE__ */ jsx("span", {
												className: "text-gray-300",
												children: entry.name
											}),
											/* @__PURE__ */ jsx("span", {
												className: "text-gray-500",
												children: "•"
											}),
											/* @__PURE__ */ jsx("span", {
												className: "font-mono text-gray-400",
												children: entry.value.toFixed(4)
											})
										]
									}, `${shift.id}-${entryIndex}`))
								})]
							})
						}, shift.id))
					})]
				})]
			});
			case "open-graph": return /* @__PURE__ */ jsxs("div", {
				className: "h-full w-full p-6 text-white space-y-8",
				style: { viewTransitionName: "tab-content" },
				children: [
					/* @__PURE__ */ jsxs("div", {
						className: "space-y-4",
						children: [/* @__PURE__ */ jsxs("div", {
							className: "flex items-center gap-3",
							children: [/* @__PURE__ */ jsx("div", { className: "w-1 h-6 bg-brand-dark rounded-full" }), /* @__PURE__ */ jsx("h2", {
								className: "text-xl font-display font-semibold text-white",
								children: "Social Media Preview"
							})]
						}), /* @__PURE__ */ jsxs("div", {
							className: "bg-gray-800/50 rounded-xl border border-gray-700/50 p-6 max-w-md",
							children: [
								/* @__PURE__ */ jsx("div", {
									className: "text-xs text-gray-400 mb-3 uppercase tracking-wide font-medium",
									children: "Link Preview"
								}),
								ogData["og:image"] && /* @__PURE__ */ jsx("div", {
									className: "mb-4 overflow-hidden rounded-lg",
									children: /* @__PURE__ */ jsx("img", {
										src: ogData["og:image"],
										alt: "Preview",
										className: "w-full h-40 object-cover",
										onError: (e$1) => {
											e$1.currentTarget.style.display = "none";
										}
									})
								}),
								/* @__PURE__ */ jsxs("div", {
									className: "space-y-2",
									children: [
										/* @__PURE__ */ jsx("h3", {
											className: "font-semibold text-white line-clamp-2 leading-snug",
											children: ogData["og:title"] || ogData.title || "No title"
										}),
										/* @__PURE__ */ jsx("p", {
											className: "text-gray-300 text-sm line-clamp-3 leading-relaxed",
											children: ogData["og:description"] || ogData.description || "No description"
										}),
										/* @__PURE__ */ jsxs("div", {
											className: "flex items-center gap-2 text-xs text-gray-400 pt-1",
											children: [/* @__PURE__ */ jsx("div", { className: "w-1 h-1 bg-gray-500 rounded-full" }), /* @__PURE__ */ jsx("span", {
												className: "truncate",
												children: ogData["og:url"] || ogData.url || window.location.href
											})]
										})
									]
								})
							]
						})]
					}),
					/* @__PURE__ */ jsxs("div", {
						className: "space-y-4",
						children: [/* @__PURE__ */ jsxs("div", {
							className: "flex items-center gap-3",
							children: [
								/* @__PURE__ */ jsx("div", { className: "w-1 h-6 bg-blue-400 rounded-full" }),
								/* @__PURE__ */ jsx("h2", {
									className: "text-xl font-display font-semibold text-white",
									children: "Open Graph Properties"
								}),
								Object.entries(ogData).length > 0 && /* @__PURE__ */ jsxs("span", {
									className: "px-2 py-1 text-xs font-medium bg-blue-400/10 text-blue-400 rounded-full",
									children: [Object.entries(ogData).length, " properties"]
								})
							]
						}), Object.entries(ogData).length === 0 ? /* @__PURE__ */ jsxs("div", {
							className: "bg-gray-800/30 rounded-xl p-8 border border-gray-700/30 text-center",
							children: [
								/* @__PURE__ */ jsx("div", {
									className: "w-12 h-12 bg-orange-400/10 rounded-full flex items-center justify-center mx-auto mb-3",
									children: /* @__PURE__ */ jsx(Icon, {
										name: "icon-close",
										size: 20,
										className: "text-orange-400"
									})
								}),
								/* @__PURE__ */ jsx("div", {
									className: "text-gray-300 font-medium mb-1",
									children: "No Open Graph meta tags found"
								}),
								/* @__PURE__ */ jsx("div", {
									className: "text-sm text-gray-400",
									children: "Add og: meta tags to improve social media sharing"
								})
							]
						}) : /* @__PURE__ */ jsx("div", {
							className: "bg-gray-800/50 rounded-xl border border-gray-700/50",
							children: /* @__PURE__ */ jsx("div", {
								className: "p-4 space-y-3",
								children: Object.entries(ogData).map(([key, value]) => /* @__PURE__ */ jsxs("div", {
									className: "flex gap-4 py-2 border-b border-gray-700/30 last:border-b-0",
									children: [/* @__PURE__ */ jsx("div", {
										className: "font-mono text-sm text-blue-400 min-w-32 flex-shrink-0",
										children: key
									}), /* @__PURE__ */ jsx("div", {
										className: "text-sm text-gray-300 break-all",
										children: value
									})]
								}, key))
							})
						})]
					}),
					Object.entries(twitterData).length > 0 && /* @__PURE__ */ jsxs("div", {
						className: "space-y-4",
						children: [/* @__PURE__ */ jsxs("div", {
							className: "flex items-center gap-3",
							children: [
								/* @__PURE__ */ jsx("div", { className: "w-1 h-6 bg-green-400 rounded-full" }),
								/* @__PURE__ */ jsx("h2", {
									className: "text-xl font-display font-semibold text-white",
									children: "Twitter Card Properties"
								}),
								/* @__PURE__ */ jsxs("span", {
									className: "px-2 py-1 text-xs font-medium bg-green-400/10 text-green-400 rounded-full",
									children: [Object.entries(twitterData).length, " properties"]
								})
							]
						}), /* @__PURE__ */ jsx("div", {
							className: "bg-gray-800/50 rounded-xl border border-gray-700/50",
							children: /* @__PURE__ */ jsx("div", {
								className: "p-4 space-y-3",
								children: Object.entries(twitterData).map(([key, value]) => /* @__PURE__ */ jsxs("div", {
									className: "flex gap-4 py-2 border-b border-gray-700/30 last:border-b-0",
									children: [/* @__PURE__ */ jsx("div", {
										className: "font-mono text-sm text-green-400 min-w-32 flex-shrink-0",
										children: key
									}), /* @__PURE__ */ jsx("div", {
										className: "text-sm text-gray-300 break-all",
										children: value
									})]
								}, key))
							})
						})]
					})
				]
			});
			case "router": return /* @__PURE__ */ jsx("div", {
				className: "h-full w-full p-4 text-white",
				style: { viewTransitionName: "tab-content" },
				children: /* @__PURE__ */ jsxs("div", {
					className: "p-4 border border-gray-600 rounded",
					children: [/* @__PURE__ */ jsx("h3", {
						className: "text-lg font-semibold mb-2",
						children: "Router"
					}), /* @__PURE__ */ jsx("p", {
						className: "text-gray-300",
						children: "Router configuration and debugging tools will be available here."
					})]
				})
			});
			case "feature-flags": return /* @__PURE__ */ jsx("div", {
				className: "h-full w-full p-4 text-white",
				style: { viewTransitionName: "tab-content" },
				children: /* @__PURE__ */ jsxs("div", {
					className: "p-4 border border-gray-600 rounded",
					children: [/* @__PURE__ */ jsx("h3", {
						className: "text-lg font-semibold mb-2",
						children: "Feature Flags"
					}), /* @__PURE__ */ jsx("p", {
						className: "text-gray-300",
						children: "Feature flag management and testing tools will be available here."
					})]
				})
			});
			default: return /* @__PURE__ */ jsx("div", {
				className: "h-full w-full p-4 text-white flex items-center justify-center",
				style: { viewTransitionName: "tab-content" },
				children: /* @__PURE__ */ jsx("div", {
					className: "text-gray-400",
					children: "Select a tab to view content"
				})
			});
		}
	};
	return /* @__PURE__ */ jsxs("div", {
		className: "w-full font-text pb-18",
		children: [/* @__PURE__ */ jsx("div", {
			className: cn("h-full w-full p-4 text-white", selectedTab === "app" ? "block" : "hidden"),
			style: { viewTransitionName: selectedTab === "app" ? "tab-content" : void 0 },
			children: /* @__PURE__ */ jsx(ReactContentRenderer, {})
		}), selectedTab !== "app" && renderTabContent()]
	});
};
const MainView = () => {
	const [selectedTab, setSelectedTab] = useState$1(TABS[0].id);
	const showTabs = TABS.length > 1;
	return /* @__PURE__ */ jsxs("div", {
		className: "flex flex-col h-full w-full",
		children: [/* @__PURE__ */ jsx(MainViewHeader, {}), /* @__PURE__ */ jsx(ResizablePanel, {
			showLeftPanel: showTabs,
			leftPanel: /* @__PURE__ */ jsx(TabSidebar, {
				selectedTab,
				onSelectTab: setSelectedTab
			}),
			rightPanel: /* @__PURE__ */ jsx(TabContent, { selectedTab })
		})]
	});
};
const MainViewWrapper = /* @__PURE__ */ D((_$1, ref) => {
	return /* @__PURE__ */ jsx("div", {
		ref,
		className: "h-full w-full bg-black",
		children: /* @__PURE__ */ jsx(MainView, {})
	});
});
function CONSTANT_UPDATE() {
	return false;
}
function constant(Component$2) {
	function Memoed(props) {
		this.shouldComponentUpdate = CONSTANT_UPDATE;
		return createElement(Component$2, props);
	}
	Memoed.displayName = `Memo(${Component$2.displayName || Component$2.name})`;
	Memoed.prototype.isReactComponent = true;
	Memoed._forwarded = true;
	return Memoed;
}
const FpsMeterInner = ({ fps: fps$1 }) => {
	const getColor = (fps$2) => {
		if (fps$2 < 30) return "#EF4444";
		if (fps$2 < 50) return "#F59E0B";
		return "rgb(214,132,245)";
	};
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex items-center gap-x-1 px-2 w-full", "h-6", "rounded-md", "font-mono leading-none", "bg-[#141414]", "ring-1 ring-white/[0.08]"),
		children: [/* @__PURE__ */ jsx("div", {
			style: { color: getColor(fps$1) },
			className: "text-sm font-semibold tracking-wide transition-colors ease-in-out w-full flex justify-center items-center",
			children: fps$1
		}), /* @__PURE__ */ jsx("span", {
			className: "text-white/30 text-[11px] font-medium tracking-wide ml-auto min-w-fit",
			children: "FPS"
		})]
	});
};
const FPSMeter = () => {
	const [fps$1, setFps] = useState$1(null);
	useEffect$1(() => {
		const intervalId = setInterval(() => {
			setFps(getFPS());
		}, 200);
		return () => clearInterval(intervalId);
	}, []);
	return /* @__PURE__ */ jsx("div", {
		className: cn("flex items-center justify-end gap-x-2 px-1 ml-1 w-[72px]", "whitespace-nowrap text-sm text-white"),
		children: fps$1 === null ? /* @__PURE__ */ jsx(Fragment$1, { children: "️" }) : /* @__PURE__ */ jsx(FpsMeterInner, { fps: fps$1 })
	});
};
const Toolbar = /* @__PURE__ */ constant(() => {
	const inspectState = Store.inspectState;
	const isInspectActive = inspectState.value.kind === "inspecting";
	const isInspectFocused = inspectState.value.kind === "focused";
	const onToggleInspect = useCallback$1(() => {
		const currentState = Store.inspectState.value;
		switch (currentState.kind) {
			case "inspecting": {
				signalWidgetViews.value = { view: "none" };
				Store.inspectState.value = { kind: "inspect-off" };
				return;
			}
			case "focused": {
				signalWidgetViews.value = { view: "inspector" };
				Store.inspectState.value = {
					kind: "inspecting",
					hoveredDomElement: null
				};
				return;
			}
			case "inspect-off": {
				signalWidgetViews.value = { view: "none" };
				Store.inspectState.value = {
					kind: "inspecting",
					hoveredDomElement: null
				};
				return;
			}
			case "uninitialized": return;
		}
	}, []);
	useSignalEffect(() => {
		const state = Store.inspectState.value;
		if (state.kind === "uninitialized") Store.inspectState.value = { kind: "inspect-off" };
	});
	let inspectIcon = null;
	let inspectColor = "#999";
	if (isInspectActive) {
		inspectIcon = /* @__PURE__ */ jsx(Icon, { name: "icon-inspect" });
		inspectColor = "#8e61e3";
	} else if (isInspectFocused) {
		inspectIcon = /* @__PURE__ */ jsx(Icon, { name: "icon-focus" });
		inspectColor = "#8e61e3";
	} else {
		inspectIcon = /* @__PURE__ */ jsx(Icon, { name: "icon-inspect" });
		inspectColor = "#999";
	}
	return /* @__PURE__ */ jsxs("div", {
		className: "flex max-h-9 min-h-9 flex-1 items-stretch overflow-hidden",
		children: [
			/* @__PURE__ */ jsx("div", {
				className: "h-full flex items-center min-w-fit w-2",
				children: /* @__PURE__ */ jsx("span", {})
			}),
			/* @__PURE__ */ jsx("button", {
				onClick: () => {
					if (Store.inspectState.value.kind !== "inspect-off") Store.inspectState.value = { kind: "inspect-off" };
					switch (signalWidgetViews.value.view) {
						case "none": {
							signalWidgetViews.value = { view: "notifications" };
							return;
						}
					}
				},
				className: "flex items-center min-w-fit w-6 h-4 mt-2.5",
				"data-testid": "open-devtool",
				children: /* @__PURE__ */ jsx(Logo, { className: "text-sm me-0 w-4 h-4 text-brand-dark flex origin-center transition-all ease-in-out" })
			}),
			ReactDevtoolInternals.options.value.showFPS && /* @__PURE__ */ jsx(FPSMeter, {})
		]
	});
});
const isInspecting = /* @__PURE__ */ computed(() => Store.inspectState.value.kind === "inspecting");
const headerClassName = /* @__PURE__ */ computed(() => cn("relative", "flex-1", "flex flex-col", "rounded-t-lg", "overflow-hidden", "opacity-100", "transition-[opacity]", isInspecting.value && "opacity-0 duration-0 delay-0"));
const isNotificationsViewOpen = /* @__PURE__ */ computed(() => signalWidgetViews.value.view === "notifications");
const contentClassName = /* @__PURE__ */ computed(() => {
	return cn("flex flex-1 flex-col", "overflow-hidden z-10", "rounded-lg", "bg-wash-dark", "opacity-100", "transition-[border-radius]", "peer-hover/left:rounded-l-none", "peer-hover/right:rounded-r-none", "peer-hover/top:rounded-t-none", "peer-hover/bottom:rounded-b-none");
});
const Content = () => {
	return /* @__PURE__ */ jsxs("div", {
		className: contentClassName,
		children: [/* @__PURE__ */ jsxs("div", {
			className: headerClassName,
			children: [/* @__PURE__ */ jsx(Header, {}), /* @__PURE__ */ jsx("div", {
				className: cn("relative", "flex-1 flex", "text-white", "bg-wash-dark", "transition-opacity delay-150", "overflow-hidden", "border-b border-[#222]"),
				children: /* @__PURE__ */ jsx(ContentView, {
					isOpen: isNotificationsViewOpen,
					children: /* @__PURE__ */ jsx(MainViewWrapper, {})
				})
			})]
		}), /* @__PURE__ */ jsx(Toolbar, {})]
	});
};
const ContentView = ({ isOpen, children }) => {
	return /* @__PURE__ */ jsx("div", {
		className: cn("flex-1", "opacity-0", "overflow-y-auto overflow-x-hidden", "transition-opacity delay-0", "pointer-events-none", isOpen.value && "opacity-100 delay-150 pointer-events-auto"),
		children: /* @__PURE__ */ jsx("div", {
			className: "absolute inset-0 flex",
			children
		})
	});
};
const lerp = (start$1, end, t$1) => {
	return start$1 + (end - start$1) * t$1;
};
const ANIMATION_CONFIG = {
	frameInterval: 1e3 / 60,
	speeds: {
		fast: .51,
		slow: .1,
		off: 0
	}
};
const OVERLAY_DPR = IS_CLIENT ? /* @__PURE__ */ (() => window.devicePixelRatio)() || 1 : 1;
const ScanOverlay = () => {
	const refCanvas = useRef$1(null);
	const refEventCatcher = useRef$1(null);
	const refCurrentRect = useRef$1(null);
	const refCurrentLockIconRect = useRef$1(null);
	const refLastHoveredElement = useRef$1(null);
	const refRafId = useRef$1(0);
	const refTimeout = useRef$1();
	const refCleanupMap = useRef$1(/* @__PURE__ */ new Map());
	const refIsFadingOut = useRef$1(false);
	const refLastFrameTime = useRef$1(0);
	const drawLockIcon = (ctx, x$2, y$1, size) => {
		ctx.save();
		ctx.strokeStyle = "white";
		ctx.fillStyle = "white";
		ctx.lineWidth = 1.5;
		const shackleWidth = size * .6;
		const shackleHeight = size * .5;
		const shackleX = x$2 + (size - shackleWidth) / 2;
		const shackleY = y$1;
		ctx.beginPath();
		ctx.arc(shackleX + shackleWidth / 2, shackleY + shackleHeight / 2, shackleWidth / 2, Math.PI, 0, false);
		ctx.stroke();
		const bodyWidth = size * .8;
		const bodyHeight = size * .5;
		const bodyX = x$2 + (size - bodyWidth) / 2;
		const bodyY = y$1 + shackleHeight / 2;
		ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
		ctx.restore();
	};
	const drawStatsPill = (ctx, rect, kind, fiber) => {
		if (!fiber) return;
		const pillHeight = 24;
		const pillPadding = 8;
		const componentName = (fiber?.type && getDisplayName(fiber.type)) ?? "Unknown";
		const text = componentName;
		ctx.save();
		ctx.font = "12px system-ui, -apple-system, sans-serif";
		const textMetrics = ctx.measureText(text);
		const textWidth = textMetrics.width;
		const lockIconSize = kind === "locked" ? 14 : 0;
		const lockIconPadding = kind === "locked" ? 6 : 0;
		const pillWidth = textWidth + pillPadding * 2 + lockIconSize + lockIconPadding;
		const pillX = rect.left;
		const pillY = rect.top - pillHeight - 4;
		ctx.fillStyle = "rgb(37, 37, 38, .75)";
		ctx.beginPath();
		ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 3);
		ctx.fill();
		if (kind === "locked") {
			const lockX = pillX + pillPadding;
			const lockY = pillY + (pillHeight - lockIconSize) / 2 + 2;
			drawLockIcon(ctx, lockX, lockY, lockIconSize);
			refCurrentLockIconRect.current = {
				x: lockX,
				y: lockY,
				width: lockIconSize,
				height: lockIconSize
			};
		} else refCurrentLockIconRect.current = null;
		ctx.fillStyle = "white";
		ctx.textBaseline = "middle";
		const textX = pillX + pillPadding + (kind === "locked" ? lockIconSize + lockIconPadding : 0);
		ctx.fillText(text, textX, pillY + pillHeight / 2);
		ctx.restore();
	};
	const drawRect = (canvas, ctx, kind, fiber) => {
		if (!refCurrentRect.current) return;
		const rect = refCurrentRect.current;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.strokeStyle = "rgba(142, 97, 227, 0.5)";
		ctx.fillStyle = "rgba(173, 97, 230, 0.10)";
		if (kind === "locked") ctx.setLineDash([]);
		else ctx.setLineDash([4]);
		ctx.lineWidth = 1;
		ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
		ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
		drawStatsPill(ctx, rect, kind, fiber);
	};
	const animate = (canvas, ctx, targetRect, kind, parentCompositeFiber, onComplete) => {
		const speed = ReactDevtoolInternals.options.value.animationSpeed;
		const t$1 = ANIMATION_CONFIG.speeds[speed] ?? ANIMATION_CONFIG.speeds.off;
		const animationFrame$1 = (timestamp) => {
			if (timestamp - refLastFrameTime.current < ANIMATION_CONFIG.frameInterval) {
				refRafId.current = requestAnimationFrame(animationFrame$1);
				return;
			}
			refLastFrameTime.current = timestamp;
			if (!refCurrentRect.current) {
				cancelAnimationFrame(refRafId.current);
				return;
			}
			refCurrentRect.current = {
				left: lerp(refCurrentRect.current.left, targetRect.left, t$1),
				top: lerp(refCurrentRect.current.top, targetRect.top, t$1),
				width: lerp(refCurrentRect.current.width, targetRect.width, t$1),
				height: lerp(refCurrentRect.current.height, targetRect.height, t$1)
			};
			drawRect(canvas, ctx, kind, parentCompositeFiber);
			const stillMoving = Math.abs(refCurrentRect.current.left - targetRect.left) > .1 || Math.abs(refCurrentRect.current.top - targetRect.top) > .1 || Math.abs(refCurrentRect.current.width - targetRect.width) > .1 || Math.abs(refCurrentRect.current.height - targetRect.height) > .1;
			if (stillMoving) refRafId.current = requestAnimationFrame(animationFrame$1);
			else {
				refCurrentRect.current = targetRect;
				drawRect(canvas, ctx, kind, parentCompositeFiber);
				cancelAnimationFrame(refRafId.current);
				ctx.restore();
				onComplete?.();
			}
		};
		cancelAnimationFrame(refRafId.current);
		clearTimeout(refTimeout.current);
		refRafId.current = requestAnimationFrame(animationFrame$1);
		refTimeout.current = setTimeout(() => {
			cancelAnimationFrame(refRafId.current);
			refCurrentRect.current = targetRect;
			drawRect(canvas, ctx, kind, parentCompositeFiber);
			ctx.restore();
			onComplete?.();
		}, 1e3);
	};
	const setupOverlayAnimation = (canvas, ctx, targetRect, kind, parentCompositeFiber) => {
		ctx.save();
		if (!refCurrentRect.current) {
			refCurrentRect.current = targetRect;
			drawRect(canvas, ctx, kind, parentCompositeFiber);
			ctx.restore();
			return;
		}
		animate(canvas, ctx, targetRect, kind, parentCompositeFiber);
	};
	const drawHoverOverlay = async (overlayElement, canvas, ctx, kind) => {
		if (!overlayElement || !canvas || !ctx) return;
		const { parentCompositeFiber } = getCompositeComponentFromElement(overlayElement);
		const targetRect = await getAssociatedFiberRect(overlayElement);
		if (!parentCompositeFiber || !targetRect) return;
		setupOverlayAnimation(canvas, ctx, targetRect, kind, parentCompositeFiber);
	};
	const unsubscribeAll = () => {
		for (const cleanup$1 of refCleanupMap.current.values()) cleanup$1?.();
	};
	const cleanupCanvas = (canvas) => {
		const ctx = canvas.getContext("2d");
		if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
		refCurrentRect.current = null;
		refCurrentLockIconRect.current = null;
		refLastHoveredElement.current = null;
		canvas.classList.remove("fade-in");
		refIsFadingOut.current = false;
	};
	const startFadeOut = (onComplete) => {
		if (!refCanvas.current || refIsFadingOut.current) return;
		const handleTransitionEnd = (e$1) => {
			if (!refCanvas.current || e$1.propertyName !== "opacity" || !refIsFadingOut.current) return;
			refCanvas.current.removeEventListener("transitionend", handleTransitionEnd);
			cleanupCanvas(refCanvas.current);
			onComplete?.();
		};
		const existingListener = refCleanupMap.current.get("fade-out");
		if (existingListener) {
			existingListener();
			refCleanupMap.current.delete("fade-out");
		}
		refCanvas.current.addEventListener("transitionend", handleTransitionEnd);
		refCleanupMap.current.set("fade-out", () => {
			refCanvas.current?.removeEventListener("transitionend", handleTransitionEnd);
		});
		refIsFadingOut.current = true;
		refCanvas.current.classList.remove("fade-in");
		requestAnimationFrame(() => {
			refCanvas.current?.classList.add("fade-out");
		});
	};
	const startFadeIn = () => {
		if (!refCanvas.current) return;
		refIsFadingOut.current = false;
		refCanvas.current.classList.remove("fade-out");
		requestAnimationFrame(() => {
			refCanvas.current?.classList.add("fade-in");
		});
	};
	const handleHoverableElement = (componentElement) => {
		if (componentElement === refLastHoveredElement.current) return;
		refLastHoveredElement.current = componentElement;
		if (nonVisualTags.has(componentElement.tagName)) startFadeOut();
		else startFadeIn();
		Store.inspectState.value = {
			kind: "inspecting",
			hoveredDomElement: componentElement
		};
	};
	const handleNonHoverableArea = () => {
		if (!refCurrentRect.current || !refCanvas.current || refIsFadingOut.current) return;
		startFadeOut();
	};
	const handlePointerMove = throttle((e$1) => {
		const state = Store.inspectState.peek();
		if (state.kind !== "inspecting" || !refEventCatcher.current) return;
		refEventCatcher.current.style.pointerEvents = "none";
		const element = document.elementFromPoint(e$1?.clientX ?? 0, e$1?.clientY ?? 0);
		refEventCatcher.current.style.removeProperty("pointer-events");
		clearTimeout(refTimeout.current);
		if (element && element !== refCanvas.current) {
			const { parentCompositeFiber } = getCompositeComponentFromElement(element);
			if (parentCompositeFiber) {
				const componentElement = findComponentDOMNode(parentCompositeFiber);
				if (componentElement) {
					handleHoverableElement(componentElement);
					return;
				}
			}
		}
		handleNonHoverableArea();
	}, 32);
	const isClickInLockIcon = (e$1, canvas) => {
		const currentRect = refCurrentLockIconRect.current;
		if (!currentRect) return false;
		const rect = canvas.getBoundingClientRect();
		const scaleX = canvas.width / rect.width;
		const scaleY = canvas.height / rect.height;
		const x$2 = (e$1.clientX - rect.left) * scaleX;
		const y$1 = (e$1.clientY - rect.top) * scaleY;
		const adjustedX = x$2 / OVERLAY_DPR;
		const adjustedY = y$1 / OVERLAY_DPR;
		return adjustedX >= currentRect.x && adjustedX <= currentRect.x + currentRect.width && adjustedY >= currentRect.y && adjustedY <= currentRect.y + currentRect.height;
	};
	const handleLockIconClick = (state) => {
		if (state.kind === "focused") Store.inspectState.value = {
			kind: "inspecting",
			hoveredDomElement: state.focusedDomElement
		};
	};
	const handleElementClick = (e$1) => {
		const clickableElements = ["react-devtool-inspect-element", "react-devtool-power"];
		if (e$1.target instanceof HTMLElement && clickableElements.includes(e$1.target.id)) return;
		const tagName = refLastHoveredElement.current?.tagName;
		if (tagName && nonVisualTags.has(tagName)) return;
		e$1.preventDefault();
		e$1.stopPropagation();
		const element = refLastHoveredElement.current ?? document.elementFromPoint(e$1.clientX, e$1.clientY);
		if (!element) return;
		const clickedEl = e$1.composedPath().at(0);
		if (clickedEl instanceof HTMLElement && clickableElements.includes(clickedEl.id)) {
			const syntheticEvent = new MouseEvent(e$1.type, e$1);
			syntheticEvent.__reactDevtoolSyntheticEvent = true;
			clickedEl.dispatchEvent(syntheticEvent);
			return;
		}
		const { parentCompositeFiber } = getCompositeComponentFromElement(element);
		if (!parentCompositeFiber) return;
		const componentElement = findComponentDOMNode(parentCompositeFiber);
		if (!componentElement) {
			refLastHoveredElement.current = null;
			Store.inspectState.value = { kind: "inspect-off" };
			return;
		}
		Store.inspectState.value = {
			kind: "focused",
			focusedDomElement: componentElement,
			fiber: parentCompositeFiber
		};
	};
	const handleClick = (e$1) => {
		if (e$1.__reactDevtoolSyntheticEvent) return;
		const state = Store.inspectState.peek();
		const canvas = refCanvas.current;
		if (!canvas || !refEventCatcher.current) return;
		if (isClickInLockIcon(e$1, canvas)) {
			e$1.preventDefault();
			e$1.stopPropagation();
			handleLockIconClick(state);
			return;
		}
		if (state.kind === "inspecting") handleElementClick(e$1);
	};
	const handleKeyDown = (e$1) => {
		if (e$1.key !== "Escape") return;
		const state = Store.inspectState.peek();
		const canvas = refCanvas.current;
		if (!canvas) return;
		if (document.activeElement?.id === "react-devtool-root") return;
		signalWidgetViews.value = { view: "none" };
		if (state.kind === "focused" || state.kind === "inspecting") {
			e$1.preventDefault();
			e$1.stopPropagation();
			switch (state.kind) {
				case "focused": {
					startFadeIn();
					refCurrentRect.current = null;
					refLastHoveredElement.current = state.focusedDomElement;
					Store.inspectState.value = {
						kind: "inspecting",
						hoveredDomElement: state.focusedDomElement
					};
					break;
				}
				case "inspecting": {
					startFadeOut(() => {
						signalIsSettingsOpen.value = false;
						Store.inspectState.value = { kind: "inspect-off" };
					});
					break;
				}
			}
		}
	};
	const handleStateChange = (state, canvas, ctx) => {
		refCleanupMap.current.get(state.kind)?.();
		if (refEventCatcher.current) {
			if (state.kind !== "inspecting") refEventCatcher.current.style.pointerEvents = "none";
		}
		if (refRafId.current) cancelAnimationFrame(refRafId.current);
		let unsubReport;
		switch (state.kind) {
			case "inspect-off":
				startFadeOut();
				return;
			case "inspecting":
				drawHoverOverlay(state.hoveredDomElement, canvas, ctx, "inspecting");
				break;
			case "focused":
				if (!state.focusedDomElement) return;
				if (refLastHoveredElement.current !== state.focusedDomElement) refLastHoveredElement.current = state.focusedDomElement;
				signalWidgetViews.value = { view: "inspector" };
				drawHoverOverlay(state.focusedDomElement, canvas, ctx, "locked");
				unsubReport = Store.lastReportTime.subscribe(() => {
					if (refRafId.current && refCurrentRect.current) {
						const { parentCompositeFiber } = getCompositeComponentFromElement(state.focusedDomElement);
						if (parentCompositeFiber) drawHoverOverlay(state.focusedDomElement, canvas, ctx, "locked");
					}
				});
				if (unsubReport) refCleanupMap.current.set(state.kind, unsubReport);
				break;
		}
	};
	const updateCanvasSize = (canvas, ctx) => {
		const rect = canvas.getBoundingClientRect();
		canvas.width = rect.width * OVERLAY_DPR;
		canvas.height = rect.height * OVERLAY_DPR;
		ctx.scale(OVERLAY_DPR, OVERLAY_DPR);
		ctx.save();
	};
	const handleResizeOrScroll = () => {
		const state = Store.inspectState.peek();
		const canvas = refCanvas.current;
		if (!canvas) return;
		const ctx = canvas?.getContext("2d");
		if (!ctx) return;
		cancelAnimationFrame(refRafId.current);
		clearTimeout(refTimeout.current);
		updateCanvasSize(canvas, ctx);
		refCurrentRect.current = null;
		if (state.kind === "focused" && state.focusedDomElement) drawHoverOverlay(state.focusedDomElement, canvas, ctx, "locked");
		else if (state.kind === "inspecting" && state.hoveredDomElement) drawHoverOverlay(state.hoveredDomElement, canvas, ctx, "inspecting");
	};
	const handlePointerDown = (e$1) => {
		const state = Store.inspectState.peek();
		const canvas = refCanvas.current;
		if (!canvas) return;
		if (state.kind === "inspecting" || isClickInLockIcon(e$1, canvas)) {
			e$1.preventDefault();
			e$1.stopPropagation();
			e$1.stopImmediatePropagation();
		}
	};
	useEffect$1(() => {
		const canvas = refCanvas.current;
		if (!canvas) return;
		const ctx = canvas?.getContext("2d");
		if (!ctx) return;
		updateCanvasSize(canvas, ctx);
		const unSubState = Store.inspectState.subscribe((state) => {
			handleStateChange(state, canvas, ctx);
		});
		window.addEventListener("scroll", handleResizeOrScroll, { passive: true });
		window.addEventListener("resize", handleResizeOrScroll, { passive: true });
		document.addEventListener("pointermove", handlePointerMove, {
			passive: true,
			capture: true
		});
		document.addEventListener("pointerdown", handlePointerDown, { capture: true });
		document.addEventListener("click", handleClick, { capture: true });
		document.addEventListener("keydown", handleKeyDown, { capture: true });
		return () => {
			unsubscribeAll();
			unSubState();
			window.removeEventListener("scroll", handleResizeOrScroll);
			window.removeEventListener("resize", handleResizeOrScroll);
			document.removeEventListener("pointermove", handlePointerMove, { capture: true });
			document.removeEventListener("click", handleClick, { capture: true });
			document.removeEventListener("pointerdown", handlePointerDown, { capture: true });
			document.removeEventListener("keydown", handleKeyDown, { capture: true });
			if (refRafId.current) cancelAnimationFrame(refRafId.current);
			clearTimeout(refTimeout.current);
		};
	}, []);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("div", {
		ref: refEventCatcher,
		className: cn("fixed top-0 left-0 w-screen h-screen", "z-[214748365]"),
		style: { pointerEvents: "none" }
	}), /* @__PURE__ */ jsx("canvas", {
		ref: refCanvas,
		dir: "ltr",
		className: cn("react-devtool-inspector-overlay", "fixed top-0 left-0 w-screen h-screen", "pointer-events-none", "z-[214748367]")
	})] });
};
var WindowDimensions = class {
	maxWidth;
	maxHeight;
	constructor(width, height) {
		this.width = width;
		this.height = height;
		this.maxWidth = width - SAFE_AREA * 2;
		this.maxHeight = height - SAFE_AREA * 2;
	}
	rightEdge(width) {
		return this.width - width - SAFE_AREA;
	}
	bottomEdge(height) {
		return this.height - height - SAFE_AREA;
	}
	isFullWidth(width) {
		return width >= this.maxWidth;
	}
	isFullHeight(height) {
		return height >= this.maxHeight;
	}
};
let cachedWindowDimensions;
const getWindowDimensions = () => {
	const currentWidth = window.innerWidth;
	const currentHeight = window.innerHeight;
	if (cachedWindowDimensions && cachedWindowDimensions.width === currentWidth && cachedWindowDimensions.height === currentHeight) return cachedWindowDimensions;
	cachedWindowDimensions = new WindowDimensions(currentWidth, currentHeight);
	return cachedWindowDimensions;
};
const getOppositeCorner = (position, currentCorner, isFullScreen, isFullWidth, isFullHeight) => {
	if (isFullScreen) {
		if (position === "top-left") return "bottom-right";
		if (position === "top-right") return "bottom-left";
		if (position === "bottom-left") return "top-right";
		if (position === "bottom-right") return "top-left";
		const [vertical, horizontal] = currentCorner.split("-");
		if (position === "left") return `${vertical}-right`;
		if (position === "right") return `${vertical}-left`;
		if (position === "top") return `bottom-${horizontal}`;
		if (position === "bottom") return `top-${horizontal}`;
	}
	if (isFullWidth) {
		if (position === "left") return `${currentCorner.split("-")[0]}-right`;
		if (position === "right") return `${currentCorner.split("-")[0]}-left`;
	}
	if (isFullHeight) {
		if (position === "top") return `bottom-${currentCorner.split("-")[1]}`;
		if (position === "bottom") return `top-${currentCorner.split("-")[1]}`;
	}
	return currentCorner;
};
const calculatePosition = (corner, width, height) => {
	const isRTL = getComputedStyle(document.body).direction === "rtl";
	const windowWidth = window.innerWidth;
	const windowHeight = window.innerHeight;
	const isMinimized = width === MIN_SIZE.width;
	const effectiveWidth = isMinimized ? width : Math.min(width, windowWidth - SAFE_AREA * 2);
	const effectiveHeight = isMinimized ? height : Math.min(height, windowHeight - SAFE_AREA * 2);
	let x$2;
	let y$1;
	const leftBound = SAFE_AREA;
	const rightBound = windowWidth - effectiveWidth - SAFE_AREA;
	const topBound = SAFE_AREA;
	const bottomBound = windowHeight - effectiveHeight - SAFE_AREA;
	switch (corner) {
		case "top-right":
			x$2 = isRTL ? -leftBound : rightBound;
			y$1 = topBound;
			break;
		case "bottom-right":
			x$2 = isRTL ? -leftBound : rightBound;
			y$1 = bottomBound;
			break;
		case "bottom-left":
			x$2 = isRTL ? -rightBound : leftBound;
			y$1 = bottomBound;
			break;
		case "top-left":
			x$2 = isRTL ? -rightBound : leftBound;
			y$1 = topBound;
			break;
		default:
			x$2 = leftBound;
			y$1 = topBound;
			break;
	}
	if (isMinimized) {
		if (isRTL) x$2 = Math.min(-leftBound, Math.max(x$2, -rightBound));
		else x$2 = Math.max(leftBound, Math.min(x$2, rightBound));
		y$1 = Math.max(topBound, Math.min(y$1, bottomBound));
	}
	return {
		x: x$2,
		y: y$1
	};
};
const positionMatchesCorner = (position, corner) => {
	const [vertical, horizontal] = corner.split("-");
	return position !== vertical && position !== horizontal;
};
const getHandleVisibility = (position, corner, isFullWidth, isFullHeight) => {
	if (isFullWidth && isFullHeight) return true;
	if (!isFullWidth && !isFullHeight) return positionMatchesCorner(position, corner);
	if (isFullWidth) return position !== corner.split("-")[0];
	if (isFullHeight) return position !== corner.split("-")[1];
	return false;
};
const calculateBoundedSize = (currentSize, delta, isWidth) => {
	const min = isWidth ? MIN_SIZE.width : MIN_SIZE.initialHeight;
	const max = isWidth ? getWindowDimensions().maxWidth : getWindowDimensions().maxHeight;
	const newSize = currentSize + delta;
	return Math.min(Math.max(min, newSize), max);
};
const calculateNewSizeAndPosition = (position, initialSize, initialPosition, deltaX, deltaY) => {
	const isRTL = getComputedStyle(document.body).direction === "rtl";
	const maxWidth = window.innerWidth - SAFE_AREA * 2;
	const maxHeight = window.innerHeight - SAFE_AREA * 2;
	let newWidth = initialSize.width;
	let newHeight = initialSize.height;
	let newX = initialPosition.x;
	let newY = initialPosition.y;
	if (isRTL && position.includes("right")) {
		const availableWidth = -initialPosition.x + initialSize.width - SAFE_AREA;
		const proposedWidth = Math.min(initialSize.width + deltaX, availableWidth);
		newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
		newX = initialPosition.x + (newWidth - initialSize.width);
	}
	if (isRTL && position.includes("left")) {
		const availableWidth = window.innerWidth - initialPosition.x - SAFE_AREA;
		const proposedWidth = Math.min(initialSize.width - deltaX, availableWidth);
		newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
	}
	if (!isRTL && position.includes("right")) {
		const availableWidth = window.innerWidth - initialPosition.x - SAFE_AREA;
		const proposedWidth = Math.min(initialSize.width + deltaX, availableWidth);
		newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
	}
	if (!isRTL && position.includes("left")) {
		const availableWidth = initialPosition.x + initialSize.width - SAFE_AREA;
		const proposedWidth = Math.min(initialSize.width - deltaX, availableWidth);
		newWidth = Math.min(maxWidth, Math.max(MIN_SIZE.width, proposedWidth));
		newX = initialPosition.x - (newWidth - initialSize.width);
	}
	if (position.includes("bottom")) {
		const availableHeight = window.innerHeight - initialPosition.y - SAFE_AREA;
		const proposedHeight = Math.min(initialSize.height + deltaY, availableHeight);
		newHeight = Math.min(maxHeight, Math.max(MIN_SIZE.initialHeight, proposedHeight));
	}
	if (position.includes("top")) {
		const availableHeight = initialPosition.y + initialSize.height - SAFE_AREA;
		const proposedHeight = Math.min(initialSize.height - deltaY, availableHeight);
		newHeight = Math.min(maxHeight, Math.max(MIN_SIZE.initialHeight, proposedHeight));
		newY = initialPosition.y - (newHeight - initialSize.height);
	}
	const leftBound = SAFE_AREA;
	const rightBound = window.innerWidth - SAFE_AREA - newWidth;
	const topBound = SAFE_AREA;
	const bottomBound = window.innerHeight - SAFE_AREA - newHeight;
	if (isRTL) newX = Math.min(-leftBound, Math.max(newX, -rightBound));
	else newX = Math.max(leftBound, Math.min(newX, rightBound));
	newY = Math.max(topBound, Math.min(newY, bottomBound));
	return {
		newSize: {
			width: newWidth,
			height: newHeight
		},
		newPosition: {
			x: newX,
			y: newY
		}
	};
};
const getClosestCorner = (position) => {
	const windowDims = getWindowDimensions();
	const distances = {
		"top-left": Math.hypot(position.x, position.y),
		"top-right": Math.hypot(windowDims.maxWidth - position.x, position.y),
		"bottom-left": Math.hypot(position.x, windowDims.maxHeight - position.y),
		"bottom-right": Math.hypot(windowDims.maxWidth - position.x, windowDims.maxHeight - position.y)
	};
	let closest = "top-left";
	for (const key in distances) if (distances[key] < distances[closest]) closest = key;
	return closest;
};
const getBestCorner = (mouseX, mouseY, initialMouseX, initialMouseY, threshold = 100) => {
	const deltaX = initialMouseX !== void 0 ? mouseX - initialMouseX : 0;
	const deltaY = initialMouseY !== void 0 ? mouseY - initialMouseY : 0;
	const windowCenterX = window.innerWidth / 2;
	const windowCenterY = window.innerHeight / 2;
	const movingRight = deltaX > threshold;
	const movingLeft = deltaX < -threshold;
	const movingDown = deltaY > threshold;
	const movingUp = deltaY < -threshold;
	if (movingRight || movingLeft) {
		const isBottom = mouseY > windowCenterY;
		return movingRight ? isBottom ? "bottom-right" : "top-right" : isBottom ? "bottom-left" : "top-left";
	}
	if (movingDown || movingUp) {
		const isRight = mouseX > windowCenterX;
		return movingDown ? isRight ? "bottom-right" : "bottom-left" : isRight ? "top-right" : "top-left";
	}
	return mouseX > windowCenterX ? mouseY > windowCenterY ? "bottom-right" : "top-right" : mouseY > windowCenterY ? "bottom-left" : "top-left";
};
const ResizeHandle = ({ position }) => {
	const refContainer = useRef$1(null);
	const prevWidth = useRef$1(null);
	const prevHeight = useRef$1(null);
	const prevCorner = useRef$1(null);
	useEffect$1(() => {
		const container = refContainer.current;
		if (!container) return;
		const updateVisibility = () => {
			container.classList.remove("pointer-events-none");
			const isFocused = Store.inspectState.value.kind === "focused";
			const shouldShow = signalWidgetViews.value.view !== "none";
			const isVisible = (isFocused || shouldShow) && getHandleVisibility(position, signalWidget.value.corner, signalWidget.value.dimensions.isFullWidth, signalWidget.value.dimensions.isFullHeight);
			if (isVisible) container.classList.remove("hidden", "pointer-events-none", "opacity-0");
			else container.classList.add("hidden", "pointer-events-none", "opacity-0");
		};
		const unsubscribeSignalWidget = signalWidget.subscribe((state) => {
			if (prevWidth.current !== null && prevHeight.current !== null && prevCorner.current !== null && state.dimensions.width === prevWidth.current && state.dimensions.height === prevHeight.current && state.corner === prevCorner.current) return;
			updateVisibility();
			prevWidth.current = state.dimensions.width;
			prevHeight.current = state.dimensions.height;
			prevCorner.current = state.corner;
		});
		const unsubscribeInspectState = Store.inspectState.subscribe(() => {
			updateVisibility();
		});
		return () => {
			unsubscribeSignalWidget();
			unsubscribeInspectState();
			prevWidth.current = null;
			prevHeight.current = null;
			prevCorner.current = null;
		};
	}, []);
	const handleResize = useCallback$1((e$1) => {
		e$1.preventDefault();
		e$1.stopPropagation();
		const widget = signalRefWidget.value;
		if (!widget) return;
		const containerStyle = widget.style;
		const { dimensions } = signalWidget.value;
		const initialX = e$1.clientX;
		const initialY = e$1.clientY;
		const initialWidth = dimensions.width;
		const initialHeight = dimensions.height;
		const initialPosition = dimensions.position;
		signalWidget.value = {
			...signalWidget.value,
			dimensions: {
				...dimensions,
				isFullWidth: false,
				isFullHeight: false,
				width: initialWidth,
				height: initialHeight,
				position: initialPosition
			}
		};
		let rafId = null;
		const handlePointerMove = (e$2) => {
			if (rafId) return;
			containerStyle.transition = "none";
			rafId = requestAnimationFrame(() => {
				const { newSize, newPosition } = calculateNewSizeAndPosition(position, {
					width: initialWidth,
					height: initialHeight
				}, initialPosition, e$2.clientX - initialX, e$2.clientY - initialY);
				containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
				containerStyle.width = `${newSize.width}px`;
				containerStyle.height = `${newSize.height}px`;
				const maxTreeWidth = Math.floor(newSize.width - MIN_CONTAINER_WIDTH / 2);
				const currentTreeWidth = signalWidget.value.componentsTree.width;
				const newTreeWidth = Math.min(maxTreeWidth, Math.max(MIN_CONTAINER_WIDTH, currentTreeWidth));
				signalWidget.value = {
					...signalWidget.value,
					dimensions: {
						isFullWidth: false,
						isFullHeight: false,
						width: newSize.width,
						height: newSize.height,
						position: newPosition
					},
					componentsTree: {
						...signalWidget.value.componentsTree,
						width: newTreeWidth
					}
				};
				rafId = null;
			});
		};
		const handlePointerUp = () => {
			if (rafId) {
				cancelAnimationFrame(rafId);
				rafId = null;
			}
			document.removeEventListener("pointermove", handlePointerMove);
			document.removeEventListener("pointerup", handlePointerUp);
			const { dimensions: dimensions$1, corner } = signalWidget.value;
			const windowDims = getWindowDimensions();
			const isCurrentFullWidth = windowDims.isFullWidth(dimensions$1.width);
			const isCurrentFullHeight = windowDims.isFullHeight(dimensions$1.height);
			const isFullScreen = isCurrentFullWidth && isCurrentFullHeight;
			let newCorner = corner;
			if (isFullScreen || isCurrentFullWidth || isCurrentFullHeight) newCorner = getClosestCorner(dimensions$1.position);
			const newPosition = calculatePosition(newCorner, dimensions$1.width, dimensions$1.height);
			const onTransitionEnd = () => {
				widget.removeEventListener("transitionend", onTransitionEnd);
			};
			widget.addEventListener("transitionend", onTransitionEnd);
			containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
			signalWidget.value = {
				...signalWidget.value,
				corner: newCorner,
				dimensions: {
					isFullWidth: isCurrentFullWidth,
					isFullHeight: isCurrentFullHeight,
					width: dimensions$1.width,
					height: dimensions$1.height,
					position: newPosition
				},
				lastDimensions: {
					isFullWidth: isCurrentFullWidth,
					isFullHeight: isCurrentFullHeight,
					width: dimensions$1.width,
					height: dimensions$1.height,
					position: newPosition
				}
			};
			saveLocalStorage(LOCALSTORAGE_KEY, {
				corner: newCorner,
				dimensions: signalWidget.value.dimensions,
				lastDimensions: signalWidget.value.lastDimensions,
				componentsTree: signalWidget.value.componentsTree
			});
		};
		document.addEventListener("pointermove", handlePointerMove, { passive: true });
		document.addEventListener("pointerup", handlePointerUp);
	}, []);
	const handleDoubleClick = useCallback$1((e$1) => {
		e$1.preventDefault();
		e$1.stopPropagation();
		const widget = signalRefWidget.value;
		if (!widget) return;
		const containerStyle = widget.style;
		const { dimensions, corner } = signalWidget.value;
		const windowDims = getWindowDimensions();
		const isCurrentFullWidth = windowDims.isFullWidth(dimensions.width);
		const isCurrentFullHeight = windowDims.isFullHeight(dimensions.height);
		const isFullScreen = isCurrentFullWidth && isCurrentFullHeight;
		const isPartiallyMaximized = (isCurrentFullWidth || isCurrentFullHeight) && !isFullScreen;
		let newWidth = dimensions.width;
		let newHeight = dimensions.height;
		const newCorner = getOppositeCorner(position, corner, isFullScreen, isCurrentFullWidth, isCurrentFullHeight);
		if (position === "left" || position === "right") {
			newWidth = isCurrentFullWidth ? dimensions.width : windowDims.maxWidth;
			if (isPartiallyMaximized) newWidth = isCurrentFullWidth ? MIN_SIZE.width : windowDims.maxWidth;
		} else {
			newHeight = isCurrentFullHeight ? dimensions.height : windowDims.maxHeight;
			if (isPartiallyMaximized) newHeight = isCurrentFullHeight ? MIN_SIZE.initialHeight : windowDims.maxHeight;
		}
		if (isFullScreen) if (position === "left" || position === "right") newWidth = MIN_SIZE.width;
		else newHeight = MIN_SIZE.initialHeight;
		const newPosition = calculatePosition(newCorner, newWidth, newHeight);
		const newDimensions = {
			isFullWidth: windowDims.isFullWidth(newWidth),
			isFullHeight: windowDims.isFullHeight(newHeight),
			width: newWidth,
			height: newHeight,
			position: newPosition
		};
		const maxTreeWidth = Math.floor(newWidth - MIN_SIZE.width / 2);
		const currentTreeWidth = signalWidget.value.componentsTree.width;
		const defaultWidth = Math.floor(newWidth * .3);
		const newTreeWidth = isCurrentFullWidth ? MIN_CONTAINER_WIDTH : (position === "left" || position === "right") && !isCurrentFullWidth ? Math.min(maxTreeWidth, Math.max(MIN_CONTAINER_WIDTH, defaultWidth)) : Math.min(maxTreeWidth, Math.max(MIN_CONTAINER_WIDTH, currentTreeWidth));
		requestAnimationFrame(() => {
			signalWidget.value = {
				corner: newCorner,
				dimensions: newDimensions,
				lastDimensions: dimensions,
				componentsTree: {
					...signalWidget.value.componentsTree,
					width: newTreeWidth
				}
			};
			containerStyle.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
			containerStyle.width = `${newWidth}px`;
			containerStyle.height = `${newHeight}px`;
			containerStyle.transform = `translate3d(${newPosition.x}px, ${newPosition.y}px, 0)`;
		});
		saveLocalStorage(LOCALSTORAGE_KEY, {
			corner: newCorner,
			dimensions: newDimensions,
			lastDimensions: dimensions,
			componentsTree: {
				...signalWidget.value.componentsTree,
				width: newTreeWidth
			}
		});
	}, []);
	return /* @__PURE__ */ jsx("div", {
		ref: refContainer,
		onPointerDown: handleResize,
		onDblClick: handleDoubleClick,
		className: cn("absolute z-50", "flex items-center justify-center", "group", "transition-colors select-none", "peer", {
			"resize-left peer/left": position === "left",
			"resize-right peer/right z-10": position === "right",
			"resize-top peer/top": position === "top",
			"resize-bottom peer/bottom": position === "bottom"
		}),
		children: /* @__PURE__ */ jsx("span", {
			className: "resize-line-wrapper",
			children: /* @__PURE__ */ jsx("span", {
				className: "resize-line",
				children: /* @__PURE__ */ jsx(Icon, {
					name: "icon-ellipsis",
					size: 18,
					className: cn("text-neutral-400", (position === "left" || position === "right") && "rotate-90")
				})
			})
		})
	});
};
const COLLAPSED_SIZE = {
	horizontal: {
		width: 20,
		height: 48
	},
	vertical: {
		width: 48,
		height: 20
	}
};
const Widget = () => {
	const refWidget = useRef$1(null);
	const refShouldOpen = useRef$1(false);
	const refInitialMinimizedWidth = useRef$1(0);
	const refInitialMinimizedHeight = useRef$1(0);
	const refExpandingFromCollapsed = useRef$1(false);
	const updateWidgetPosition = useCallback$1((shouldSave = true) => {
		if (!refWidget.current) return;
		const { corner } = signalWidget.value;
		let newWidth;
		let newHeight;
		if (signalWidgetCollapsed.value) {
			const orientation = signalWidgetCollapsed.value.orientation || "horizontal";
			const size = COLLAPSED_SIZE[orientation];
			newWidth = size.width;
			newHeight = size.height;
		} else if (refShouldOpen.current) {
			const lastDims = signalWidget.value.lastDimensions;
			newWidth = calculateBoundedSize(lastDims.width, 0, true);
			newHeight = calculateBoundedSize(lastDims.height, 0, false);
			if (refExpandingFromCollapsed.current) refExpandingFromCollapsed.current = false;
		} else {
			newWidth = refInitialMinimizedWidth.current;
			newHeight = refInitialMinimizedHeight.current;
		}
		const newPosition = calculatePosition(corner, newWidth, newHeight);
		let finalPosition = newPosition;
		if (signalWidgetCollapsed.value) {
			const { corner: collapsedCorner, orientation = "horizontal" } = signalWidgetCollapsed.value;
			const size = COLLAPSED_SIZE[orientation];
			switch (collapsedCorner) {
				case "top-left":
					finalPosition = orientation === "horizontal" ? {
						x: -1,
						y: SAFE_AREA
					} : {
						x: SAFE_AREA,
						y: -1
					};
					break;
				case "bottom-left":
					finalPosition = orientation === "horizontal" ? {
						x: -1,
						y: window.innerHeight - size.height - SAFE_AREA
					} : {
						x: SAFE_AREA,
						y: window.innerHeight - size.height + 1
					};
					break;
				case "top-right":
					finalPosition = orientation === "horizontal" ? {
						x: window.innerWidth - size.width + 1,
						y: SAFE_AREA
					} : {
						x: window.innerWidth - size.width - SAFE_AREA,
						y: -1
					};
					break;
				case "bottom-right":
				default:
					finalPosition = orientation === "horizontal" ? {
						x: window.innerWidth - size.width + 1,
						y: window.innerHeight - size.height - SAFE_AREA
					} : {
						x: window.innerWidth - size.width - SAFE_AREA,
						y: window.innerHeight - size.height + 1
					};
					break;
			}
		}
		const isTooSmall = newWidth < MIN_SIZE.width || newHeight < MIN_SIZE.initialHeight;
		const shouldPersist = shouldSave && !isTooSmall;
		const container = refWidget.current;
		const containerStyle = container.style;
		let rafId = null;
		const onTransitionEnd = () => {
			updateDimensions();
			container.removeEventListener("transitionend", onTransitionEnd);
			if (rafId) {
				cancelAnimationFrame(rafId);
				rafId = null;
			}
		};
		container.addEventListener("transitionend", onTransitionEnd);
		containerStyle.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
		rafId = requestAnimationFrame(() => {
			containerStyle.width = `${newWidth}px`;
			containerStyle.height = `${newHeight}px`;
			containerStyle.transform = `translate3d(${finalPosition.x}px, ${finalPosition.y}px, 0)`;
			rafId = null;
		});
		const newDimensions = {
			isFullWidth: newWidth >= window.innerWidth - SAFE_AREA * 2,
			isFullHeight: newHeight >= window.innerHeight - SAFE_AREA * 2,
			width: newWidth,
			height: newHeight,
			position: finalPosition
		};
		signalWidget.value = {
			corner,
			dimensions: newDimensions,
			lastDimensions: refShouldOpen ? signalWidget.value.lastDimensions : newWidth > refInitialMinimizedWidth.current ? newDimensions : signalWidget.value.lastDimensions,
			componentsTree: signalWidget.value.componentsTree
		};
		if (shouldPersist) saveLocalStorage(LOCALSTORAGE_KEY, {
			corner: signalWidget.value.corner,
			dimensions: signalWidget.value.dimensions,
			lastDimensions: signalWidget.value.lastDimensions,
			componentsTree: signalWidget.value.componentsTree
		});
		updateDimensions();
	}, []);
	const handleDrag = useCallback$1((e$1) => {
		e$1.preventDefault();
		if (!refWidget.current || e$1.target.closest("button") || e$1.target.closest("input") || e$1.target.closest("select")) return;
		const container = refWidget.current;
		const containerStyle = container.style;
		const { dimensions } = signalWidget.value;
		const initialMouseX = e$1.clientX;
		const initialMouseY = e$1.clientY;
		const initialX = dimensions.position.x;
		const initialY = dimensions.position.y;
		let currentX = initialX;
		let currentY = initialY;
		let rafId = null;
		let hasMoved = false;
		let lastMouseX = initialMouseX;
		let lastMouseY = initialMouseY;
		const handlePointerMove = (e$2) => {
			if (rafId) return;
			hasMoved = true;
			lastMouseX = e$2.clientX;
			lastMouseY = e$2.clientY;
			rafId = requestAnimationFrame(() => {
				const deltaX = lastMouseX - initialMouseX;
				const deltaY = lastMouseY - initialMouseY;
				currentX = Number(initialX) + deltaX;
				currentY = Number(initialY) + deltaY;
				containerStyle.transition = "none";
				containerStyle.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
				const widgetRight = currentX + dimensions.width;
				const widgetBottom = currentY + dimensions.height;
				const outsideLeft = Math.max(0, -currentX);
				const outsideRight = Math.max(0, widgetRight - window.innerWidth);
				const outsideTop = Math.max(0, -currentY);
				const outsideBottom = Math.max(0, widgetBottom - window.innerHeight);
				const horizontalOutside = Math.min(dimensions.width, outsideLeft + outsideRight);
				const verticalOutside = Math.min(dimensions.height, outsideTop + outsideBottom);
				const areaOutside = horizontalOutside * dimensions.height + verticalOutside * dimensions.width - horizontalOutside * verticalOutside;
				const totalArea = dimensions.width * dimensions.height;
				let shouldCollapse = areaOutside > totalArea * .35;
				if (!shouldCollapse && ReactDevtoolInternals.options.value.showFPS) {
					const fpsRight = currentX + dimensions.width;
					const fpsLeft = fpsRight - 100;
					const fpsFullyOutside = fpsRight <= 0 || fpsLeft >= window.innerWidth || currentY + dimensions.height <= 0 || currentY >= window.innerHeight;
					shouldCollapse = fpsFullyOutside;
				}
				if (shouldCollapse) {
					const widgetCenterX = currentX + dimensions.width / 2;
					const widgetCenterY = currentY + dimensions.height / 2;
					const screenCenterX = window.innerWidth / 2;
					const screenCenterY = window.innerHeight / 2;
					let targetCorner;
					if (widgetCenterX < screenCenterX) targetCorner = widgetCenterY < screenCenterY ? "top-left" : "bottom-left";
					else targetCorner = widgetCenterY < screenCenterY ? "top-right" : "bottom-right";
					let orientation;
					const horizontalOverflow = Math.max(outsideLeft, outsideRight);
					const verticalOverflow = Math.max(outsideTop, outsideBottom);
					orientation = horizontalOverflow > verticalOverflow ? "horizontal" : "vertical";
					signalWidget.value = {
						...signalWidget.value,
						corner: targetCorner,
						lastDimensions: {
							...dimensions,
							position: calculatePosition(targetCorner, dimensions.width, dimensions.height)
						}
					};
					const collapsedPosition = {
						corner: targetCorner,
						orientation
					};
					signalWidgetCollapsed.value = collapsedPosition;
					saveLocalStorage(LOCALSTORAGE_COLLAPSED_KEY, collapsedPosition);
					saveLocalStorage(LOCALSTORAGE_KEY, signalWidget.value);
					updateWidgetPosition(false);
					document.removeEventListener("pointermove", handlePointerMove);
					document.removeEventListener("pointerup", handlePointerEnd);
					if (rafId) {
						cancelAnimationFrame(rafId);
						rafId = null;
					}
				}
				rafId = null;
			});
		};
		const handlePointerEnd = () => {
			if (!container) return;
			if (rafId) {
				cancelAnimationFrame(rafId);
				rafId = null;
			}
			document.removeEventListener("pointermove", handlePointerMove);
			document.removeEventListener("pointerup", handlePointerEnd);
			const totalDeltaX = Math.abs(lastMouseX - initialMouseX);
			const totalDeltaY = Math.abs(lastMouseY - initialMouseY);
			const totalMovement = Math.sqrt(totalDeltaX * totalDeltaX + totalDeltaY * totalDeltaY);
			if (!hasMoved || totalMovement < 60) return;
			const newCorner = getBestCorner(lastMouseX, lastMouseY, initialMouseX, initialMouseY, Store.inspectState.value.kind === "focused" ? 80 : 40);
			if (newCorner === signalWidget.value.corner) {
				containerStyle.transition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
				const currentPosition = signalWidget.value.dimensions.position;
				requestAnimationFrame(() => {
					containerStyle.transform = `translate3d(${currentPosition.x}px, ${currentPosition.y}px, 0)`;
				});
				return;
			}
			const snappedPosition = calculatePosition(newCorner, dimensions.width, dimensions.height);
			if (currentX === initialX && currentY === initialY) return;
			const onTransitionEnd = () => {
				containerStyle.transition = "none";
				updateDimensions();
				container.removeEventListener("transitionend", onTransitionEnd);
				if (rafId) {
					cancelAnimationFrame(rafId);
					rafId = null;
				}
			};
			container.addEventListener("transitionend", onTransitionEnd);
			containerStyle.transition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
			requestAnimationFrame(() => {
				containerStyle.transform = `translate3d(${snappedPosition.x}px, ${snappedPosition.y}px, 0)`;
			});
			signalWidget.value = {
				corner: newCorner,
				dimensions: {
					isFullWidth: dimensions.isFullWidth,
					isFullHeight: dimensions.isFullHeight,
					width: dimensions.width,
					height: dimensions.height,
					position: snappedPosition
				},
				lastDimensions: signalWidget.value.lastDimensions,
				componentsTree: signalWidget.value.componentsTree
			};
			saveLocalStorage(LOCALSTORAGE_KEY, {
				corner: newCorner,
				dimensions: signalWidget.value.dimensions,
				lastDimensions: signalWidget.value.lastDimensions,
				componentsTree: signalWidget.value.componentsTree
			});
		};
		document.addEventListener("pointermove", handlePointerMove);
		document.addEventListener("pointerup", handlePointerEnd);
	}, []);
	const handleCollapsedDrag = useCallback$1((e$1) => {
		e$1.preventDefault();
		if (!refWidget.current || !signalWidgetCollapsed.value) return;
		const { corner: collapsedCorner, orientation = "horizontal" } = signalWidgetCollapsed.value;
		const initialMouseX = e$1.clientX;
		const initialMouseY = e$1.clientY;
		let rafId = null;
		let hasExpanded = false;
		const DRAG_THRESHOLD = 50;
		const handlePointerMove = (e$2) => {
			if (hasExpanded || rafId) return;
			const deltaX = e$2.clientX - initialMouseX;
			const deltaY = e$2.clientY - initialMouseY;
			let shouldExpand = false;
			if (orientation === "horizontal") {
				if (collapsedCorner.endsWith("left") && deltaX > DRAG_THRESHOLD) shouldExpand = true;
				else if (collapsedCorner.endsWith("right") && deltaX < -DRAG_THRESHOLD) shouldExpand = true;
			} else if (collapsedCorner.startsWith("top") && deltaY > DRAG_THRESHOLD) shouldExpand = true;
			else if (collapsedCorner.startsWith("bottom") && deltaY < -DRAG_THRESHOLD) shouldExpand = true;
			if (shouldExpand) {
				hasExpanded = true;
				signalWidgetCollapsed.value = null;
				saveLocalStorage(LOCALSTORAGE_COLLAPSED_KEY, null);
				if (refInitialMinimizedWidth.current === 0 && refWidget.current) requestAnimationFrame(() => {
					if (refWidget.current) {
						refWidget.current.style.width = "min-content";
						const naturalWidth = refWidget.current.offsetWidth;
						refInitialMinimizedWidth.current = naturalWidth || 300;
						const lastDims = signalWidget.value.lastDimensions;
						const targetWidth = calculateBoundedSize(lastDims.width, 0, true);
						const targetHeight = calculateBoundedSize(lastDims.height, 0, false);
						let newX = e$2.clientX - targetWidth / 2;
						let newY = e$2.clientY - targetHeight / 2;
						newX = Math.max(SAFE_AREA, Math.min(newX, window.innerWidth - targetWidth - SAFE_AREA));
						newY = Math.max(SAFE_AREA, Math.min(newY, window.innerHeight - targetHeight - SAFE_AREA));
						signalWidget.value = {
							...signalWidget.value,
							dimensions: {
								...signalWidget.value.dimensions,
								position: {
									x: newX,
									y: newY
								}
							}
						};
						updateWidgetPosition(true);
						const savedView = readLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY);
						signalWidgetViews.value = savedView || { view: "none" };
						setTimeout(() => {
							if (refWidget.current) {
								const dragEvent = new PointerEvent("pointerdown", {
									clientX: e$2.clientX,
									clientY: e$2.clientY,
									pointerId: e$2.pointerId,
									bubbles: true
								});
								refWidget.current.dispatchEvent(dragEvent);
							}
						}, 100);
					}
				});
				else {
					updateWidgetPosition(true);
					const savedView = readLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY);
					signalWidgetViews.value = savedView || { view: "none" };
				}
				document.removeEventListener("pointermove", handlePointerMove);
				document.removeEventListener("pointerup", handlePointerEnd);
			}
		};
		const handlePointerEnd = () => {
			if (rafId) {
				cancelAnimationFrame(rafId);
				rafId = null;
			}
			document.removeEventListener("pointermove", handlePointerMove);
			document.removeEventListener("pointerup", handlePointerEnd);
		};
		document.addEventListener("pointermove", handlePointerMove);
		document.addEventListener("pointerup", handlePointerEnd);
	}, []);
	useEffect$1(() => {
		if (!refWidget.current) return;
		removeLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY);
		if (!signalWidgetCollapsed.value) {
			refWidget.current.style.width = "min-content";
			refInitialMinimizedHeight.current = 36;
			refInitialMinimizedWidth.current = refWidget.current.offsetWidth;
		} else {
			refInitialMinimizedHeight.current = 36;
			refInitialMinimizedWidth.current = 0;
		}
		refWidget.current.style.maxWidth = `calc(100vw - ${SAFE_AREA * 2}px)`;
		refWidget.current.style.maxHeight = `calc(100vh - ${SAFE_AREA * 2}px)`;
		updateWidgetPosition();
		if (Store.inspectState.value.kind !== "focused" && !signalWidgetCollapsed.value && !refExpandingFromCollapsed.current) signalWidget.value = {
			...signalWidget.value,
			dimensions: {
				isFullWidth: false,
				isFullHeight: false,
				width: refInitialMinimizedWidth.current,
				height: refInitialMinimizedHeight.current,
				position: signalWidget.value.dimensions.position
			}
		};
		signalRefWidget.value = refWidget.current;
		const unsubscribeSignalWidget = signalWidget.subscribe((widget) => {
			if (!refWidget.current) return;
			const { x: x$2, y: y$1 } = widget.dimensions.position;
			const { width, height } = widget.dimensions;
			const container = refWidget.current;
			requestAnimationFrame(() => {
				container.style.transform = `translate3d(${x$2}px, ${y$1}px, 0)`;
				container.style.width = `${width}px`;
				container.style.height = `${height}px`;
			});
		});
		const unsubscribeSignalWidgetViews = signalWidgetViews.subscribe((state) => {
			refShouldOpen.current = state.view !== "none";
			updateWidgetPosition();
			if (!signalWidgetCollapsed.value) if (state.view !== "none") saveLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY, state);
			else removeLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY);
		});
		const unsubscribeStoreInspectState = Store.inspectState.subscribe((state) => {
			refShouldOpen.current = state.kind === "focused";
			updateWidgetPosition();
		});
		const handleWindowResize = () => {
			updateWidgetPosition(true);
		};
		window.addEventListener("resize", handleWindowResize, { passive: true });
		return () => {
			window.removeEventListener("resize", handleWindowResize);
			unsubscribeSignalWidgetViews();
			unsubscribeStoreInspectState();
			unsubscribeSignalWidget();
			saveLocalStorage(LOCALSTORAGE_KEY, {
				...defaultWidgetConfig,
				corner: signalWidget.value.corner
			});
		};
	}, []);
	const [_$1, setTriggerRender] = useState$1(false);
	useEffect$1(() => {
		setTriggerRender(true);
	}, []);
	const isCollapsed = signalWidgetCollapsed.value;
	let arrowRotationClass = "";
	if (isCollapsed) {
		const { orientation = "horizontal", corner } = isCollapsed;
		if (orientation === "horizontal") arrowRotationClass = corner?.endsWith("right") ? "rotate-180" : "";
		else arrowRotationClass = corner?.startsWith("bottom") ? "-rotate-90" : "rotate-90";
	}
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(ScanOverlay, {}), /* @__PURE__ */ jsx(ToolbarElementContext.Provider, {
		value: refWidget.current,
		children: /* @__PURE__ */ jsx("div", {
			id: "react-devtool-toolbar",
			dir: "ltr",
			ref: refWidget,
			onPointerDown: !isCollapsed ? handleDrag : handleCollapsedDrag,
			className: cn("fixed inset-0", isCollapsed ? (() => {
				const { orientation = "horizontal", corner } = isCollapsed;
				if (orientation === "horizontal") return corner?.endsWith("right") ? "rounded-tl-lg rounded-bl-lg shadow-lg" : "rounded-tr-lg rounded-br-lg shadow-lg";
				else return corner?.startsWith("bottom") ? "rounded-tl-lg rounded-tr-lg shadow-lg" : "rounded-bl-lg rounded-br-lg shadow-lg";
			})() : "rounded-lg shadow-lg", "flex flex-col", "font-mono text-[13px]", "user-select-none", "opacity-0", isCollapsed ? "cursor-pointer" : "cursor-move", "z-[124124124124]", "animate-fade-in animation-duration-300 animation-delay-300", "will-change-transform", "[touch-action:none]"),
			children: isCollapsed ? /* @__PURE__ */ jsx("button", {
				type: "button",
				onClick: () => {
					signalWidgetCollapsed.value = null;
					saveLocalStorage(LOCALSTORAGE_COLLAPSED_KEY, null);
					if (refInitialMinimizedWidth.current === 0 && refWidget.current) requestAnimationFrame(() => {
						if (refWidget.current) {
							refWidget.current.style.width = "min-content";
							const naturalWidth = refWidget.current.offsetWidth;
							refInitialMinimizedWidth.current = naturalWidth || 300;
							updateWidgetPosition(true);
						}
					});
					const savedView = readLocalStorage(LOCALSTORAGE_LAST_VIEW_KEY);
					signalWidgetViews.value = savedView || { view: "none" };
				},
				className: "flex items-center justify-center w-full h-full text-white",
				title: "Expand toolbar",
				children: /* @__PURE__ */ jsx(Icon, {
					name: "icon-chevron-right",
					size: 16,
					className: cn("transition-transform", arrowRotationClass)
				})
			}) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
				/* @__PURE__ */ jsx(ResizeHandle, { position: "top" }),
				/* @__PURE__ */ jsx(ResizeHandle, { position: "bottom" }),
				/* @__PURE__ */ jsx(ResizeHandle, { position: "left" }),
				/* @__PURE__ */ jsx(ResizeHandle, { position: "right" }),
				/* @__PURE__ */ jsx(Content, {})
			] })
		})
	})] });
};
const ToolbarElementContext = /* @__PURE__ */ createContext$1(null);
const SvgSprite = () => {
	return /* @__PURE__ */ jsxs("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		style: "display: none;",
		children: [
			/* @__PURE__ */ jsx("title", { children: "React Devtool Icons" }),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-inspect",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Inspect" }),
					/* @__PURE__ */ jsx("path", { d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z" }),
					/* @__PURE__ */ jsx("path", { d: "M5 3a2 2 0 0 0-2 2" }),
					/* @__PURE__ */ jsx("path", { d: "M19 3a2 2 0 0 1 2 2" }),
					/* @__PURE__ */ jsx("path", { d: "M5 21a2 2 0 0 1-2-2" }),
					/* @__PURE__ */ jsx("path", { d: "M9 3h1" }),
					/* @__PURE__ */ jsx("path", { d: "M9 21h2" }),
					/* @__PURE__ */ jsx("path", { d: "M14 3h1" }),
					/* @__PURE__ */ jsx("path", { d: "M3 9v1" }),
					/* @__PURE__ */ jsx("path", { d: "M21 9v2" }),
					/* @__PURE__ */ jsx("path", { d: "M3 14v1" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-focus",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Focus" }),
					/* @__PURE__ */ jsx("path", { d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z" }),
					/* @__PURE__ */ jsx("path", { d: "M21 11V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-next",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [/* @__PURE__ */ jsx("title", { children: "Next" }), /* @__PURE__ */ jsx("path", { d: "M6 9h6V5l7 7-7 7v-4H6V9z" })]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-previous",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [/* @__PURE__ */ jsx("title", { children: "Previous" }), /* @__PURE__ */ jsx("path", { d: "M18 15h-6v4l-7-7 7-7v4h6v6z" })]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-close",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Close" }),
					/* @__PURE__ */ jsx("line", {
						x1: "18",
						y1: "6",
						x2: "6",
						y2: "18"
					}),
					/* @__PURE__ */ jsx("line", {
						x1: "6",
						y1: "6",
						x2: "18",
						y2: "18"
					})
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-replay",
				viewBox: "0 0 24 24",
				fill: "none",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Replay" }),
					/* @__PURE__ */ jsx("path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }),
					/* @__PURE__ */ jsx("path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }),
					/* @__PURE__ */ jsx("path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }),
					/* @__PURE__ */ jsx("path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }),
					/* @__PURE__ */ jsx("circle", {
						cx: "12",
						cy: "12",
						r: "1"
					}),
					/* @__PURE__ */ jsx("path", { d: "M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-ellipsis",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Ellipsis" }),
					/* @__PURE__ */ jsx("circle", {
						cx: "12",
						cy: "12",
						r: "1"
					}),
					/* @__PURE__ */ jsx("circle", {
						cx: "19",
						cy: "12",
						r: "1"
					}),
					/* @__PURE__ */ jsx("circle", {
						cx: "5",
						cy: "12",
						r: "1"
					})
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-copy",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Copy" }),
					/* @__PURE__ */ jsx("rect", {
						width: "14",
						height: "14",
						x: "8",
						y: "8",
						rx: "2",
						ry: "2"
					}),
					/* @__PURE__ */ jsx("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-check",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [/* @__PURE__ */ jsx("title", { children: "Check" }), /* @__PURE__ */ jsx("path", { d: "M20 6 9 17l-5-5" })]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-chevron-right",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [/* @__PURE__ */ jsx("title", { children: "Chevron Right" }), /* @__PURE__ */ jsx("path", { d: "m9 18 6-6-6-6" })]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-settings",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Settings" }),
					/* @__PURE__ */ jsx("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" }),
					/* @__PURE__ */ jsx("circle", {
						cx: "12",
						cy: "12",
						r: "3"
					})
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-flame",
				viewBox: "0 0 24 24",
				children: [/* @__PURE__ */ jsx("title", { children: "Flame" }), /* @__PURE__ */ jsx("path", { d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z" })]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-function",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Function" }),
					/* @__PURE__ */ jsx("rect", {
						width: "18",
						height: "18",
						x: "3",
						y: "3",
						rx: "2",
						ry: "2"
					}),
					/* @__PURE__ */ jsx("path", { d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3" }),
					/* @__PURE__ */ jsx("path", { d: "M9 11.2h5.7" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-triangle-alert",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Alert" }),
					/* @__PURE__ */ jsx("path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" }),
					/* @__PURE__ */ jsx("path", { d: "M12 9v4" }),
					/* @__PURE__ */ jsx("path", { d: "M12 17h.01" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-gallery-horizontal-end",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Gallery" }),
					/* @__PURE__ */ jsx("path", { d: "M2 7v10" }),
					/* @__PURE__ */ jsx("path", { d: "M6 5v14" }),
					/* @__PURE__ */ jsx("rect", {
						width: "12",
						height: "18",
						x: "10",
						y: "3",
						rx: "2"
					})
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-search",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Search" }),
					/* @__PURE__ */ jsx("circle", {
						cx: "11",
						cy: "11",
						r: "8"
					}),
					/* @__PURE__ */ jsx("line", {
						x1: "21",
						y1: "21",
						x2: "16.65",
						y2: "16.65"
					})
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-lock",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Lock" }),
					/* @__PURE__ */ jsx("rect", {
						width: "18",
						height: "11",
						x: "3",
						y: "11",
						rx: "2",
						ry: "2"
					}),
					/* @__PURE__ */ jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-lock-open",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Lock Open" }),
					/* @__PURE__ */ jsx("rect", {
						width: "18",
						height: "11",
						x: "3",
						y: "11",
						rx: "2",
						ry: "2"
					}),
					/* @__PURE__ */ jsx("path", { d: "M7 11V7a5 5 0 0 1 9.9-1" })
				]
			}),
			/* @__PURE__ */ jsxs("symbol", {
				id: "icon-sanil",
				viewBox: "0 0 24 24",
				fill: "none",
				stroke: "currentColor",
				"stroke-width": "2",
				"stroke-linecap": "round",
				"stroke-linejoin": "round",
				children: [
					/* @__PURE__ */ jsx("title", { children: "Snail" }),
					/* @__PURE__ */ jsx("path", { d: "M2 13a6 6 0 1 0 12 0 4 4 0 1 0-8 0 2 2 0 0 0 4 0" }),
					/* @__PURE__ */ jsx("circle", {
						cx: "10",
						cy: "13",
						r: "8"
					}),
					/* @__PURE__ */ jsx("path", { d: "M2 21h12c4.4 0 8-3.6 8-8V7a2 2 0 1 0-4 0v6" }),
					/* @__PURE__ */ jsx("path", { d: "M18 3 19.1 5.2" })
				]
			})
		]
	});
};
var ToolbarErrorBoundary = class extends Component {
	state = {
		hasError: false,
		error: null
	};
	static getDerivedStateFromError(error) {
		console.log(error);
		return {
			hasError: true,
			error
		};
	}
	handleReset = () => {
		this.setState({
			hasError: false,
			error: null
		});
	};
	render() {
		if (this.state.hasError) return /* @__PURE__ */ jsx("div", {
			className: "fixed bottom-4 right-4 z-[124124124124]",
			children: /* @__PURE__ */ jsxs("div", {
				className: "p-3 bg-black rounded-lg shadow-lg w-80",
				children: [
					/* @__PURE__ */ jsxs("div", {
						className: "flex items-center gap-2 mb-2 text-red-400 text-sm font-medium",
						children: [/* @__PURE__ */ jsx(Icon, {
							name: "icon-flame",
							className: "text-red-500",
							size: 14
						}), "React Devtool ran into a problem"]
					}),
					/* @__PURE__ */ jsx("div", {
						className: "p-2 bg-black rounded font-mono text-xs text-red-300 mb-3 break-words",
						children: this.state.error?.message || JSON.stringify(this.state.error)
					}),
					/* @__PURE__ */ jsx("button", {
						type: "button",
						onClick: this.handleReset,
						className: "px-3 py-1.5 bg-red-500 hover:bg-red-600 text-white rounded text-xs font-medium transition-colors flex items-center justify-center gap-1.5",
						children: "Restart"
					})
				]
			})
		});
		return this.props.children;
	}
};
const createToolbar = (root) => {
	const container = document.createElement("div");
	container.id = "react-devtool-toolbar-root";
	window.__REACT_DEVTOOL_TOOLBAR_CONTAINER__ = container;
	root.appendChild(container);
	render(/* @__PURE__ */ jsx(ToolbarErrorBoundary, { children: /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SvgSprite, {}), /* @__PURE__ */ jsx(Widget, {})] }) }), container);
	const originalRemove = container.remove.bind(container);
	container.remove = () => {
		window.__REACT_DEVTOOL_TOOLBAR_CONTAINER__ = void 0;
		if (container.hasChildNodes()) {
			render(null, container);
			render(null, container);
		}
		originalRemove();
	};
	return container;
};
var src_default = "/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */\n@layer properties {\n  @supports (((-webkit-hyphens: none)) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color: rgb(from red r g b)))) {\n    *, :before, :after, ::backdrop {\n      --tw-translate-x: 0;\n      --tw-translate-y: 0;\n      --tw-translate-z: 0;\n      --tw-rotate-x: initial;\n      --tw-rotate-y: initial;\n      --tw-rotate-z: initial;\n      --tw-skew-x: initial;\n      --tw-skew-y: initial;\n      --tw-space-y-reverse: 0;\n      --tw-space-x-reverse: 0;\n      --tw-border-style: solid;\n      --tw-leading: initial;\n      --tw-font-weight: initial;\n      --tw-tracking: initial;\n      --tw-shadow: 0 0 #0000;\n      --tw-shadow-color: initial;\n      --tw-shadow-alpha: 100%;\n      --tw-inset-shadow: 0 0 #0000;\n      --tw-inset-shadow-color: initial;\n      --tw-inset-shadow-alpha: 100%;\n      --tw-ring-color: initial;\n      --tw-ring-shadow: 0 0 #0000;\n      --tw-inset-ring-color: initial;\n      --tw-inset-ring-shadow: 0 0 #0000;\n      --tw-ring-inset: initial;\n      --tw-ring-offset-width: 0px;\n      --tw-ring-offset-color: #fff;\n      --tw-ring-offset-shadow: 0 0 #0000;\n      --tw-outline-style: solid;\n      --tw-blur: initial;\n      --tw-brightness: initial;\n      --tw-contrast: initial;\n      --tw-grayscale: initial;\n      --tw-hue-rotate: initial;\n      --tw-invert: initial;\n      --tw-opacity: initial;\n      --tw-saturate: initial;\n      --tw-sepia: initial;\n      --tw-drop-shadow: initial;\n      --tw-drop-shadow-color: initial;\n      --tw-drop-shadow-alpha: 100%;\n      --tw-drop-shadow-size: initial;\n      --tw-backdrop-blur: initial;\n      --tw-backdrop-brightness: initial;\n      --tw-backdrop-contrast: initial;\n      --tw-backdrop-grayscale: initial;\n      --tw-backdrop-hue-rotate: initial;\n      --tw-backdrop-invert: initial;\n      --tw-backdrop-opacity: initial;\n      --tw-backdrop-saturate: initial;\n      --tw-backdrop-sepia: initial;\n      --tw-duration: initial;\n      --tw-ease: initial;\n      --tw-content: \"\";\n      --tw-ordinal: initial;\n      --tw-slashed-zero: initial;\n      --tw-numeric-figure: initial;\n      --tw-numeric-spacing: initial;\n      --tw-numeric-fraction: initial;\n    }\n  }\n}\n\n@layer theme {\n  :root, :host {\n    --font-sans: ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n    --font-mono: SFMono-Regular, \"SF Mono\", ui-monospace, Consolas, \"Liberation Mono\", Menlo, monospace;\n    --color-red-300: oklch(80.8% .114 19.571);\n    --color-red-400: oklch(70.4% .191 22.216);\n    --color-red-500: oklch(63.7% .237 25.331);\n    --color-red-600: oklch(57.7% .245 27.325);\n    --color-red-700: oklch(50.5% .213 27.518);\n    --color-red-950: oklch(25.8% .092 26.042);\n    --color-orange-400: oklch(75% .183 55.934);\n    --color-yellow-300: oklch(90.5% .182 98.111);\n    --color-yellow-400: oklch(85.2% .199 91.936);\n    --color-yellow-500: oklch(79.5% .184 86.047);\n    --color-green-400: oklch(79.2% .209 151.711);\n    --color-green-500: oklch(72.3% .219 149.579);\n    --color-blue-400: oklch(70.7% .165 254.624);\n    --color-blue-500: oklch(62.3% .214 259.815);\n    --color-blue-600: oklch(54.6% .245 262.881);\n    --color-purple-400: oklch(71.4% .203 305.504);\n    --color-purple-500: oklch(62.7% .265 303.9);\n    --color-purple-800: oklch(43.8% .218 303.724);\n    --color-gray-300: oklch(87.2% .01 258.338);\n    --color-gray-400: oklch(70.7% .022 261.325);\n    --color-gray-500: oklch(55.1% .027 264.364);\n    --color-gray-600: oklch(44.6% .03 256.802);\n    --color-gray-700: oklch(37.3% .034 259.733);\n    --color-gray-800: oklch(27.8% .033 256.848);\n    --color-neutral-300: oklch(87% 0 0);\n    --color-neutral-400: oklch(70.8% 0 0);\n    --color-neutral-500: oklch(55.6% 0 0);\n    --color-neutral-600: oklch(43.9% 0 0);\n    --color-neutral-700: oklch(37.1% 0 0);\n    --color-neutral-800: oklch(26.9% 0 0);\n    --color-black: #000;\n    --color-white: #fff;\n    --spacing: .25rem;\n    --container-md: 28rem;\n    --text-xs: .75rem;\n    --text-xs--line-height: calc(1 / .75);\n    --text-sm: .875rem;\n    --text-sm--line-height: calc(1.25 / .875);\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --text-xl: 1.25rem;\n    --text-xl--line-height: calc(1.75 / 1.25);\n    --font-weight-medium: 500;\n    --font-weight-semibold: 600;\n    --font-weight-bold: 700;\n    --tracking-wide: .025em;\n    --leading-snug: 1.375;\n    --leading-relaxed: 1.625;\n    --radius-sm: .25rem;\n    --radius-md: .375rem;\n    --radius-lg: .5rem;\n    --radius-xl: .75rem;\n    --ease-in: cubic-bezier(.4, 0, 1, 1);\n    --ease-out: cubic-bezier(0, 0, .2, 1);\n    --ease-in-out: cubic-bezier(.4, 0, .2, 1);\n    --blur-sm: 8px;\n    --default-transition-duration: .15s;\n    --default-transition-timing-function: cubic-bezier(.4, 0, .2, 1);\n    --default-font-family: var(--font-sans);\n    --default-mono-font-family: var(--font-mono);\n    --color-secondary: #404756;\n    --color-wash: #fff;\n    --color-wash-dark: #23272f;\n    --color-brand-dark: #58c4dc;\n    --color-gray-95: #16181d;\n    --color-gray-90: #23272f;\n    --color-gray-80: #343a46;\n    --color-gray-40: #78839b;\n    --color-blue-30: #58c4dc;\n    --color-yellow-30: #fabd62;\n    --color-red-30: #d07d77;\n    --font-display: \"Optimistic Display\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif;\n    --font-text: \"Optimistic Text\", -apple-system, ui-sans-serif, system-ui, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;\n  }\n}\n\n@layer base {\n  *, :after, :before, ::backdrop {\n    box-sizing: border-box;\n    border: 0 solid;\n    margin: 0;\n    padding: 0;\n  }\n\n  ::file-selector-button {\n    box-sizing: border-box;\n    border: 0 solid;\n    margin: 0;\n    padding: 0;\n  }\n\n  html, :host {\n    -webkit-text-size-adjust: 100%;\n    tab-size: 4;\n    line-height: 1.5;\n    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\");\n    font-feature-settings: var(--default-font-feature-settings, normal);\n    font-variation-settings: var(--default-font-variation-settings, normal);\n    -webkit-tap-highlight-color: transparent;\n  }\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n\n  h1, h2, h3, h4, h5, h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    -webkit-text-decoration: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n\n  b, strong {\n    font-weight: bolder;\n  }\n\n  code, kbd, samp, pre {\n    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace);\n    font-feature-settings: var(--default-mono-font-feature-settings, normal);\n    font-variation-settings: var(--default-mono-font-variation-settings, normal);\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub, sup {\n    vertical-align: baseline;\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n  }\n\n  sub {\n    bottom: -.25em;\n  }\n\n  sup {\n    top: -.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  :-moz-focusring {\n    outline: auto;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  ol, ul, menu {\n    list-style: none;\n  }\n\n  img, svg, video, canvas, audio, iframe, embed, object {\n    vertical-align: middle;\n    display: block;\n  }\n\n  img, video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  button, input, select, optgroup, textarea {\n    font: inherit;\n    font-feature-settings: inherit;\n    font-variation-settings: inherit;\n    letter-spacing: inherit;\n    color: inherit;\n    opacity: 1;\n    background-color: #0000;\n    border-radius: 0;\n  }\n\n  ::file-selector-button {\n    font: inherit;\n    font-feature-settings: inherit;\n    font-variation-settings: inherit;\n    letter-spacing: inherit;\n    color: inherit;\n    opacity: 1;\n    background-color: #0000;\n    border-radius: 0;\n  }\n\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n\n  ::placeholder {\n    opacity: 1;\n  }\n\n  @supports (not ((-webkit-appearance: -apple-pay-button))) or (contain-intrinsic-size: 1px) {\n    ::placeholder {\n      color: currentColor;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      ::placeholder {\n        color: color-mix(in oklab, currentcolor 50%, transparent);\n      }\n    }\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-date-and-time-value {\n    min-height: 1lh;\n    text-align: inherit;\n  }\n\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n\n  ::-webkit-datetime-edit {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-year-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-month-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-day-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-hour-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-minute-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-second-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-millisecond-field {\n    padding-block: 0;\n  }\n\n  ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  button, input:where([type=\"button\"], [type=\"reset\"], [type=\"submit\"]) {\n    appearance: button;\n  }\n\n  ::file-selector-button {\n    appearance: button;\n  }\n\n  ::-webkit-inner-spin-button {\n    height: auto;\n  }\n\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [hidden]:where(:not([hidden=\"until-found\"])) {\n    display: none !important;\n  }\n}\n\n@layer components;\n\n@layer utilities {\n  .pointer-events-auto {\n    pointer-events: auto;\n  }\n\n  .pointer-events-bounding-box {\n    pointer-events: bounding-box;\n  }\n\n  .pointer-events-none {\n    pointer-events: none;\n  }\n\n  .visible {\n    visibility: visible;\n  }\n\n  .absolute {\n    position: absolute;\n  }\n\n  .fixed {\n    position: fixed;\n  }\n\n  .relative {\n    position: relative;\n  }\n\n  .static {\n    position: static;\n  }\n\n  .inset-0 {\n    inset: calc(var(--spacing) * 0);\n  }\n\n  .inset-x-1 {\n    inset-inline: calc(var(--spacing) * 1);\n  }\n\n  .inset-y-0 {\n    inset-block: calc(var(--spacing) * 0);\n  }\n\n  .top-0 {\n    top: calc(var(--spacing) * 0);\n  }\n\n  .top-0\\.5 {\n    top: calc(var(--spacing) * .5);\n  }\n\n  .right-0\\.5 {\n    right: calc(var(--spacing) * .5);\n  }\n\n  .right-4 {\n    right: calc(var(--spacing) * 4);\n  }\n\n  .bottom-4 {\n    bottom: calc(var(--spacing) * 4);\n  }\n\n  .left-0 {\n    left: calc(var(--spacing) * 0);\n  }\n\n  .z-10 {\n    z-index: 10;\n  }\n\n  .z-50 {\n    z-index: 50;\n  }\n\n  .z-\\[99999\\] {\n    z-index: 99999;\n  }\n\n  .z-\\[214748365\\] {\n    z-index: 214748365;\n  }\n\n  .z-\\[214748367\\] {\n    z-index: 214748367;\n  }\n\n  .z-\\[124124124124\\] {\n    z-index: 2147483647;\n  }\n\n  .container {\n    width: 100%;\n  }\n\n  @media (min-width: 40rem) {\n    .container {\n      max-width: 40rem;\n    }\n  }\n\n  @media (min-width: 48rem) {\n    .container {\n      max-width: 48rem;\n    }\n  }\n\n  @media (min-width: 64rem) {\n    .container {\n      max-width: 64rem;\n    }\n  }\n\n  @media (min-width: 80rem) {\n    .container {\n      max-width: 80rem;\n    }\n  }\n\n  @media (min-width: 96rem) {\n    .container {\n      max-width: 96rem;\n    }\n  }\n\n  .mx-auto {\n    margin-inline: auto;\n  }\n\n  .me-0 {\n    margin-inline-end: calc(var(--spacing) * 0);\n  }\n\n  .mt-0\\.5 {\n    margin-top: calc(var(--spacing) * .5);\n  }\n\n  .mt-1 {\n    margin-top: calc(var(--spacing) * 1);\n  }\n\n  .mt-2\\.5 {\n    margin-top: calc(var(--spacing) * 2.5);\n  }\n\n  .mt-6 {\n    margin-top: calc(var(--spacing) * 6);\n  }\n\n  .mr-1 {\n    margin-right: calc(var(--spacing) * 1);\n  }\n\n  .mr-auto {\n    margin-right: auto;\n  }\n\n  .mb-1 {\n    margin-bottom: calc(var(--spacing) * 1);\n  }\n\n  .mb-1\\.5 {\n    margin-bottom: calc(var(--spacing) * 1.5);\n  }\n\n  .mb-2 {\n    margin-bottom: calc(var(--spacing) * 2);\n  }\n\n  .mb-3 {\n    margin-bottom: calc(var(--spacing) * 3);\n  }\n\n  .mb-4 {\n    margin-bottom: calc(var(--spacing) * 4);\n  }\n\n  .mb-px {\n    margin-bottom: 1px;\n  }\n\n  .\\!ml-0 {\n    margin-left: calc(var(--spacing) * 0) !important;\n  }\n\n  .ml-1 {\n    margin-left: calc(var(--spacing) * 1);\n  }\n\n  .ml-1\\.5 {\n    margin-left: calc(var(--spacing) * 1.5);\n  }\n\n  .ml-auto {\n    margin-left: auto;\n  }\n\n  .line-clamp-2 {\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n    display: -webkit-box;\n    overflow: hidden;\n  }\n\n  .line-clamp-3 {\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n    display: -webkit-box;\n    overflow: hidden;\n  }\n\n  .block {\n    display: block;\n  }\n\n  .flex {\n    display: flex;\n  }\n\n  .grid {\n    display: grid;\n  }\n\n  .hidden {\n    display: none;\n  }\n\n  .inline-flex {\n    display: inline-flex;\n  }\n\n  .table {\n    display: table;\n  }\n\n  .h-1 {\n    height: calc(var(--spacing) * 1);\n  }\n\n  .h-2 {\n    height: calc(var(--spacing) * 2);\n  }\n\n  .h-3 {\n    height: calc(var(--spacing) * 3);\n  }\n\n  .h-4 {\n    height: calc(var(--spacing) * 4);\n  }\n\n  .h-6 {\n    height: calc(var(--spacing) * 6);\n  }\n\n  .h-7 {\n    height: calc(var(--spacing) * 7);\n  }\n\n  .h-8 {\n    height: calc(var(--spacing) * 8);\n  }\n\n  .h-9 {\n    height: calc(var(--spacing) * 9);\n  }\n\n  .h-12 {\n    height: calc(var(--spacing) * 12);\n  }\n\n  .h-40 {\n    height: calc(var(--spacing) * 40);\n  }\n\n  .h-full {\n    height: 100%;\n  }\n\n  .h-screen {\n    height: 100vh;\n  }\n\n  .max-h-0 {\n    max-height: calc(var(--spacing) * 0);\n  }\n\n  .max-h-9 {\n    max-height: calc(var(--spacing) * 9);\n  }\n\n  .max-h-40 {\n    max-height: calc(var(--spacing) * 40);\n  }\n\n  .min-h-9 {\n    min-height: calc(var(--spacing) * 9);\n  }\n\n  .min-h-\\[48px\\] {\n    min-height: 48px;\n  }\n\n  .w-1 {\n    width: calc(var(--spacing) * 1);\n  }\n\n  .w-2 {\n    width: calc(var(--spacing) * 2);\n  }\n\n  .w-3 {\n    width: calc(var(--spacing) * 3);\n  }\n\n  .w-4 {\n    width: calc(var(--spacing) * 4);\n  }\n\n  .w-6 {\n    width: calc(var(--spacing) * 6);\n  }\n\n  .w-7 {\n    width: calc(var(--spacing) * 7);\n  }\n\n  .w-8 {\n    width: calc(var(--spacing) * 8);\n  }\n\n  .w-10 {\n    width: calc(var(--spacing) * 10);\n  }\n\n  .w-12 {\n    width: calc(var(--spacing) * 12);\n  }\n\n  .w-20 {\n    width: calc(var(--spacing) * 20);\n  }\n\n  .w-80 {\n    width: calc(var(--spacing) * 80);\n  }\n\n  .w-\\[3px\\] {\n    width: 3px;\n  }\n\n  .w-\\[72px\\] {\n    width: 72px;\n  }\n\n  .w-full {\n    width: 100%;\n  }\n\n  .w-screen {\n    width: 100vw;\n  }\n\n  .max-w-md {\n    max-width: var(--container-md);\n  }\n\n  .min-w-32 {\n    min-width: calc(var(--spacing) * 32);\n  }\n\n  .min-w-fit {\n    min-width: fit-content;\n  }\n\n  .flex-1 {\n    flex: 1;\n  }\n\n  .flex-shrink-0, .shrink-0 {\n    flex-shrink: 0;\n  }\n\n  .origin-center {\n    transform-origin: center;\n  }\n\n  .translate-x-0 {\n    --tw-translate-x: calc(var(--spacing) * 0);\n    translate: var(--tw-translate-x) var(--tw-translate-y);\n  }\n\n  .translate-x-3 {\n    --tw-translate-x: calc(var(--spacing) * 3);\n    translate: var(--tw-translate-x) var(--tw-translate-y);\n  }\n\n  .-translate-y-\\[200\\%\\] {\n    --tw-translate-y: calc(200% * -1);\n    translate: var(--tw-translate-x) var(--tw-translate-y);\n  }\n\n  .translate-y-0 {\n    --tw-translate-y: calc(var(--spacing) * 0);\n    translate: var(--tw-translate-x) var(--tw-translate-y);\n  }\n\n  .-rotate-90 {\n    rotate: -90deg;\n  }\n\n  .rotate-0 {\n    rotate: none;\n  }\n\n  .rotate-90 {\n    rotate: 90deg;\n  }\n\n  .rotate-180 {\n    rotate: 180deg;\n  }\n\n  .transform {\n    transform: var(--tw-rotate-x, ) var(--tw-rotate-y, ) var(--tw-rotate-z, ) var(--tw-skew-x, ) var(--tw-skew-y, );\n  }\n\n  .animate-fade-in {\n    animation: ease-in forwards fadeIn;\n  }\n\n  .\\!cursor-col-resize {\n    cursor: col-resize !important;\n  }\n\n  .cursor-e-resize {\n    cursor: e-resize;\n  }\n\n  .cursor-ew-resize {\n    cursor: ew-resize;\n    cursor: ew-resize;\n  }\n\n  .cursor-move {\n    cursor: move;\n    cursor: move;\n  }\n\n  .cursor-nesw-resize {\n    cursor: nesw-resize;\n    cursor: nesw-resize;\n  }\n\n  .cursor-ns-resize {\n    cursor: ns-resize;\n    cursor: ns-resize;\n  }\n\n  .cursor-nwse-resize {\n    cursor: nwse-resize;\n    cursor: nwse-resize;\n  }\n\n  .cursor-pointer {\n    cursor: pointer;\n  }\n\n  .cursor-w-resize {\n    cursor: w-resize;\n  }\n\n  .\\[touch-action\\:none\\] {\n    touch-action: none;\n  }\n\n  .resize {\n    resize: both;\n  }\n\n  .list-none {\n    list-style-type: none;\n  }\n\n  .grid-cols-1 {\n    grid-template-columns: repeat(1, minmax(0, 1fr));\n  }\n\n  .flex-col {\n    flex-direction: column;\n  }\n\n  .flex-row {\n    flex-direction: row;\n  }\n\n  .flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .items-center {\n    align-items: center;\n  }\n\n  .items-start {\n    align-items: flex-start;\n  }\n\n  .items-stretch {\n    align-items: stretch;\n  }\n\n  .justify-between {\n    justify-content: space-between;\n  }\n\n  .justify-center {\n    justify-content: center;\n  }\n\n  .justify-end {\n    justify-content: flex-end;\n  }\n\n  .justify-start {\n    justify-content: flex-start;\n  }\n\n  .gap-0\\.5 {\n    gap: calc(var(--spacing) * .5);\n  }\n\n  .gap-1 {\n    gap: calc(var(--spacing) * 1);\n  }\n\n  .gap-1\\.5 {\n    gap: calc(var(--spacing) * 1.5);\n  }\n\n  .gap-2 {\n    gap: calc(var(--spacing) * 2);\n  }\n\n  .gap-3 {\n    gap: calc(var(--spacing) * 3);\n  }\n\n  .gap-4 {\n    gap: calc(var(--spacing) * 4);\n  }\n\n  :where(.space-y-1 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-y-2 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-y-3 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 3) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-y-4 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-y-6 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-y-8 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 8) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 8) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  .gap-x-0\\.5 {\n    column-gap: calc(var(--spacing) * .5);\n  }\n\n  .gap-x-1 {\n    column-gap: calc(var(--spacing) * 1);\n  }\n\n  .gap-x-1\\.5 {\n    column-gap: calc(var(--spacing) * 1.5);\n  }\n\n  .gap-x-2 {\n    column-gap: calc(var(--spacing) * 2);\n  }\n\n  .gap-x-4 {\n    column-gap: calc(var(--spacing) * 4);\n  }\n\n  :where(.space-x-1 > :not(:last-child)) {\n    --tw-space-x-reverse: 0;\n    margin-inline-start: calc(calc(var(--spacing) * 1) * var(--tw-space-x-reverse));\n    margin-inline-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-x-reverse)));\n  }\n\n  :where(.space-x-2 > :not(:last-child)) {\n    --tw-space-x-reverse: 0;\n    margin-inline-start: calc(calc(var(--spacing) * 2) * var(--tw-space-x-reverse));\n    margin-inline-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-x-reverse)));\n  }\n\n  .gap-y-1 {\n    row-gap: calc(var(--spacing) * 1);\n  }\n\n  .gap-y-2 {\n    row-gap: calc(var(--spacing) * 2);\n  }\n\n  .place-self-center {\n    place-self: center;\n  }\n\n  .self-end {\n    align-self: flex-end;\n  }\n\n  .truncate {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden;\n  }\n\n  .\\!overflow-visible {\n    overflow: visible !important;\n  }\n\n  .overflow-auto {\n    overflow: auto;\n  }\n\n  .overflow-hidden {\n    overflow: hidden;\n  }\n\n  .overflow-x-hidden {\n    overflow-x: hidden;\n  }\n\n  .overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .overflow-y-scroll {\n    overflow-y: scroll;\n  }\n\n  .rounded {\n    border-radius: .25rem;\n  }\n\n  .rounded-full {\n    border-radius: 3.40282e38px;\n  }\n\n  .rounded-lg {\n    border-radius: var(--radius-lg);\n  }\n\n  .rounded-md {\n    border-radius: var(--radius-md);\n  }\n\n  .rounded-none {\n    border-radius: 0;\n  }\n\n  .rounded-sm {\n    border-radius: var(--radius-sm);\n  }\n\n  .rounded-xl {\n    border-radius: var(--radius-xl);\n  }\n\n  .rounded-t-lg {\n    border-top-left-radius: var(--radius-lg);\n    border-top-right-radius: var(--radius-lg);\n  }\n\n  .rounded-tl-lg {\n    border-top-left-radius: var(--radius-lg);\n  }\n\n  .rounded-tr-lg {\n    border-top-right-radius: var(--radius-lg);\n  }\n\n  .rounded-br-lg {\n    border-bottom-right-radius: var(--radius-lg);\n  }\n\n  .rounded-bl-lg {\n    border-bottom-left-radius: var(--radius-lg);\n  }\n\n  .border {\n    border-style: var(--tw-border-style);\n    border-width: 1px;\n  }\n\n  .border-0 {\n    border-style: var(--tw-border-style);\n    border-width: 0;\n  }\n\n  .border-2 {\n    border-style: var(--tw-border-style);\n    border-width: 2px;\n  }\n\n  .border-t {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 1px;\n  }\n\n  .border-b {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 1px;\n  }\n\n  .border-b-2 {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 2px;\n  }\n\n  .border-l, .border-l-1 {\n    border-left-style: var(--tw-border-style);\n    border-left-width: 1px;\n  }\n\n  .border-none {\n    --tw-border-style: none;\n    border-style: none;\n  }\n\n  .\\!border-red-500 {\n    border-color: var(--color-red-500) !important;\n  }\n\n  .border-\\[\\#1e1e1e\\] {\n    border-color: #1e1e1e;\n  }\n\n  .border-\\[\\#222\\] {\n    border-color: #222;\n  }\n\n  .border-\\[\\#333\\] {\n    border-color: #333;\n  }\n\n  .border-\\[\\#27272A\\] {\n    border-color: #27272a;\n  }\n\n  .border-blue-500 {\n    border-color: var(--color-blue-500);\n  }\n\n  .border-gray-600 {\n    border-color: var(--color-gray-600);\n  }\n\n  .border-gray-700\\/30 {\n    border-color: #3641534d;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .border-gray-700\\/30 {\n      border-color: color-mix(in oklab, var(--color-gray-700) 30%, transparent);\n    }\n  }\n\n  .border-gray-700\\/50 {\n    border-color: #36415380;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .border-gray-700\\/50 {\n      border-color: color-mix(in oklab, var(--color-gray-700) 50%, transparent);\n    }\n  }\n\n  .border-neutral-600 {\n    border-color: var(--color-neutral-600);\n  }\n\n  .border-red-500 {\n    border-color: var(--color-red-500);\n  }\n\n  .border-transparent {\n    border-color: #0000;\n  }\n\n  .bg-\\[\\#0d1117\\] {\n    background-color: #0d1117;\n  }\n\n  .bg-\\[\\#1E1E1E\\] {\n    background-color: #1e1e1e;\n  }\n\n  .bg-\\[\\#1a2a1a\\] {\n    background-color: #1a2a1a;\n  }\n\n  .bg-\\[\\#1e1e1e\\] {\n    background-color: #1e1e1e;\n  }\n\n  .bg-\\[\\#2a1515\\] {\n    background-color: #2a1515;\n  }\n\n  .bg-\\[\\#5f3f9a\\] {\n    background-color: #5f3f9a;\n  }\n\n  .bg-\\[\\#5f3f9a\\]\\/40 {\n    background-color: oklab(45.1275% .0635828 -.127792 / .4);\n  }\n\n  .bg-\\[\\#8e61e3\\] {\n    background-color: #8e61e3;\n  }\n\n  .bg-\\[\\#18181B\\] {\n    background-color: #18181b;\n  }\n\n  .bg-\\[\\#141414\\] {\n    background-color: #141414;\n  }\n\n  .bg-black {\n    background-color: var(--color-black);\n  }\n\n  .bg-black\\/40 {\n    background-color: #0006;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-black\\/40 {\n      background-color: color-mix(in oklab, var(--color-black) 40%, transparent);\n    }\n  }\n\n  .bg-blue-400 {\n    background-color: var(--color-blue-400);\n  }\n\n  .bg-blue-400\\/10 {\n    background-color: #54a2ff1a;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-blue-400\\/10 {\n      background-color: color-mix(in oklab, var(--color-blue-400) 10%, transparent);\n    }\n  }\n\n  .bg-blue-600 {\n    background-color: var(--color-blue-600);\n  }\n\n  .bg-brand-dark {\n    background-color: var(--color-brand-dark);\n  }\n\n  .bg-gray-400 {\n    background-color: var(--color-gray-400);\n  }\n\n  .bg-gray-500 {\n    background-color: var(--color-gray-500);\n  }\n\n  .bg-gray-800\\/30 {\n    background-color: #1e29394d;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-gray-800\\/30 {\n      background-color: color-mix(in oklab, var(--color-gray-800) 30%, transparent);\n    }\n  }\n\n  .bg-gray-800\\/50 {\n    background-color: #1e293980;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-gray-800\\/50 {\n      background-color: color-mix(in oklab, var(--color-gray-800) 50%, transparent);\n    }\n  }\n\n  .bg-green-400 {\n    background-color: var(--color-green-400);\n  }\n\n  .bg-green-400\\/10 {\n    background-color: #05df721a;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-green-400\\/10 {\n      background-color: color-mix(in oklab, var(--color-green-400) 10%, transparent);\n    }\n  }\n\n  .bg-neutral-600 {\n    background-color: var(--color-neutral-600);\n  }\n\n  .bg-neutral-700 {\n    background-color: var(--color-neutral-700);\n  }\n\n  .bg-orange-400\\/10 {\n    background-color: #ff8b1a1a;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-orange-400\\/10 {\n      background-color: color-mix(in oklab, var(--color-orange-400) 10%, transparent);\n    }\n  }\n\n  .bg-purple-400 {\n    background-color: var(--color-purple-400);\n  }\n\n  .bg-purple-800 {\n    background-color: var(--color-purple-800);\n  }\n\n  .bg-red-400 {\n    background-color: var(--color-red-400);\n  }\n\n  .bg-red-500 {\n    background-color: var(--color-red-500);\n  }\n\n  .bg-red-600 {\n    background-color: var(--color-red-600);\n  }\n\n  .bg-red-950\\/50 {\n    background-color: #46080980;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-red-950\\/50 {\n      background-color: color-mix(in oklab, var(--color-red-950) 50%, transparent);\n    }\n  }\n\n  .bg-transparent {\n    background-color: #0000;\n  }\n\n  .bg-wash-dark {\n    background-color: var(--color-wash-dark);\n  }\n\n  .bg-white {\n    background-color: var(--color-white);\n  }\n\n  .bg-yellow-300 {\n    background-color: var(--color-yellow-300);\n  }\n\n  .bg-yellow-400 {\n    background-color: var(--color-yellow-400);\n  }\n\n  .bg-yellow-400\\/10 {\n    background-color: #fac8001a;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .bg-yellow-400\\/10 {\n      background-color: color-mix(in oklab, var(--color-yellow-400) 10%, transparent);\n    }\n  }\n\n  .object-cover {\n    object-fit: cover;\n  }\n\n  .p-0 {\n    padding: calc(var(--spacing) * 0);\n  }\n\n  .p-2 {\n    padding: calc(var(--spacing) * 2);\n  }\n\n  .p-3 {\n    padding: calc(var(--spacing) * 3);\n  }\n\n  .p-4 {\n    padding: calc(var(--spacing) * 4);\n  }\n\n  .p-6 {\n    padding: calc(var(--spacing) * 6);\n  }\n\n  .p-8 {\n    padding: calc(var(--spacing) * 8);\n  }\n\n  .px-1 {\n    padding-inline: calc(var(--spacing) * 1);\n  }\n\n  .px-1\\.5 {\n    padding-inline: calc(var(--spacing) * 1.5);\n  }\n\n  .px-2 {\n    padding-inline: calc(var(--spacing) * 2);\n  }\n\n  .px-3 {\n    padding-inline: calc(var(--spacing) * 3);\n  }\n\n  .px-4 {\n    padding-inline: calc(var(--spacing) * 4);\n  }\n\n  .py-1 {\n    padding-block: calc(var(--spacing) * 1);\n  }\n\n  .py-1\\.5 {\n    padding-block: calc(var(--spacing) * 1.5);\n  }\n\n  .py-2 {\n    padding-block: calc(var(--spacing) * 2);\n  }\n\n  .py-\\[1px\\] {\n    padding-block: 1px;\n  }\n\n  .py-\\[3px\\] {\n    padding-block: 3px;\n  }\n\n  .pt-1 {\n    padding-top: calc(var(--spacing) * 1);\n  }\n\n  .pt-2 {\n    padding-top: calc(var(--spacing) * 2);\n  }\n\n  .pt-4 {\n    padding-top: calc(var(--spacing) * 4);\n  }\n\n  .pr-1\\.5 {\n    padding-right: calc(var(--spacing) * 1.5);\n  }\n\n  .pr-2 {\n    padding-right: calc(var(--spacing) * 2);\n  }\n\n  .pr-2\\.5 {\n    padding-right: calc(var(--spacing) * 2.5);\n  }\n\n  .pb-18 {\n    padding-bottom: calc(var(--spacing) * 18);\n  }\n\n  .pl-1 {\n    padding-left: calc(var(--spacing) * 1);\n  }\n\n  .pl-2 {\n    padding-left: calc(var(--spacing) * 2);\n  }\n\n  .pl-3 {\n    padding-left: calc(var(--spacing) * 3);\n  }\n\n  .pl-5 {\n    padding-left: calc(var(--spacing) * 5);\n  }\n\n  .pl-6 {\n    padding-left: calc(var(--spacing) * 6);\n  }\n\n  .text-center {\n    text-align: center;\n  }\n\n  .text-left {\n    text-align: left;\n  }\n\n  .font-display {\n    font-family: var(--font-display);\n  }\n\n  .font-mono {\n    font-family: var(--font-mono);\n  }\n\n  .font-text {\n    font-family: var(--font-text);\n  }\n\n  .text-lg {\n    font-size: var(--text-lg);\n    line-height: var(--tw-leading, var(--text-lg--line-height));\n  }\n\n  .text-sm {\n    font-size: var(--text-sm);\n    line-height: var(--tw-leading, var(--text-sm--line-height));\n  }\n\n  .text-xl {\n    font-size: var(--text-xl);\n    line-height: var(--tw-leading, var(--text-xl--line-height));\n  }\n\n  .text-xs {\n    font-size: var(--text-xs);\n    line-height: var(--tw-leading, var(--text-xs--line-height));\n  }\n\n  .text-\\[10px\\] {\n    font-size: 10px;\n  }\n\n  .text-\\[11px\\] {\n    font-size: 11px;\n  }\n\n  .text-\\[13px\\] {\n    font-size: 13px;\n  }\n\n  .leading-none {\n    --tw-leading: 1;\n    line-height: 1;\n  }\n\n  .leading-relaxed {\n    --tw-leading: var(--leading-relaxed);\n    line-height: var(--leading-relaxed);\n  }\n\n  .leading-snug {\n    --tw-leading: var(--leading-snug);\n    line-height: var(--leading-snug);\n  }\n\n  .font-bold {\n    --tw-font-weight: var(--font-weight-bold);\n    font-weight: var(--font-weight-bold);\n  }\n\n  .font-medium {\n    --tw-font-weight: var(--font-weight-medium);\n    font-weight: var(--font-weight-medium);\n  }\n\n  .font-semibold {\n    --tw-font-weight: var(--font-weight-semibold);\n    font-weight: var(--font-weight-semibold);\n  }\n\n  .tracking-wide {\n    --tw-tracking: var(--tracking-wide);\n    letter-spacing: var(--tracking-wide);\n  }\n\n  .break-words {\n    overflow-wrap: break-word;\n  }\n\n  .break-all {\n    word-break: break-all;\n  }\n\n  .whitespace-nowrap {\n    white-space: nowrap;\n  }\n\n  .whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n\n  .\\!text-white {\n    color: var(--color-white) !important;\n  }\n\n  .text-\\[\\#4ade80\\] {\n    color: #4ade80;\n  }\n\n  .text-\\[\\#6F6F78\\] {\n    color: #6f6f78;\n  }\n\n  .text-\\[\\#666\\] {\n    color: #666;\n  }\n\n  .text-\\[\\#888\\] {\n    color: #888;\n  }\n\n  .text-\\[\\#737373\\] {\n    color: #737373;\n  }\n\n  .text-\\[\\#A855F7\\] {\n    color: #a855f7;\n  }\n\n  .text-\\[\\#f87171\\] {\n    color: #f87171;\n  }\n\n  .text-black {\n    color: var(--color-black);\n  }\n\n  .text-blue-400 {\n    color: var(--color-blue-400);\n  }\n\n  .text-blue-600 {\n    color: var(--color-blue-600);\n  }\n\n  .text-brand-dark {\n    color: var(--color-brand-dark);\n  }\n\n  .text-gray-300 {\n    color: var(--color-gray-300);\n  }\n\n  .text-gray-400 {\n    color: var(--color-gray-400);\n  }\n\n  .text-gray-500 {\n    color: var(--color-gray-500);\n  }\n\n  .text-green-400 {\n    color: var(--color-green-400);\n  }\n\n  .text-green-500 {\n    color: var(--color-green-500);\n  }\n\n  .text-neutral-300 {\n    color: var(--color-neutral-300);\n  }\n\n  .text-neutral-400 {\n    color: var(--color-neutral-400);\n  }\n\n  .text-neutral-500 {\n    color: var(--color-neutral-500);\n  }\n\n  .text-orange-400 {\n    color: var(--color-orange-400);\n  }\n\n  .text-purple-400 {\n    color: var(--color-purple-400);\n  }\n\n  .text-red-300 {\n    color: var(--color-red-300);\n  }\n\n  .text-red-400 {\n    color: var(--color-red-400);\n  }\n\n  .text-red-500 {\n    color: var(--color-red-500);\n  }\n\n  .text-white {\n    color: var(--color-white);\n  }\n\n  .text-white\\/30 {\n    color: #ffffff4d;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .text-white\\/30 {\n      color: color-mix(in oklab, var(--color-white) 30%, transparent);\n    }\n  }\n\n  .text-yellow-300 {\n    color: var(--color-yellow-300);\n  }\n\n  .text-yellow-400 {\n    color: var(--color-yellow-400);\n  }\n\n  .text-yellow-500 {\n    color: var(--color-yellow-500);\n  }\n\n  .capitalize {\n    text-transform: capitalize;\n  }\n\n  .lowercase {\n    text-transform: lowercase;\n  }\n\n  .uppercase {\n    text-transform: uppercase;\n  }\n\n  .italic {\n    font-style: italic;\n  }\n\n  .opacity-0 {\n    opacity: 0;\n  }\n\n  .opacity-50 {\n    opacity: .5;\n  }\n\n  .opacity-100 {\n    opacity: 1;\n  }\n\n  .shadow {\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, #0000001a), 0 1px 2px -1px var(--tw-shadow-color, #0000001a);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .shadow-lg {\n    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, #0000001a), 0 4px 6px -4px var(--tw-shadow-color, #0000001a);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .ring-0 {\n    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .ring-1 {\n    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .ring-white\\/\\[0\\.08\\] {\n    --tw-ring-color: #ffffff14;\n  }\n\n  @supports (color: color-mix(in lab, red, red)) {\n    .ring-white\\/\\[0\\.08\\] {\n      --tw-ring-color: color-mix(in oklab, var(--color-white) 8%, transparent);\n    }\n  }\n\n  .outline {\n    outline-style: var(--tw-outline-style);\n    outline-width: 1px;\n  }\n\n  .blur {\n    --tw-blur: blur(8px);\n    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );\n  }\n\n  .filter {\n    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );\n  }\n\n  .backdrop-blur-sm {\n    --tw-backdrop-blur: blur(var(--blur-sm));\n    -webkit-backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );\n    backdrop-filter: var(--tw-backdrop-blur, ) var(--tw-backdrop-brightness, ) var(--tw-backdrop-contrast, ) var(--tw-backdrop-grayscale, ) var(--tw-backdrop-hue-rotate, ) var(--tw-backdrop-invert, ) var(--tw-backdrop-opacity, ) var(--tw-backdrop-saturate, ) var(--tw-backdrop-sepia, );\n  }\n\n  .transition {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, visibility, content-visibility, overlay, pointer-events;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-\\[border-radius\\] {\n    transition-property: border-radius;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-\\[color\\,transform\\] {\n    transition-property: color, transform;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-\\[max-height\\] {\n    transition-property: max-height;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-\\[opacity\\] {\n    transition-property: opacity;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-all {\n    transition-property: all;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-opacity {\n    transition-property: opacity;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-transform {\n    transition-property: transform, translate, scale, rotate;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .delay-0 {\n    transition-delay: 0s;\n  }\n\n  .delay-150 {\n    transition-delay: .15s;\n  }\n\n  .\\!duration-0 {\n    --tw-duration: 0s !important;\n    transition-duration: 0s !important;\n  }\n\n  .duration-0 {\n    --tw-duration: 0s;\n    transition-duration: 0s;\n  }\n\n  .duration-200 {\n    --tw-duration: .2s;\n    transition-duration: .2s;\n  }\n\n  .duration-300 {\n    --tw-duration: .3s;\n    transition-duration: .3s;\n  }\n\n  .ease-\\[cubic-bezier\\(0\\.25\\,0\\.1\\,0\\.25\\,1\\)\\] {\n    --tw-ease: cubic-bezier(.25, .1, .25, 1);\n    transition-timing-function: ease;\n  }\n\n  .ease-in {\n    --tw-ease: var(--ease-in);\n    transition-timing-function: var(--ease-in);\n  }\n\n  .ease-in-out {\n    --tw-ease: var(--ease-in-out);\n    transition-timing-function: var(--ease-in-out);\n  }\n\n  .ease-out {\n    --tw-ease: var(--ease-out);\n    transition-timing-function: var(--ease-out);\n  }\n\n  .will-change-transform {\n    will-change: transform;\n  }\n\n  .select-none {\n    -webkit-user-select: none;\n    user-select: none;\n  }\n\n  .animation-delay-0 {\n    animation-delay: 0s;\n  }\n\n  .animation-delay-100 {\n    animation-delay: .1s;\n  }\n\n  .animation-delay-150 {\n    animation-delay: .15s;\n  }\n\n  .animation-delay-200 {\n    animation-delay: .2s;\n  }\n\n  .animation-delay-300 {\n    animation-delay: .3s;\n  }\n\n  .animation-delay-500 {\n    animation-delay: .5s;\n  }\n\n  .animation-delay-700 {\n    animation-delay: .7s;\n  }\n\n  .animation-delay-1000 {\n    animation-delay: 1s;\n  }\n\n  .animation-duration-0 {\n    animation-duration: 0s;\n  }\n\n  .animation-duration-100 {\n    animation-duration: .1s;\n  }\n\n  .animation-duration-200 {\n    animation-duration: .2s;\n  }\n\n  .animation-duration-300 {\n    animation-duration: .3s;\n  }\n\n  .animation-duration-500 {\n    animation-duration: .5s;\n  }\n\n  .animation-duration-700 {\n    animation-duration: .7s;\n  }\n\n  .animation-duration-1000 {\n    animation-duration: 1s;\n  }\n\n  @media (hover: hover) {\n    .group-hover\\:bg-brand-dark:is(:where(.group):hover *) {\n      background-color: var(--color-brand-dark);\n    }\n\n    .group-hover\\:opacity-100:is(:where(.group):hover *) {\n      opacity: 1;\n    }\n\n    .peer-hover\\/bottom\\:rounded-b-none:is(:where(.peer\\/bottom):hover ~ *) {\n      border-bottom-right-radius: 0;\n      border-bottom-left-radius: 0;\n    }\n\n    .peer-hover\\/left\\:rounded-l-none:is(:where(.peer\\/left):hover ~ *) {\n      border-top-left-radius: 0;\n      border-bottom-left-radius: 0;\n    }\n\n    .peer-hover\\/right\\:rounded-r-none:is(:where(.peer\\/right):hover ~ *) {\n      border-top-right-radius: 0;\n      border-bottom-right-radius: 0;\n    }\n\n    .peer-hover\\/top\\:rounded-t-none:is(:where(.peer\\/top):hover ~ *) {\n      border-top-left-radius: 0;\n      border-top-right-radius: 0;\n    }\n  }\n\n  .placeholder\\:text-neutral-500::placeholder {\n    color: var(--color-neutral-500);\n  }\n\n  .last\\:border-b-0:last-child {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 0;\n  }\n\n  .focus-within\\:border-\\[\\#454545\\]:focus-within {\n    border-color: #454545;\n  }\n\n  @media (hover: hover) {\n    .hover\\:border-blue-400\\/30:hover {\n      border-color: #54a2ff4d;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      .hover\\:border-blue-400\\/30:hover {\n        border-color: color-mix(in oklab, var(--color-blue-400) 30%, transparent);\n      }\n    }\n\n    .hover\\:border-green-400\\/30:hover {\n      border-color: #05df724d;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      .hover\\:border-green-400\\/30:hover {\n        border-color: color-mix(in oklab, var(--color-green-400) 30%, transparent);\n      }\n    }\n\n    .hover\\:border-purple-400\\/30:hover {\n      border-color: #c07eff4d;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      .hover\\:border-purple-400\\/30:hover {\n        border-color: color-mix(in oklab, var(--color-purple-400) 30%, transparent);\n      }\n    }\n\n    .hover\\:border-red-400\\/30:hover {\n      border-color: #ff65684d;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      .hover\\:border-red-400\\/30:hover {\n        border-color: color-mix(in oklab, var(--color-red-400) 30%, transparent);\n      }\n    }\n\n    .hover\\:border-yellow-400\\/30:hover {\n      border-color: #fac8004d;\n    }\n\n    @supports (color: color-mix(in lab, red, red)) {\n      .hover\\:border-yellow-400\\/30:hover {\n        border-color: color-mix(in oklab, var(--color-yellow-400) 30%, transparent);\n      }\n    }\n\n    .hover\\:bg-\\[\\#5f3f9a\\]\\/20:hover {\n      background-color: oklab(45.1275% .0635828 -.127792 / .2);\n    }\n\n    .hover\\:bg-\\[\\#5f3f9a\\]\\/40:hover {\n      background-color: oklab(45.1275% .0635828 -.127792 / .4);\n    }\n\n    .hover\\:bg-\\[\\#34343b\\]:hover {\n      background-color: #34343b;\n    }\n\n    .hover\\:bg-gray-700:hover {\n      background-color: var(--color-gray-700);\n    }\n\n    .hover\\:bg-neutral-800:hover {\n      background-color: var(--color-neutral-800);\n    }\n\n    .hover\\:bg-red-600:hover {\n      background-color: var(--color-red-600);\n    }\n\n    .hover\\:bg-red-700:hover {\n      background-color: var(--color-red-700);\n    }\n\n    .hover\\:text-neutral-300:hover {\n      color: var(--color-neutral-300);\n    }\n\n    .hover\\:text-white:hover {\n      color: var(--color-white);\n    }\n  }\n\n  .focus\\:z-10:focus {\n    z-index: 10;\n  }\n\n  .focus\\:border-neutral-400:focus {\n    border-color: var(--color-neutral-400);\n  }\n\n  .focus\\:border-red-500:focus {\n    border-color: var(--color-red-500);\n  }\n\n  .focus\\:ring-1:focus {\n    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .focus\\:ring-blue-400:focus {\n    --tw-ring-color: var(--color-blue-400);\n  }\n\n  .focus\\:ring-blue-600:focus {\n    --tw-ring-color: var(--color-blue-600);\n  }\n\n  .focus\\:ring-neutral-400:focus {\n    --tw-ring-color: var(--color-neutral-400);\n  }\n\n  .focus\\:ring-red-500:focus {\n    --tw-ring-color: var(--color-red-500);\n  }\n\n  .focus\\:ring-offset-0:focus {\n    --tw-ring-offset-width: 0px;\n    --tw-ring-offset-shadow: var(--tw-ring-inset, ) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\n  }\n\n  .focus\\:outline-none:focus {\n    --tw-outline-style: none;\n    outline-style: none;\n  }\n\n  .focus-visible\\:ring-1:focus-visible {\n    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .focus-visible\\:ring-neutral-400:focus-visible {\n    --tw-ring-color: var(--color-neutral-400);\n  }\n\n  .focus-visible\\:outline-none:focus-visible {\n    --tw-outline-style: none;\n    outline-style: none;\n  }\n\n  .disabled\\:pointer-events-none:disabled {\n    pointer-events: none;\n  }\n\n  .disabled\\:cursor-not-allowed:disabled {\n    cursor: not-allowed;\n  }\n\n  .disabled\\:opacity-50:disabled {\n    opacity: .5;\n  }\n\n  @media (min-width: 48rem) {\n    .md\\:grid-cols-2 {\n      grid-template-columns: repeat(2, minmax(0, 1fr));\n    }\n  }\n\n  @media (min-width: 64rem) {\n    .lg\\:grid-cols-3 {\n      grid-template-columns: repeat(3, minmax(0, 1fr));\n    }\n  }\n\n  @media (min-width: 80rem) {\n    .xl\\:grid-cols-4 {\n      grid-template-columns: repeat(4, minmax(0, 1fr));\n    }\n  }\n\n  @media (min-width: 96rem) {\n    .\\32 xl\\:grid-cols-5 {\n      grid-template-columns: repeat(5, minmax(0, 1fr));\n    }\n  }\n\n  .\\[\\&\\:\\:-webkit-details-marker\\]\\:hidden::-webkit-details-marker {\n    display: none;\n  }\n\n  details[open] .\\[details\\[open\\]_\\&\\]\\:rotate-90 {\n    rotate: 90deg;\n  }\n}\n\n* {\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  backface-visibility: hidden;\n  outline: none !important;\n}\n\n::-webkit-scrollbar {\n  width: 6px;\n  height: 6px;\n}\n\n::-webkit-scrollbar-track {\n  background: none;\n  border-radius: 10px;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #ffffff4d;\n  border-radius: 10px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #fff6;\n}\n\n::-webkit-scrollbar-corner {\n  background: none;\n}\n\n@-moz-document url-prefix() {\n  * {\n    scrollbar-width: thin;\n    scrollbar-color: #fff6 transparent;\n    scrollbar-width: 6px;\n  }\n}\n\n@media (hover: hover) {\n  button:hover {\n    background-image: none;\n  }\n}\n\nbutton {\n  --tw-outline-style: none;\n  --tw-border-style: none;\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-ease: linear;\n  cursor: pointer;\n  border-style: none;\n  outline-style: none;\n  transition-timing-function: linear;\n}\n\ninput {\n  --tw-outline-style: none;\n  --tw-border-style: none;\n  background-color: #0000;\n  background-image: none;\n  border-style: none;\n  outline-style: none;\n}\n\ninput::placeholder {\n  font-size: var(--text-xs);\n  line-height: var(--tw-leading, var(--text-xs--line-height));\n  color: var(--color-neutral-500);\n  font-style: italic;\n}\n\ninput:placeholder-shown {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\nhr {\n  --tw-border-style: none;\n  background-color: var(--color-neutral-700);\n  height: 1px;\n  margin-block: calc(var(--spacing) * 2);\n  opacity: .6;\n  border-style: none;\n}\n\nsvg {\n  pointer-events: none;\n}\n\n.with-data-text {\n  overflow: hidden;\n}\n\n.with-data-text:before {\n  content: attr(data-text);\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  display: block;\n  overflow: hidden;\n}\n\n#react-devtool-toolbar {\n  top: calc(var(--spacing) * 0);\n  left: calc(var(--spacing) * 0);\n  --tw-shadow: 0 4px 12px var(--tw-shadow-color, #0003);\n  box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  font-family: var(--font-mono);\n  color: var(--color-white);\n  background-color: var(--color-wash-dark);\n  -webkit-user-select: none;\n  user-select: none;\n  cursor: move;\n  cursor: move;\n  opacity: 0;\n  z-index: 2147483647;\n  box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  backface-visibility: hidden;\n  perspective: 1000px;\n  -webkit-transform-style: preserve-3d;\n  transform-style: preserve-3d;\n  flex-direction: column;\n  place-self: start;\n  font-size: 13px;\n  animation: .3s ease-in .3s forwards fadeIn;\n  display: flex;\n  position: fixed;\n  transform: translate3d(0, 0, 0);\n}\n\n.button:hover {\n  background: #ffffff1a;\n}\n\n.button:active {\n  background: #ffffff26;\n}\n\n.resize-line-wrapper {\n  position: absolute;\n  overflow: hidden;\n}\n\n.resize-line {\n  inset: calc(var(--spacing) * 0);\n  background-color: var(--color-black);\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  position: absolute;\n  overflow: hidden;\n}\n\n.resize-line svg {\n  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n\n.resize-right, .resize-left {\n  inset-block: calc(var(--spacing) * 0);\n  width: calc(var(--spacing) * 6);\n  cursor: ew-resize;\n  cursor: ew-resize;\n}\n\n:is(.resize-right, .resize-left) .resize-line-wrapper {\n  inset-block: calc(var(--spacing) * 0);\n  width: 50%;\n}\n\n:is(.resize-right, .resize-left):hover .resize-line {\n  --tw-translate-x: calc(var(--spacing) * 0);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-right {\n  right: calc(var(--spacing) * 0);\n  --tw-translate-x: calc(1 / 2 * 100%);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-right .resize-line-wrapper {\n  right: calc(var(--spacing) * 0);\n}\n\n.resize-right .resize-line {\n  border-top-right-radius: var(--radius-lg);\n  border-bottom-right-radius: var(--radius-lg);\n  --tw-translate-x: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-left {\n  left: calc(var(--spacing) * 0);\n  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-left .resize-line-wrapper {\n  left: calc(var(--spacing) * 0);\n}\n\n.resize-left .resize-line {\n  border-top-left-radius: var(--radius-lg);\n  border-bottom-left-radius: var(--radius-lg);\n  --tw-translate-x: 100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-top, .resize-bottom {\n  inset-inline: calc(var(--spacing) * 0);\n  height: calc(var(--spacing) * 6);\n  cursor: ns-resize;\n  cursor: ns-resize;\n}\n\n:is(.resize-top, .resize-bottom) .resize-line-wrapper {\n  inset-inline: calc(var(--spacing) * 0);\n  height: 50%;\n}\n\n:is(.resize-top, .resize-bottom):hover .resize-line {\n  --tw-translate-y: calc(var(--spacing) * 0);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-top {\n  top: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-top .resize-line-wrapper {\n  top: calc(var(--spacing) * 0);\n}\n\n.resize-top .resize-line {\n  border-top-left-radius: var(--radius-lg);\n  border-top-right-radius: var(--radius-lg);\n  --tw-translate-y: 100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-bottom {\n  bottom: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(1 / 2 * 100%);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.resize-bottom .resize-line-wrapper {\n  bottom: calc(var(--spacing) * 0);\n}\n\n.resize-bottom .resize-line {\n  border-bottom-right-radius: var(--radius-lg);\n  border-bottom-left-radius: var(--radius-lg);\n  --tw-translate-y: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.react-devtool-header {\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  padding-right: calc(var(--spacing) * 2);\n  padding-left: calc(var(--spacing) * 3);\n  min-height: calc(var(--spacing) * 9);\n  border-bottom-style: var(--tw-border-style);\n  white-space: nowrap;\n  border-color: #222;\n  border-bottom-width: 1px;\n  display: flex;\n  overflow: hidden;\n}\n\n.react-devtool-replay-button, .react-devtool-close-button {\n  padding: calc(var(--spacing) * 1);\n  min-width: fit-content;\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  border-radius: .25rem;\n  align-items: center;\n  transition-duration: .3s;\n  display: flex;\n}\n\n.react-devtool-replay-button {\n  position: relative;\n  overflow: hidden;\n  background-color: #ac4bff80 !important;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-replay-button {\n    background-color: color-mix(in oklab, var(--color-purple-500) 50%, transparent) !important;\n  }\n}\n\n.react-devtool-replay-button:hover {\n  background-color: #ac4bff40;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-replay-button:hover {\n    background-color: color-mix(in oklab, var(--color-purple-500) 25%, transparent);\n  }\n}\n\n.react-devtool-replay-button.disabled {\n  opacity: .5;\n  pointer-events: none;\n}\n\n.react-devtool-replay-button:before {\n  content: \"\";\n  inset: calc(var(--spacing) * 0);\n  --tw-translate-x: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  background: linear-gradient(to right, #0000, #8e61e34d, #0000);\n  animation: 2s infinite shimmer;\n  position: absolute;\n}\n\n.react-devtool-close-button {\n  background-color: #ffffff1a;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-close-button {\n    background-color: color-mix(in oklab, var(--color-white) 10%, transparent);\n  }\n}\n\n.react-devtool-close-button:hover {\n  background-color: #ffffff26;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-close-button:hover {\n    background-color: color-mix(in oklab, var(--color-white) 15%, transparent);\n  }\n}\n\n.react-section-header {\n  z-index: 100;\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  height: calc(var(--spacing) * 7);\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: #888;\n  border-bottom-style: var(--tw-border-style);\n  background-color: #0a0a0a;\n  border-color: #222;\n  border-bottom-width: 1px;\n  width: 100%;\n  display: flex;\n  position: sticky;\n  overflow: hidden;\n}\n\n.react-devtool-section {\n  padding-inline: calc(var(--spacing) * 2);\n  color: #888;\n  flex-direction: column;\n  display: flex;\n}\n\n.react-devtool-section:before {\n  content: var(--tw-content);\n  color: var(--color-gray-500);\n  content: var(--tw-content);\n  --tw-content: attr(data-section);\n  content: var(--tw-content);\n}\n\n.react-devtool-section {\n  font-size: var(--text-xs);\n  line-height: var(--tw-leading, var(--text-xs--line-height));\n}\n\n.react-devtool-section > .react-devtool-property {\n  margin-left: -.875rem;\n}\n\n.react-devtool-property {\n  padding-left: calc(var(--spacing) * 8);\n  border-left-style: var(--tw-border-style);\n  border-color: #0000;\n  border-left-width: 1px;\n  flex-direction: column;\n  display: flex;\n  position: relative;\n  overflow: hidden;\n}\n\n.react-devtool-property-content {\n  min-height: calc(var(--spacing) * 7);\n  flex-direction: column;\n  flex: 1;\n  max-width: 100%;\n  display: flex;\n  overflow: hidden;\n}\n\n.react-devtool-string {\n  color: #9ecbff;\n}\n\n.react-devtool-number {\n  color: #79c7ff;\n}\n\n.react-devtool-boolean {\n  color: #56b6c2;\n}\n\n.react-devtool-key {\n  width: fit-content;\n  max-width: calc(var(--spacing) * 60);\n  white-space: nowrap;\n  color: var(--color-white);\n}\n\n.react-devtool-input {\n  color: var(--color-white);\n  background-color: var(--color-black);\n}\n\n.react-devtool-arrow {\n  top: calc(var(--spacing) * 0);\n  left: calc(var(--spacing) * 7);\n  cursor: pointer;\n  height: calc(var(--spacing) * 7);\n  width: calc(var(--spacing) * 6);\n  --tw-translate-x: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  z-index: 10;\n  justify-content: center;\n  align-items: center;\n  display: flex;\n  position: absolute;\n}\n\n.react-devtool-arrow > svg {\n  transition-property: transform, translate, scale, rotate;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n}\n\n.react-devtool-expandable {\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: 75ms;\n  grid-template-rows: 0fr;\n  transition-duration: 75ms;\n  display: grid;\n}\n\n.react-devtool-expandable.react-devtool-expanded {\n  --tw-duration: .1s;\n  grid-template-rows: 1fr;\n  transition-duration: .1s;\n}\n\n.react-devtool-nested {\n  position: relative;\n  overflow: hidden;\n}\n\n.react-devtool-nested:before {\n  content: \"\";\n  top: calc(var(--spacing) * 0);\n  left: calc(var(--spacing) * 0);\n  background-color: #6a72824d;\n  width: 1px;\n  height: 100%;\n  position: absolute;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-nested:before {\n    background-color: color-mix(in oklab, var(--color-gray-500) 30%, transparent);\n  }\n}\n\n.react-devtool-settings {\n  inset: calc(var(--spacing) * 0);\n  gap: calc(var(--spacing) * 4);\n  padding-inline: calc(var(--spacing) * 4);\n  padding-block: calc(var(--spacing) * 2);\n  color: #888;\n  flex-direction: column;\n  display: flex;\n  position: absolute;\n}\n\n.react-devtool-settings > div {\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  justify-content: space-between;\n  align-items: center;\n  transition-duration: .3s;\n  display: flex;\n}\n\n.react-devtool-preview-line {\n  min-height: calc(var(--spacing) * 7);\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  display: flex;\n  position: relative;\n}\n\n.react-devtool-flash-overlay {\n  inset: calc(var(--spacing) * 0);\n  opacity: 0;\n  z-index: 50;\n  pointer-events: none;\n  transition-property: opacity;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  mix-blend-mode: multiply;\n  background-color: var(--color-brand-dark);\n  color: var(--color-secondary);\n  position: absolute;\n}\n\n.react-devtool-toggle {\n  height: calc(var(--spacing) * 6);\n  width: calc(var(--spacing) * 10);\n  display: inline-flex;\n  position: relative;\n}\n\n.react-devtool-toggle input {\n  inset: calc(var(--spacing) * 0);\n  z-index: 20;\n  opacity: 0;\n  cursor: pointer;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n}\n\n.react-devtool-toggle input:checked + div {\n  background-color: #5f3f9a;\n}\n\n.react-devtool-toggle input:checked + div:before {\n  --tw-translate-x: 100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  border-color: #5f3f9a;\n  left: auto;\n}\n\n.react-devtool-toggle > div {\n  inset: calc(var(--spacing) * 1);\n  background-color: var(--color-neutral-700);\n  pointer-events: none;\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  border-radius: 3.40282e38px;\n  transition-duration: .3s;\n  position: absolute;\n}\n\n.react-devtool-toggle > div:before {\n  --tw-translate-x: 0px;\n  --tw-content: \"\";\n  content: var(--tw-content);\n  top: 50%;\n  left: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  height: calc(var(--spacing) * 4);\n  width: calc(var(--spacing) * 4);\n  background-color: var(--color-white);\n  border-style: var(--tw-border-style);\n  border-width: 2px;\n  border-color: var(--color-neutral-700);\n  --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, #0000001a), 0 1px 2px -1px var(--tw-shadow-color, #0000001a);\n  box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  border-radius: 3.40282e38px;\n  transition-duration: .3s;\n  position: absolute;\n}\n\n.react-devtool-flash-active {\n  opacity: .4;\n  transition-property: opacity;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  transition-duration: .3s;\n}\n\n.react-devtool-inspector-overlay {\n  opacity: 0;\n  transition-property: opacity;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  flex-direction: column;\n  transition-duration: .3s;\n  display: flex;\n}\n\n.react-devtool-inspector-overlay.fade-out {\n  opacity: 0;\n}\n\n.react-devtool-inspector-overlay.fade-in {\n  opacity: 1;\n}\n\n.react-devtool-what-changed ul {\n  padding-left: calc(var(--spacing) * 4);\n  list-style-type: disc;\n}\n\n.react-devtool-what-changed li {\n  white-space: nowrap;\n}\n\n.react-devtool-what-changed li > div {\n  justify-content: space-between;\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  display: flex;\n}\n\n.count-badge {\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  padding-inline: calc(var(--spacing) * 1.5);\n  padding-block: calc(var(--spacing) * .5);\n  transform-origin: center;\n  font-size: var(--text-xs);\n  line-height: var(--tw-leading, var(--text-xs--line-height));\n  --tw-font-weight: var(--font-weight-medium);\n  font-weight: var(--font-weight-medium);\n  color: #a855f7;\n  --tw-numeric-spacing: tabular-nums;\n  font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  background-color: oklab(62.6846% .129701 -.193012 / .1);\n  border-radius: 4px;\n  transition-duration: .3s;\n  transition-delay: .15s;\n  display: flex;\n}\n\n.count-flash {\n  animation: .3s ease-out forwards countFlash;\n}\n\n.count-flash-white {\n  animation: .3s ease-out forwards countFlashShake;\n  transition-delay: .5s !important;\n}\n\n.change-scope {\n  align-items: center;\n  column-gap: calc(var(--spacing) * 1);\n  color: #666;\n  font-size: var(--text-xs);\n  line-height: var(--tw-leading, var(--text-xs--line-height));\n  font-family: var(--font-mono);\n  display: flex;\n}\n\n.change-scope > div {\n  padding-inline: calc(var(--spacing) * 1.5);\n  padding-block: calc(var(--spacing) * .5);\n  transform-origin: center;\n  font-size: var(--text-xs);\n  line-height: var(--tw-leading, var(--text-xs--line-height));\n  --tw-font-weight: var(--font-weight-medium);\n  font-weight: var(--font-weight-medium);\n  --tw-numeric-spacing: tabular-nums;\n  font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  border-radius: 4px;\n  transition-duration: .3s;\n  transition-delay: .15s;\n}\n\n.change-scope > div[data-flash=\"true\"] {\n  color: #a855f7;\n  background-color: oklab(62.6846% .129701 -.193012 / .1);\n}\n\n.react-devtool-slider {\n  min-height: calc(var(--spacing) * 6);\n  position: relative;\n}\n\n.react-devtool-slider > input {\n  inset: calc(var(--spacing) * 0);\n  opacity: 0;\n  position: absolute;\n}\n\n.react-devtool-slider:before {\n  --tw-content: \"\";\n  content: var(--tw-content);\n  inset-inline: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  height: calc(var(--spacing) * 1.5);\n  border-radius: var(--radius-lg);\n  pointer-events: none;\n  background-color: oklab(60.2737% .0837533 -.170212 / .4);\n  position: absolute;\n  top: 50%;\n}\n\n.react-devtool-slider:after {\n  --tw-content: \"\";\n  content: var(--tw-content);\n  inset-inline: calc(var(--spacing) * 0);\n  inset-block: calc(var(--spacing) * -2);\n  z-index: calc(10 * -1);\n  position: absolute;\n}\n\n.react-devtool-slider span {\n  top: 50%;\n  left: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  height: calc(var(--spacing) * 2.5);\n  width: calc(var(--spacing) * 2.5);\n  border-radius: var(--radius-lg);\n  pointer-events: none;\n  transition-property: transform, translate, scale, rotate;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: 75ms;\n  background-color: #8e61e3;\n  transition-duration: 75ms;\n  position: absolute;\n}\n\n.resize-v-line {\n  max-width: calc(var(--spacing) * 1);\n  min-width: calc(var(--spacing) * 1);\n  width: 100%;\n  height: 100%;\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  justify-content: center;\n  align-items: center;\n  display: flex;\n}\n\n:is(.resize-v-line:hover, .resize-v-line:active) > span {\n  background-color: #222;\n}\n\n:is(.resize-v-line:hover, .resize-v-line:active) svg {\n  opacity: 1;\n}\n\n.resize-v-line:before {\n  --tw-content: \"\";\n  content: var(--tw-content);\n  inset: calc(var(--spacing) * 0);\n  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  width: 1px;\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  background-color: #222;\n  position: absolute;\n  left: 50%;\n}\n\n.resize-v-line > span {\n  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  height: 1.125rem;\n  width: calc(var(--spacing) * 1.5);\n  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  border-radius: .25rem;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n\n.resize-v-line svg {\n  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  --tw-translate-y: calc(calc(1 / 2 * 100%) * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  color: var(--color-neutral-400);\n  opacity: 0;\n  transition-property: opacity;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  z-index: 50;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  rotate: 90deg;\n}\n\n.tree-node-search-highlight {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n.tree-node-search-highlight span {\n  border-radius: var(--radius-sm);\n  background-color: var(--color-yellow-300);\n  --tw-font-weight: var(--font-weight-medium);\n  font-weight: var(--font-weight-medium);\n  color: var(--color-black);\n  padding-block: 1px;\n}\n\n.tree-node-search-highlight .single {\n  margin-right: 1px;\n  padding-inline: 2px;\n}\n\n.tree-node-search-highlight .regex {\n  padding-inline: 2px;\n}\n\n.tree-node-search-highlight .start {\n  border-top-left-radius: var(--radius-sm);\n  border-bottom-left-radius: var(--radius-sm);\n  margin-left: 1px;\n}\n\n.tree-node-search-highlight .end {\n  border-top-right-radius: var(--radius-sm);\n  border-bottom-right-radius: var(--radius-sm);\n  margin-right: 1px;\n}\n\n.tree-node-search-highlight .middle {\n  border-radius: var(--radius-sm);\n  margin-inline: 1px;\n}\n\n.react-devtool-toolbar-notification {\n  inset-inline: calc(var(--spacing) * 0);\n  align-items: center;\n  column-gap: calc(var(--spacing) * 2);\n  padding: calc(var(--spacing) * 1);\n  padding-left: calc(var(--spacing) * 2);\n  color: var(--color-neutral-300);\n  background-color: #000000e6;\n  font-size: 10px;\n  display: flex;\n  position: absolute;\n}\n\n@supports (color: color-mix(in lab, red, red)) {\n  .react-devtool-toolbar-notification {\n    background-color: color-mix(in oklab, var(--color-black) 90%, transparent);\n  }\n}\n\n.react-devtool-toolbar-notification {\n  transition-property: transform, translate, scale, rotate;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n}\n\n.react-devtool-toolbar-notification:before {\n  --tw-content: \"\";\n  content: var(--tw-content);\n  inset-inline: calc(var(--spacing) * 0);\n  background-color: var(--color-black);\n  height: calc(var(--spacing) * 2);\n  position: absolute;\n}\n\n.react-devtool-toolbar-notification.position-top {\n  --tw-translate-y: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  border-bottom-right-radius: var(--radius-lg);\n  border-bottom-left-radius: var(--radius-lg);\n  top: 100%;\n}\n\n.react-devtool-toolbar-notification.position-top:before {\n  top: calc(var(--spacing) * 0);\n  --tw-translate-y: -100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.react-devtool-toolbar-notification.position-bottom {\n  --tw-translate-y: 100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  border-top-left-radius: var(--radius-lg);\n  border-top-right-radius: var(--radius-lg);\n  bottom: 100%;\n}\n\n.react-devtool-toolbar-notification.position-bottom:before {\n  bottom: calc(var(--spacing) * 0);\n  --tw-translate-y: 100%;\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.react-devtool-toolbar-notification.is-open {\n  --tw-translate-y: calc(var(--spacing) * 0);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.react-devtool-header-item {\n  inset: calc(var(--spacing) * 0);\n  --tw-translate-y: calc(200% * -1);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n  transition-property: transform, translate, scale, rotate;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: .3s;\n  transition-duration: .3s;\n  position: absolute;\n}\n\n.react-devtool-header-item.is-visible {\n  --tw-translate-y: calc(var(--spacing) * 0);\n  translate: var(--tw-translate-x) var(--tw-translate-y);\n}\n\n.react-devtool-components-tree:has(.resize-v-line:hover, .resize-v-line:active) .tree {\n  overflow: hidden;\n}\n\n.react-devtool-expandable {\n  transition-property: all;\n  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n  transition-duration: var(--tw-duration, var(--default-transition-duration));\n  --tw-duration: 75ms;\n  grid-template-rows: 0fr;\n  transition-duration: 75ms;\n  transition-timing-function: ease-out;\n  display: grid;\n  overflow: hidden;\n}\n\n.react-devtool-expandable > * {\n  min-height: 0;\n}\n\n.react-devtool-expandable.react-devtool-expanded {\n  grid-template-rows: 1fr;\n  transition-duration: .1s;\n}\n\n@view-transition {\n  navigation: auto;\n}\n\n::view-transition-old(tab-content) {\n  animation-duration: .2s;\n  animation-timing-function: ease-in-out;\n}\n\n::view-transition-new(tab-content) {\n  animation-duration: .2s;\n  animation-timing-function: ease-in-out;\n}\n\n::view-transition-old(tab-content) {\n  animation-name: slide-out;\n}\n\n::view-transition-new(tab-content) {\n  animation-name: slide-in;\n}\n\n@keyframes slide-out {\n  from {\n    opacity: 1;\n    transform: translateX(0);\n  }\n\n  to {\n    opacity: 0;\n    transform: translateX(-20px);\n  }\n}\n\n@keyframes slide-in {\n  from {\n    opacity: 0;\n    transform: translateX(20px);\n  }\n\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n@property --tw-translate-x {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-translate-y {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-translate-z {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-rotate-x {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-rotate-y {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-rotate-z {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-skew-x {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-skew-y {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-space-y-reverse {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-space-x-reverse {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-border-style {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: solid;\n}\n\n@property --tw-leading {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-font-weight {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-tracking {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-shadow-color {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n\n@property --tw-inset-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-inset-shadow-color {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-inset-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n\n@property --tw-ring-color {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-ring-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-inset-ring-color {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-inset-ring-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-ring-inset {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-ring-offset-width {\n  syntax: \"<length>\";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-ring-offset-color {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: #fff;\n}\n\n@property --tw-ring-offset-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-outline-style {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: solid;\n}\n\n@property --tw-blur {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-brightness {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-contrast {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-grayscale {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-hue-rotate {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-invert {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-opacity {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-saturate {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-sepia {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-drop-shadow {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-drop-shadow-color {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-drop-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n\n@property --tw-drop-shadow-size {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-blur {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-brightness {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-contrast {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-grayscale {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-hue-rotate {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-invert {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-opacity {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-saturate {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-backdrop-sepia {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-duration {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-ease {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-content {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: \"\";\n}\n\n@property --tw-ordinal {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-slashed-zero {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-numeric-figure {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-numeric-spacing {\n  syntax: \"*\";\n  inherits: false\n}\n\n@property --tw-numeric-fraction {\n  syntax: \"*\";\n  inherits: false\n}\n\n@keyframes fadeIn {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n\n@keyframes countFlash {\n  0% {\n    background-color: #a855f74d;\n    transform: scale(1.05);\n  }\n\n  100% {\n    background-color: #a855f71a;\n    transform: scale(1);\n  }\n}\n\n@keyframes countFlashShake {\n  0% {\n    transform: translateX(0);\n  }\n\n  25% {\n    transform: translateX(-5px);\n  }\n\n  50% {\n    transform: translateX(5px)scale(1.1);\n  }\n\n  75% {\n    transform: translateX(-5px);\n  }\n\n  100% {\n    transform: translateX(0);\n  }\n}\n";
const not_globally_unique_generateId = () => {
	if (!IS_CLIENT) return "0";
	if (window.reactDevtoolIdCounter === void 0) window.reactDevtoolIdCounter = 0;
	return `${++window.reactDevtoolIdCounter}`;
};
const invariantError = (message) => {};
const iife = (fn$1) => fn$1();
var BoundedArray = class BoundedArray extends Array {
	constructor(capacity = 25) {
		super();
		this.capacity = capacity;
	}
	push(...items) {
		const result = super.push(...items);
		while (this.length > this.capacity) this.shift();
		return result;
	}
	static fromArray(array, capacity) {
		const arr = new BoundedArray(capacity);
		arr.push(...array);
		return arr;
	}
};
var Store$1 = class {
	subscribers = /* @__PURE__ */ new Set();
	currentValue;
	constructor(initialValue) {
		this.currentValue = initialValue;
	}
	subscribe(subscriber) {
		this.subscribers.add(subscriber);
		subscriber(this.currentValue);
		return () => {
			this.subscribers.delete(subscriber);
		};
	}
	setState(data) {
		this.currentValue = data;
		this.subscribers.forEach((subscriber) => subscriber(data));
	}
	getCurrentState() {
		return this.currentValue;
	}
};
const MAX_INTERACTION_BATCH = 150;
const interactionStore = /* @__PURE__ */ new Store$1(/* @__PURE__ */ new BoundedArray(MAX_INTERACTION_BATCH));
const MAX_CHANNEL_SIZE = 50;
var PerformanceEntryChannels = class {
	channels = {};
	publish(item, to, createIfNoChannel = true) {
		const existingChannel = this.channels[to];
		if (!existingChannel) {
			if (!createIfNoChannel) return;
			this.channels[to] = {
				callbacks: new BoundedArray(MAX_CHANNEL_SIZE),
				state: new BoundedArray(MAX_CHANNEL_SIZE)
			};
			this.channels[to].state.push(item);
			return;
		}
		existingChannel.state.push(item);
		existingChannel.callbacks.forEach((cb) => cb(item));
	}
	getAvailableChannels() {
		return BoundedArray.fromArray(Object.keys(this.channels), MAX_CHANNEL_SIZE);
	}
	subscribe(to, cb, dropFirst = false) {
		const defer = () => {
			if (!dropFirst) this.channels[to].state.forEach((item) => {
				cb(item);
			});
			return () => {
				const filtered = this.channels[to].callbacks.filter((subscribed) => subscribed !== cb);
				this.channels[to].callbacks = BoundedArray.fromArray(filtered, MAX_CHANNEL_SIZE);
			};
		};
		const existing = this.channels[to];
		if (!existing) {
			this.channels[to] = {
				callbacks: new BoundedArray(MAX_CHANNEL_SIZE),
				state: new BoundedArray(MAX_CHANNEL_SIZE)
			};
			this.channels[to].callbacks.push(cb);
			return defer();
		}
		existing.callbacks.push(cb);
		return defer();
	}
	updateChannelState(channel, updater, createIfNoChannel = true) {
		const existingChannel = this.channels[channel];
		if (!existingChannel) {
			if (!createIfNoChannel) return;
			const state = new BoundedArray(MAX_CHANNEL_SIZE);
			const newChannel = {
				callbacks: new BoundedArray(MAX_CHANNEL_SIZE),
				state
			};
			this.channels[channel] = newChannel;
			newChannel.state = updater(state);
			return;
		}
		existingChannel.state = updater(existingChannel.state);
	}
	getChannelState(channel) {
		return this.channels[channel].state ?? new BoundedArray(MAX_CHANNEL_SIZE);
	}
};
const performanceEntryChannels = /* @__PURE__ */ new PerformanceEntryChannels();
const DEFAULT_FILTERS = {
	skipProviders: true,
	skipHocs: true,
	skipContainers: true,
	skipMinified: true,
	skipUtilities: true,
	skipBoundaries: true
};
const FILTER_PATTERNS = {
	providers: [
		/Provider$/,
		/^Provider$/,
		/^Context$/
	],
	hocs: [
		/^with[A-Z]/,
		/^forward(?:Ref)?$/i,
		/^Forward(?:Ref)?\(/
	],
	containers: [
		/^(?:App)?Container$/,
		/^Root$/,
		/^ReactDev/
	],
	utilities: [
		/^Fragment$/,
		/^Suspense$/,
		/^ErrorBoundary$/,
		/^Portal$/,
		/^Consumer$/,
		/^Layout$/,
		/^Router/,
		/^Hydration/
	],
	boundaries: [
		/^Boundary$/,
		/Boundary$/,
		/^Provider$/,
		/Provider$/
	]
};
const shouldIncludeInPath = (name, filters = DEFAULT_FILTERS) => {
	const patternsToCheck = [];
	if (filters.skipProviders) patternsToCheck.push(...FILTER_PATTERNS.providers);
	if (filters.skipHocs) patternsToCheck.push(...FILTER_PATTERNS.hocs);
	if (filters.skipContainers) patternsToCheck.push(...FILTER_PATTERNS.containers);
	if (filters.skipUtilities) patternsToCheck.push(...FILTER_PATTERNS.utilities);
	if (filters.skipBoundaries) patternsToCheck.push(...FILTER_PATTERNS.boundaries);
	return !patternsToCheck.some((pattern) => pattern.test(name));
};
const minifiedPatterns = [
	/^[a-z]$/,
	/^[a-z][0-9]$/,
	/^_+$/,
	/^[A-Za-z][_$]$/,
	/^[a-z]{1,2}$/
];
const isMinified = (name) => {
	for (let i$1 = 0; i$1 < minifiedPatterns.length; i$1++) if (minifiedPatterns[i$1].test(name)) return true;
	const hasNoVowels = !/[aeiou]/i.test(name);
	const hasMostlyNumbers = (name.match(/\d/g)?.length ?? 0) > name.length / 2;
	const isSingleWordLowerCase = /^[a-z]+$/.test(name);
	const hasRandomLookingChars = /[$_]{2,}/.test(name);
	return Number(hasNoVowels) + Number(hasMostlyNumbers) + Number(isSingleWordLowerCase) + Number(hasRandomLookingChars) >= 2;
};
const getInteractionPath = (initialFiber, filters = DEFAULT_FILTERS) => {
	if (!initialFiber) return [];
	const currentName = getDisplayName(initialFiber.type);
	if (!currentName) return [];
	const stack = [];
	let fiber = initialFiber;
	while (fiber.return) {
		const name = getCleanComponentName(fiber.type);
		if (name && !isMinified(name) && shouldIncludeInPath(name, filters) && name.toLowerCase() !== name) stack.push(name);
		fiber = fiber.return;
	}
	const fullPath = new Array(stack.length);
	for (let i$1 = 0; i$1 < stack.length; i$1++) fullPath[i$1] = stack[stack.length - i$1 - 1];
	return fullPath;
};
const getCleanComponentName = (component) => {
	const name = getDisplayName(component);
	if (!name) return "";
	return name.replace(/^(?:Memo|Forward(?:Ref)?|With.*?)\((?<inner>.*?)\)$/, "$<inner>");
};
const getFirstNameFromAncestor = (fiber, accept = () => true) => {
	let curr = fiber;
	while (curr) {
		const currName = getDisplayName(curr.type);
		if (currName && accept(currName)) return currName;
		curr = curr.return;
	}
	return null;
};
let unsubscribeTrackVisibilityChange;
let lastVisibilityHiddenAt = "never-hidden";
const trackVisibilityChange = () => {
	unsubscribeTrackVisibilityChange?.();
	const onVisibilityChange = () => {
		if (document.hidden) lastVisibilityHiddenAt = Date.now();
	};
	document.addEventListener("visibilitychange", onVisibilityChange);
	unsubscribeTrackVisibilityChange = () => {
		document.removeEventListener("visibilitychange", onVisibilityChange);
	};
};
const getInteractionType = (eventName) => {
	if (["pointerup", "click"].includes(eventName)) return "pointer";
	if (eventName.includes("key")) {}
	if (["keydown", "keyup"].includes(eventName)) return "keyboard";
	return null;
};
let onEntryAnimationId = null;
const setupPerformanceListener = (onEntry) => {
	trackVisibilityChange();
	const interactionMap = /* @__PURE__ */ new Map();
	const interactionTargetMap = /* @__PURE__ */ new Map();
	const processInteractionEntry = (entry) => {
		if (!entry.interactionId) return;
		if (entry.interactionId && entry.target && !interactionTargetMap.has(entry.interactionId)) interactionTargetMap.set(entry.interactionId, entry.target);
		if (entry.target) {
			let current = entry.target;
			while (current) {
				if (current.id === "react-devtool-toolbar-root" || current.id === "react-devtool-root") return;
				current = current.parentElement;
			}
		}
		const existingInteraction = interactionMap.get(entry.interactionId);
		if (existingInteraction) {
			if (entry.duration > existingInteraction.latency) {
				existingInteraction.entries = [entry];
				existingInteraction.latency = entry.duration;
			} else if (entry.duration === existingInteraction.latency && entry.startTime === existingInteraction.entries[0].startTime) existingInteraction.entries.push(entry);
		} else {
			const interactionType = getInteractionType(entry.name);
			if (!interactionType) return;
			const interaction = {
				id: entry.interactionId,
				latency: entry.duration,
				entries: [entry],
				target: entry.target,
				type: interactionType,
				startTime: entry.startTime,
				endTime: Date.now(),
				processingStart: entry.processingStart,
				processingEnd: entry.processingEnd,
				duration: entry.duration,
				inputDelay: entry.processingStart - entry.startTime,
				processingDuration: entry.processingEnd - entry.processingStart,
				presentationDelay: entry.duration - (entry.processingEnd - entry.startTime),
				timestamp: Date.now(),
				timeSinceTabInactive: lastVisibilityHiddenAt === "never-hidden" ? "never-hidden" : Date.now() - lastVisibilityHiddenAt,
				visibilityState: document.visibilityState,
				timeOrigin: performance.timeOrigin,
				referrer: document.referrer
			};
			interactionMap.set(interaction.id, interaction);
			/**
			* This seems odd, but it gives us determinism that we will receive an entry AFTER our detailed timing collection
			* runs because browser semantics (raf(() => setTimeout) will always run before a doubleRaf)
			*
			* this also handles the case where multiple entries are dispatched for semantically the same interaction,
			* they will get merged into a single interaction, where the largest latency is recorded, which is what
			* we are interested in this application
			*/
			if (!onEntryAnimationId) onEntryAnimationId = requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					onEntry(interactionMap.get(interaction.id));
					onEntryAnimationId = null;
				});
			});
		}
	};
	const po = new PerformanceObserver((list) => {
		const entries = list.getEntries();
		for (let i$1 = 0, len = entries.length; i$1 < len; i$1++) {
			const entry = entries[i$1];
			processInteractionEntry(entry);
		}
	});
	try {
		po.observe({
			type: "event",
			buffered: true,
			durationThreshold: 16
		});
		po.observe({
			type: "first-input",
			buffered: true
		});
	} catch {}
	return () => po.disconnect();
};
const setupPerformancePublisher = () => {
	return setupPerformanceListener((entry) => {
		performanceEntryChannels.publish({
			kind: "entry-received",
			entry
		}, "recording");
	});
};
const MAX_INTERACTION_TASKS = 25;
let tasks = /* @__PURE__ */ new BoundedArray(MAX_INTERACTION_TASKS);
const getAssociatedDetailedTimingInteraction = (entry, activeTasks) => {
	let closestTask = null;
	for (const task of activeTasks) {
		if (task.type !== entry.type) continue;
		if (closestTask === null) {
			closestTask = task;
			continue;
		}
		const getAbsoluteDiff = (task$1, entry$1) => Math.abs(task$1.startDateTime) - (entry$1.startTime + entry$1.timeOrigin);
		if (getAbsoluteDiff(task, entry) < getAbsoluteDiff(closestTask, entry)) closestTask = task;
	}
	return closestTask;
};
const listenForPerformanceEntryInteractions = (onComplete) => {
	const unsubscribe = performanceEntryChannels.subscribe("recording", (event) => {
		const associatedDetailedInteraction = event.kind === "auto-complete-race" ? tasks.find((task) => task.interactionUUID === event.interactionUUID) : getAssociatedDetailedTimingInteraction(event.entry, tasks);
		if (!associatedDetailedInteraction) return;
		const completedInteraction = associatedDetailedInteraction.completeInteraction(event);
		onComplete(completedInteraction);
	});
	return unsubscribe;
};
const trackDetailedTiming = ({ onMicroTask, onRAF, onTimeout, abort }) => {
	queueMicrotask(() => {
		if (abort?.() === true) return;
		if (!onMicroTask()) return;
		requestAnimationFrame(() => {
			if (abort?.() === true) return;
			if (!onRAF()) return;
			setTimeout(() => {
				if (abort?.() === true) return;
				onTimeout();
			}, 0);
		});
	});
};
const getTargetInteractionDetails = (target) => {
	const associatedFiber = getFiberFromElement(target);
	if (!associatedFiber) return;
	let componentName = associatedFiber ? getDisplayName(associatedFiber?.type) : "N/A";
	if (!componentName) componentName = getFirstNameFromAncestor(associatedFiber, (name) => name.length > 2) ?? "N/A";
	if (!componentName) return;
	const componentPath = getInteractionPath(associatedFiber);
	return {
		componentPath,
		childrenTree: {},
		componentName,
		elementFiber: associatedFiber
	};
};
/**
*
* handles tracking event timings for arbitrarily overlapping handlers with cancel logic
*/
const setupDetailedPointerTimingListener = (kind, options$1) => {
	let instrumentationIdInControl = null;
	const getEvent = (info) => {
		switch (kind) {
			case "pointer": {
				if (info.phase === "start") return "pointerup";
				if (info.target instanceof HTMLInputElement || info.target instanceof HTMLSelectElement) return "change";
				return "click";
			}
			case "keyboard": {
				if (info.phase === "start") return "keydown";
				return "change";
			}
		}
	};
	const lastInteractionRef = { current: {
		kind: "uninitialized-stage",
		interactionUUID: not_globally_unique_generateId(),
		stageStart: Date.now(),
		interactionType: kind
	} };
	const onInteractionStart = (e$1) => {
		const path = e$1.composedPath();
		if (path.some((el) => el instanceof Element && el.id === "react-devtool-toolbar-root")) return;
		if (Date.now() - lastInteractionRef.current.stageStart > 2e3) lastInteractionRef.current = {
			kind: "uninitialized-stage",
			interactionUUID: not_globally_unique_generateId(),
			stageStart: Date.now(),
			interactionType: kind
		};
		if (lastInteractionRef.current.kind !== "uninitialized-stage") return;
		const pointerUpStart = performance.now();
		options$1?.onStart?.(lastInteractionRef.current.interactionUUID);
		const details = getTargetInteractionDetails(e$1.target);
		if (!details) {
			options$1?.onError?.(lastInteractionRef.current.interactionUUID);
			return;
		}
		const fiberRenders = {};
		const stopListeningForRenders = listenForRenders(fiberRenders);
		lastInteractionRef.current = {
			...lastInteractionRef.current,
			interactionType: kind,
			blockingTimeStart: Date.now(),
			childrenTree: details.childrenTree,
			componentName: details.componentName,
			componentPath: details.componentPath,
			fiberRenders,
			kind: "interaction-start",
			interactionStartDetail: pointerUpStart,
			stopListeningForRenders
		};
		const event = getEvent({
			phase: "end",
			target: e$1.target
		});
		document.addEventListener(event, onLastJS, { once: true });
		requestAnimationFrame(() => {
			document.removeEventListener(event, onLastJS);
		});
	};
	document.addEventListener(getEvent({ phase: "start" }), onInteractionStart, { capture: true });
	/**
	*
	* TODO: IF WE DETECT RENDERS DURING THIS PERIOD WE CAN INCLUDE THAT IN THE RESULT AND THEN BACK THAT OUT OF COMPUTED STYLE TIME AND ADD IT BACK INTO JS TIME
	*/
	const onLastJS = (e$1, instrumentationId, abort) => {
		if (lastInteractionRef.current.kind !== "interaction-start" && instrumentationId === instrumentationIdInControl) {
			if (kind === "pointer" && e$1.target instanceof HTMLSelectElement) {
				lastInteractionRef.current = {
					kind: "uninitialized-stage",
					interactionUUID: not_globally_unique_generateId(),
					stageStart: Date.now(),
					interactionType: kind
				};
				return;
			}
			options$1?.onError?.(lastInteractionRef.current.interactionUUID);
			lastInteractionRef.current = {
				kind: "uninitialized-stage",
				interactionUUID: not_globally_unique_generateId(),
				stageStart: Date.now(),
				interactionType: kind
			};
			invariantError("pointer -> click");
			return;
		}
		instrumentationIdInControl = instrumentationId;
		trackDetailedTiming({
			abort,
			onMicroTask: () => {
				if (lastInteractionRef.current.kind === "uninitialized-stage") return false;
				lastInteractionRef.current = {
					...lastInteractionRef.current,
					kind: "js-end-stage",
					jsEndDetail: performance.now()
				};
				return true;
			},
			onRAF: () => {
				if (lastInteractionRef.current.kind !== "js-end-stage" && lastInteractionRef.current.kind !== "raf-stage") {
					options$1?.onError?.(lastInteractionRef.current.interactionUUID);
					invariantError("bad transition to raf");
					lastInteractionRef.current = {
						kind: "uninitialized-stage",
						interactionUUID: not_globally_unique_generateId(),
						stageStart: Date.now(),
						interactionType: kind
					};
					return false;
				}
				lastInteractionRef.current = {
					...lastInteractionRef.current,
					kind: "raf-stage",
					rafStart: performance.now()
				};
				return true;
			},
			onTimeout: () => {
				if (lastInteractionRef.current.kind !== "raf-stage") {
					options$1?.onError?.(lastInteractionRef.current.interactionUUID);
					lastInteractionRef.current = {
						kind: "uninitialized-stage",
						interactionUUID: not_globally_unique_generateId(),
						stageStart: Date.now(),
						interactionType: kind
					};
					invariantError("raf->timeout");
					return;
				}
				const now = Date.now();
				const timeoutStage = Object.freeze({
					...lastInteractionRef.current,
					kind: "timeout-stage",
					blockingTimeEnd: now,
					commitEnd: performance.now()
				});
				lastInteractionRef.current = {
					kind: "uninitialized-stage",
					interactionUUID: not_globally_unique_generateId(),
					stageStart: now,
					interactionType: kind
				};
				let completed = false;
				const completeInteraction = (event) => {
					completed = true;
					const latency = event.kind === "auto-complete-race" ? event.detailedTiming.commitEnd - event.detailedTiming.interactionStartDetail : event.entry.latency;
					const finalInteraction = {
						detailedTiming: timeoutStage,
						latency,
						completedAt: Date.now(),
						flushNeeded: true
					};
					options$1?.onComplete?.(timeoutStage.interactionUUID, finalInteraction, event);
					const newTasks = tasks.filter((task$1) => task$1.interactionUUID !== timeoutStage.interactionUUID);
					tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
					return finalInteraction;
				};
				const task = {
					completeInteraction,
					endDateTime: Date.now(),
					startDateTime: timeoutStage.blockingTimeStart,
					type: kind,
					interactionUUID: timeoutStage.interactionUUID
				};
				tasks.push(task);
				if (!isPerformanceEventAvailable()) {
					const newTasks = tasks.filter((task$1) => task$1.interactionUUID !== timeoutStage.interactionUUID);
					tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
					completeInteraction({
						kind: "auto-complete-race",
						detailedTiming: timeoutStage,
						interactionUUID: timeoutStage.interactionUUID
					});
				} else setTimeout(() => {
					if (completed) return;
					completeInteraction({
						kind: "auto-complete-race",
						detailedTiming: timeoutStage,
						interactionUUID: timeoutStage.interactionUUID
					});
					const newTasks = tasks.filter((task$1) => task$1.interactionUUID !== timeoutStage.interactionUUID);
					tasks = BoundedArray.fromArray(newTasks, MAX_INTERACTION_TASKS);
				}, 1e3);
			}
		});
	};
	const onKeyPress = (e$1) => {
		const id = not_globally_unique_generateId();
		onLastJS(e$1, id, () => id !== instrumentationIdInControl);
	};
	if (kind === "keyboard") document.addEventListener("keypress", onKeyPress);
	return () => {
		document.removeEventListener(getEvent({ phase: "start" }), onInteractionStart, { capture: true });
		document.removeEventListener("keypress", onKeyPress);
	};
};
const getHostFromFiber = (fiber) => {
	return traverseFiber(fiber, (node) => {
		if (isHostFiber(node)) return true;
	})?.stateNode;
};
const isPerformanceEventAvailable = () => {
	return "PerformanceEventTiming" in globalThis;
};
const listenForRenders = (fiberRenders) => {
	const listener = (fiber) => {
		const displayName = getDisplayName(fiber.type);
		if (!displayName) return;
		const existing = fiberRenders[displayName];
		if (!existing) {
			const parents = /* @__PURE__ */ new Set();
			const res = fiber.return && getParentCompositeFiber(fiber.return);
			const parentCompositeName = res && getDisplayName(res[0]);
			if (parentCompositeName) parents.add(parentCompositeName);
			const { selfTime: selfTime$1, totalTime: totalTime$1 } = getTimings(fiber);
			const newChanges$1 = collectInspectorDataWithoutCounts(fiber);
			const emptySection$1 = {
				current: [],
				changes: /* @__PURE__ */ new Set(),
				changesCounts: /* @__PURE__ */ new Map()
			};
			const changes = {
				fiberProps: newChanges$1.fiberProps || emptySection$1,
				fiberState: newChanges$1.fiberState || emptySection$1,
				fiberContext: newChanges$1.fiberContext || emptySection$1
			};
			fiberRenders[displayName] = {
				renderCount: 1,
				hasMemoCache: hasMemoCache(fiber),
				wasFiberRenderMount: wasFiberRenderMount(fiber),
				parents,
				selfTime: selfTime$1,
				totalTime: totalTime$1,
				nodeInfo: [{
					element: getHostFromFiber(fiber),
					name: getDisplayName(fiber.type) ?? "Unknown",
					selfTime: getTimings(fiber).selfTime
				}],
				changes
			};
			return;
		}
		const parentType = getParentCompositeFiber(fiber)?.[0]?.type;
		if (parentType) {
			const res = fiber.return && getParentCompositeFiber(fiber.return);
			const parentCompositeName = res && getDisplayName(res[0]);
			if (parentCompositeName) existing.parents.add(parentCompositeName);
		}
		const { selfTime, totalTime } = getTimings(fiber);
		const newChanges = collectInspectorDataWithoutCounts(fiber);
		if (!newChanges) return;
		const emptySection = {
			current: [],
			changes: /* @__PURE__ */ new Set(),
			changesCounts: /* @__PURE__ */ new Map()
		};
		existing.wasFiberRenderMount = existing.wasFiberRenderMount || wasFiberRenderMount(fiber);
		existing.hasMemoCache = existing.hasMemoCache || hasMemoCache(fiber);
		existing.changes = {
			fiberProps: mergeSectionData(existing.changes?.fiberProps || emptySection, newChanges.fiberProps || emptySection),
			fiberState: mergeSectionData(existing.changes?.fiberState || emptySection, newChanges.fiberState || emptySection),
			fiberContext: mergeSectionData(existing.changes?.fiberContext || emptySection, newChanges.fiberContext || emptySection)
		};
		existing.renderCount += 1;
		existing.selfTime += selfTime;
		existing.totalTime += totalTime;
		existing.nodeInfo.push({
			element: getHostFromFiber(fiber),
			name: getDisplayName(fiber.type) ?? "Unknown",
			selfTime: getTimings(fiber).selfTime
		});
	};
	Store.interactionListeningForRenders = listener;
	return () => {
		if (Store.interactionListeningForRenders === listener) Store.interactionListeningForRenders = null;
	};
};
const mergeSectionData = (existing, newData) => {
	const mergedSection = {
		current: [...existing.current],
		changes: /* @__PURE__ */ new Set(),
		changesCounts: /* @__PURE__ */ new Map()
	};
	for (const value of newData.current) if (!mergedSection.current.some((item) => item.name === value.name)) mergedSection.current.push(value);
	for (const change of newData.changes) if (typeof change === "string" || typeof change === "number") {
		mergedSection.changes.add(change);
		const existingCount = existing.changesCounts.get(change) || 0;
		const newCount = newData.changesCounts.get(change) || 0;
		mergedSection.changesCounts.set(change, existingCount + newCount);
	}
	return mergedSection;
};
const wasFiberRenderMount = (fiber) => {
	if (!fiber.alternate) return true;
	const prevFiber = fiber.alternate;
	const wasMounted = prevFiber && prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && prevFiber.memoizedState.isDehydrated !== true;
	const isMounted = fiber.memoizedState != null && fiber.memoizedState.element != null && fiber.memoizedState.isDehydrated !== true;
	return !wasMounted && isMounted;
};
const createStoreImpl = (createState) => {
	let state;
	const listeners = /* @__PURE__ */ new Set();
	const setState = (partial, replace) => {
		const nextState = typeof partial === "function" ? partial(state) : partial;
		if (!Object.is(nextState, state)) {
			const previousState = state;
			state = replace ?? (typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
			listeners.forEach((listener) => listener(state, previousState));
		}
	};
	const getState = () => state;
	const getInitialState = () => initialState;
	const subscribe = (selectorOrListener, listener) => {
		let selector;
		let actualListener;
		if (listener) {
			selector = selectorOrListener;
			actualListener = listener;
		} else actualListener = selectorOrListener;
		let currentSlice = selector ? selector(state) : void 0;
		const wrappedListener = (newState, previousState) => {
			if (selector) {
				const nextSlice = selector(newState);
				const prevSlice = selector(previousState);
				if (!Object.is(currentSlice, nextSlice)) {
					currentSlice = nextSlice;
					actualListener(nextSlice, prevSlice);
				}
			} else actualListener(newState, previousState);
		};
		listeners.add(wrappedListener);
		return () => listeners.delete(wrappedListener);
	};
	const api = {
		setState,
		getState,
		getInitialState,
		subscribe
	};
	const initialState = state = createState(setState, getState, api);
	return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
let accumulatedFiberRendersOverTask = null;
const EVENT_STORE_CAPACITY = 200;
const toolbarEventStore = /* @__PURE__ */ createStore()((set, get) => {
	const listeners = /* @__PURE__ */ new Set();
	return {
		state: { events: new BoundedArray(EVENT_STORE_CAPACITY) },
		actions: {
			addEvent: (event) => {
				listeners.forEach((listener) => listener(event));
				const events = [...get().state.events, event];
				const applyOverlapCheckToLongRenderEvent = (longRenderEvent, onOverlap) => {
					const overlapsWith = events.find((event$1) => {
						if (event$1.kind === "long-render") return;
						if (event$1.id === longRenderEvent.id) return;
						/**
						* |---x-----------x------ (interaction)
						* |x-----------x          (long-render)
						*/
						if (longRenderEvent.data.startAt <= event$1.data.startAt && longRenderEvent.data.endAt <= event$1.data.endAt && longRenderEvent.data.endAt >= event$1.data.startAt) return true;
						/**
						* |x-----------x---- (interaction)
						* |--x------------x  (long-render)
						*
						
						*/
						if (event$1.data.startAt <= longRenderEvent.data.startAt && event$1.data.endAt >= longRenderEvent.data.startAt) return true;
						/**
						*
						* |--x-------------x    (interaction)
						* |x------------------x (long-render)
						*
						*/
						if (longRenderEvent.data.startAt <= event$1.data.startAt && longRenderEvent.data.endAt >= event$1.data.endAt) return true;
					});
					if (overlapsWith) onOverlap(overlapsWith);
				};
				const toRemove = /* @__PURE__ */ new Set();
				events.forEach((event$1) => {
					if (event$1.kind === "interaction") return;
					applyOverlapCheckToLongRenderEvent(event$1, () => {
						toRemove.add(event$1.id);
					});
				});
				const withRemovedEvents = events.filter((event$1) => !toRemove.has(event$1.id));
				set(() => ({ state: { events: BoundedArray.fromArray(withRemovedEvents, EVENT_STORE_CAPACITY) } }));
			},
			addListener: (listener) => {
				listeners.add(listener);
				return () => {
					listeners.delete(listener);
				};
			},
			clear: () => {
				set({ state: { events: new BoundedArray(EVENT_STORE_CAPACITY) } });
			}
		}
	};
});
let taskDirtyAt = null;
let taskDirtyOrigin = null;
let previousTrackCurrentMouseOverElementCallback = null;
let overToolbar;
const trackCurrentMouseOverToolbar = () => {
	const callback = (e$1) => {
		overToolbar = e$1.composedPath().map((path) => path.id).filter(Boolean).includes("react-devtool-toolbar");
	};
	document.addEventListener("mouseover", callback);
	previousTrackCurrentMouseOverElementCallback = callback;
	return () => {
		if (previousTrackCurrentMouseOverElementCallback) document.removeEventListener("mouseover", previousTrackCurrentMouseOverElementCallback);
	};
};
const startDirtyTaskTracking = () => {
	const onVisibilityChange = () => {
		taskDirtyAt = performance.now();
		taskDirtyOrigin = performance.timeOrigin;
	};
	document.addEventListener("visibilitychange", onVisibilityChange);
	return () => {
		document.removeEventListener("visibilitychange", onVisibilityChange);
	};
};
const HIGH_SEVERITY_FPS_DROP_TIME = 150;
let framesDrawnInTheLastSecond = [];
function startLongPipelineTracking() {
	let rafHandle;
	let timeoutHandle;
	function measure() {
		let unSub = null;
		accumulatedFiberRendersOverTask = null;
		accumulatedFiberRendersOverTask = {};
		unSub = listenForRenders(accumulatedFiberRendersOverTask);
		const startOrigin = performance.timeOrigin;
		const startTime = performance.now();
		rafHandle = requestAnimationFrame(() => {
			timeoutHandle = setTimeout(() => {
				const endNow = performance.now();
				const duration = endNow - startTime;
				const endOrigin = performance.timeOrigin;
				framesDrawnInTheLastSecond.push(endNow + endOrigin);
				const framesInTheLastSecond = framesDrawnInTheLastSecond.filter((frameAt) => endNow + endOrigin - frameAt <= 1e3);
				const fps$1 = framesInTheLastSecond.length;
				framesDrawnInTheLastSecond = framesInTheLastSecond;
				const taskConsideredDirty = taskDirtyAt !== null && taskDirtyOrigin !== null ? endNow + endOrigin - (taskDirtyOrigin + taskDirtyAt) < 100 : null;
				const wasTaskInfluencedByToolbar = overToolbar !== null && overToolbar;
				if (duration > HIGH_SEVERITY_FPS_DROP_TIME && !taskConsideredDirty && document.visibilityState === "visible" && !wasTaskInfluencedByToolbar) {
					const endAt = endOrigin + endNow;
					const startAt = startTime + startOrigin;
					toolbarEventStore.getState().actions.addEvent({
						kind: "long-render",
						id: not_globally_unique_generateId(),
						data: {
							endAt,
							startAt,
							meta: {
								fiberRenders: accumulatedFiberRendersOverTask,
								latency: duration,
								fps: fps$1
							}
						}
					});
				}
				taskDirtyAt = null;
				taskDirtyOrigin = null;
				unSub?.();
				measure();
			}, 0);
		});
		return unSub;
	}
	const measureUnSub = measure();
	return () => {
		measureUnSub();
		cancelAnimationFrame(rafHandle);
		clearTimeout(timeoutHandle);
	};
}
const startTimingTracking = () => {
	const unSubPerformance = setupPerformancePublisher();
	const unSubMouseOver = trackCurrentMouseOverToolbar();
	const unSubDirtyTaskTracking = startDirtyTaskTracking();
	const unSubLongPipelineTracking = startLongPipelineTracking();
	const onComplete = async (_$1, finalInteraction, event) => {
		toolbarEventStore.getState().actions.addEvent({
			kind: "interaction",
			id: not_globally_unique_generateId(),
			data: {
				startAt: finalInteraction.detailedTiming.blockingTimeStart,
				endAt: performance.now() + performance.timeOrigin,
				meta: {
					...finalInteraction,
					kind: event.kind
				}
			}
		});
		const existingCompletedInteractions = performanceEntryChannels.getChannelState("recording");
		finalInteraction.detailedTiming.stopListeningForRenders();
		if (existingCompletedInteractions.length) performanceEntryChannels.updateChannelState("recording", () => new BoundedArray(MAX_CHANNEL_SIZE));
	};
	const unSubDetailedPointerTiming = setupDetailedPointerTimingListener("pointer", { onComplete });
	const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener("keyboard", { onComplete });
	const unSubInteractions = listenForPerformanceEntryInteractions((completedInteraction) => {
		interactionStore.setState(BoundedArray.fromArray(interactionStore.getCurrentState().concat(completedInteraction), MAX_INTERACTION_BATCH));
	});
	return () => {
		unSubMouseOver();
		unSubDirtyTaskTracking();
		unSubLongPipelineTracking();
		unSubPerformance();
		unSubDetailedPointerTiming();
		unSubInteractions();
		unSubDetailedKeyboardTiming();
	};
};
let highlightCanvas = null;
let highlightCtx = null;
let animationFrame = null;
const HighlightStore = /* @__PURE__ */ signal({
	kind: "idle",
	current: null
});
let currFrame = null;
const drawHighlights = () => {
	if (currFrame) cancelAnimationFrame(currFrame);
	currFrame = requestAnimationFrame(() => {
		if (!highlightCanvas || !highlightCtx) return;
		highlightCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
		const color = "hsl(271, 76%, 53%)";
		const state = HighlightStore.value;
		const { alpha, current } = iife(() => {
			switch (state.kind) {
				case "transition": {
					const current$1 = state.current?.alpha && state.current.alpha > 0 ? state.current : state.transitionTo;
					return {
						alpha: current$1 ? current$1.alpha : 0,
						current: current$1
					};
				}
				case "move-out": return {
					alpha: state.current?.alpha ?? 0,
					current: state.current
				};
				case "idle": return {
					alpha: 1,
					current: state.current
				};
			}
		});
		current?.rects.forEach((rect) => {
			if (!highlightCtx) return;
			highlightCtx.shadowColor = color;
			highlightCtx.shadowBlur = 6;
			highlightCtx.strokeStyle = color;
			highlightCtx.lineWidth = 2;
			highlightCtx.globalAlpha = alpha;
			highlightCtx.beginPath();
			highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
			highlightCtx.stroke();
			highlightCtx.shadowBlur = 0;
			highlightCtx.beginPath();
			highlightCtx.rect(rect.left, rect.top, rect.width, rect.height);
			highlightCtx.stroke();
		});
		switch (state.kind) {
			case "move-out": {
				if (state.current.alpha === 0) {
					HighlightStore.value = {
						kind: "idle",
						current: null
					};
					return;
				}
				if (state.current.alpha <= .01) state.current.alpha = 0;
				state.current.alpha = Math.max(0, state.current.alpha - .03);
				drawHighlights();
				return;
			}
			case "transition": {
				if (state.current && state.current.alpha > 0) {
					state.current.alpha = Math.max(0, state.current.alpha - .03);
					drawHighlights();
					return;
				}
				if (state.transitionTo.alpha === 1) {
					HighlightStore.value = {
						kind: "idle",
						current: state.transitionTo
					};
					return;
				}
				state.transitionTo.alpha = Math.min(state.transitionTo.alpha + .03, 1);
				drawHighlights();
			}
			case "idle": return;
		}
	});
};
let handleResizeListener = null;
const createHighlightCanvas = (root) => {
	highlightCanvas = document.createElement("canvas");
	highlightCtx = highlightCanvas.getContext("2d", { alpha: true });
	if (!highlightCtx) return null;
	const dpr = window.devicePixelRatio || 1;
	const { innerWidth, innerHeight } = window;
	highlightCanvas.style.width = `${innerWidth}px`;
	highlightCanvas.style.height = `${innerHeight}px`;
	highlightCanvas.width = innerWidth * dpr;
	highlightCanvas.height = innerHeight * dpr;
	highlightCanvas.style.position = "fixed";
	highlightCanvas.style.left = "0";
	highlightCanvas.style.top = "0";
	highlightCanvas.style.pointerEvents = "none";
	highlightCanvas.style.zIndex = "2147483600";
	highlightCtx.scale(dpr, dpr);
	root.appendChild(highlightCanvas);
	if (handleResizeListener) window.removeEventListener("resize", handleResizeListener);
	const handleResize = () => {
		if (!highlightCanvas || !highlightCtx) return;
		const dpr$1 = window.devicePixelRatio || 1;
		const { innerWidth: innerWidth$1, innerHeight: innerHeight$1 } = window;
		highlightCanvas.style.width = `${innerWidth$1}px`;
		highlightCanvas.style.height = `${innerHeight$1}px`;
		highlightCanvas.width = innerWidth$1 * dpr$1;
		highlightCanvas.height = innerHeight$1 * dpr$1;
		highlightCtx.scale(dpr$1, dpr$1);
		drawHighlights();
	};
	handleResizeListener = handleResize;
	window.addEventListener("resize", handleResize);
	HighlightStore.subscribe(() => {
		requestAnimationFrame(() => {
			drawHighlights();
		});
	});
	return cleanup;
};
function cleanup() {
	if (animationFrame) {
		cancelAnimationFrame(animationFrame);
		animationFrame = null;
	}
	if (highlightCanvas?.parentNode) highlightCanvas.parentNode.removeChild(highlightCanvas);
	highlightCanvas = null;
	highlightCtx = null;
}
let rootContainer = null;
let shadowRoot = null;
const loadOptimisticFonts = () => {
	if (!IS_CLIENT || document.getElementById("react-devtool-fonts")) return;
	const fontCSS = `
		/* Arabic */
		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Arbc_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0600-06FF;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Arbc_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0600-06FF;
		}

		/* Cyrillic */
		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Cyrl_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Cyrl_W_SBd.woff2') format('woff2');
			font-weight: 600;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Cyrl_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Cyrl_W_Rg.woff2') format('woff2');
			font-weight: 400;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Cyrl_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Cyrl_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0400-045F, U+2116;
		}

		/* Devanagari */
		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Deva_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Deva_W_SBd.woff2') format('woff2');
			font-weight: 600;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Deva_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Deva_W_Rg.woff2') format('woff2');
			font-weight: 400;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Deva_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Deva_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;
		}

		/* Vietnamese */
		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Viet_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Viet_W_SBd.woff2') format('woff2');
			font-weight: 600;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_Viet_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Viet_W_Rg.woff2') format('woff2');
			font-weight: 400;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Viet_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_Viet_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
		}

		/* Latin Extended */
		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_SBd.woff2') format('woff2');
			font-weight: 600;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Rg.woff2') format('woff2');
			font-weight: 400;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
		}

		/* Latin */
		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_SBd.woff2') format('woff2');
			font-weight: 600;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}

		@font-face {
			font-family: 'Optimistic Display';
			src: url('https://react.dev/fonts/Optimistic_Display_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Rg.woff2') format('woff2');
			font-weight: 400;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Md.woff2') format('woff2');
			font-weight: 500;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}

		@font-face {
			font-family: 'Optimistic Text';
			src: url('https://react.dev/fonts/Optimistic_Text_W_Bd.woff2') format('woff2');
			font-weight: 700;
			font-style: normal;
			font-display: swap;
			unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
		}
	`;
	const styleElement = document.createElement("style");
	styleElement.id = "react-devtool-fonts";
	styleElement.textContent = fontCSS;
	document.head.appendChild(styleElement);
};
const initRootContainer = () => {
	if (rootContainer && shadowRoot) return {
		rootContainer,
		shadowRoot
	};
	rootContainer = document.createElement("div");
	rootContainer.id = "react-devtool-root";
	shadowRoot = rootContainer.attachShadow({ mode: "open" });
	const cssStyles = document.createElement("style");
	cssStyles.textContent = src_default;
	shadowRoot.appendChild(cssStyles);
	document.documentElement.appendChild(rootContainer);
	return {
		rootContainer,
		shadowRoot
	};
};
const Store = {
	wasDetailsOpen: /* @__PURE__ */ signal(true),
	isInIframe: /* @__PURE__ */ signal(IS_CLIENT && /* @__PURE__ */ (() => window.self)() !== /* @__PURE__ */ (() => window.top)()),
	inspectState: /* @__PURE__ */ signal({ kind: "uninitialized" }),
	monitor: /* @__PURE__ */ signal(null),
	fiberRoots: /* @__PURE__ */ new Set(),
	reportData: /* @__PURE__ */ new Map(),
	legacyReportData: /* @__PURE__ */ new Map(),
	lastReportTime: /* @__PURE__ */ signal(0),
	interactionListeningForRenders: null,
	changesListeners: /* @__PURE__ */ new Map()
};
const ReactDevtoolInternals = {
	instrumentation: null,
	componentAllowList: null,
	options: /* @__PURE__ */ signal({
		enabled: true,
		log: false,
		showToolbar: true,
		animationSpeed: "fast",
		dangerouslyForceRunInProduction: false,
		showFPS: true,
		showNotificationCount: true,
		allowInIframe: false
	}),
	runInAllEnvironments: false,
	onRender: null,
	scheduledOutlines: /* @__PURE__ */ new Map(),
	activeOutlines: /* @__PURE__ */ new Map(),
	Store,
	version: "0.0.1"
};
function isOptionKey(key) {
	return key in ReactDevtoolInternals.options.value;
}
const validateOptions = (options$1) => {
	const errors = [];
	const validOptions = {};
	for (const key in options$1) {
		if (!isOptionKey(key)) continue;
		const value = options$1[key];
		switch (key) {
			case "enabled":
			case "log":
			case "showToolbar":
			case "showNotificationCount":
			case "dangerouslyForceRunInProduction":
			case "showFPS":
			case "allowInIframe":
				if (typeof value !== "boolean") errors.push(`- ${key} must be a boolean. Got "${value}"`);
				else validOptions[key] = value;
				break;
			case "animationSpeed":
				if (![
					"slow",
					"fast",
					"off"
				].includes(value)) errors.push(`- Invalid animation speed "${value}". Using default "fast"`);
				else validOptions[key] = value;
				break;
			case "onCommitStart":
				if (typeof value !== "function") errors.push(`- ${key} must be a function. Got "${value}"`);
				else validOptions.onCommitStart = value;
				break;
			case "onCommitFinish":
				if (typeof value !== "function") errors.push(`- ${key} must be a function. Got "${value}"`);
				else validOptions.onCommitFinish = value;
				break;
			case "onRender":
				if (typeof value !== "function") errors.push(`- ${key} must be a function. Got "${value}"`);
				else validOptions.onRender = value;
				break;
			case "onPaintStart":
			case "onPaintFinish":
				if (typeof value !== "function") errors.push(`- ${key} must be a function. Got "${value}"`);
				else validOptions[key] = value;
				break;
			default: errors.push(`- Unknown option "${key}"`);
		}
	}
	if (errors.length > 0) console.warn(`[React Scan] Invalid options:\n${errors.join("\n")}`);
	return validOptions;
};
const setOptions = (userOptions) => {
	try {
		const validOptions = validateOptions(userOptions);
		if (Object.keys(validOptions).length === 0) return;
		const shouldInitToolbar = "showToolbar" in validOptions && validOptions.showToolbar !== void 0;
		const newOptions = {
			...ReactDevtoolInternals.options.value,
			...validOptions
		};
		const { instrumentation } = ReactDevtoolInternals;
		if (instrumentation && "enabled" in validOptions) instrumentation.isPaused.value = validOptions.enabled === false;
		ReactDevtoolInternals.options.value = newOptions;
		try {
			const existing = readLocalStorage("react-devtool-options")?.enabled;
			if (typeof existing === "boolean") newOptions.enabled = existing;
		} catch (e$1) {
			if (ReactDevtoolInternals.options.value._debug === "verbose") console.error("[React Scan Internal Error]", "Failed to create notifications outline canvas", e$1);
		}
		saveLocalStorage("react-devtool-options", newOptions);
		if (shouldInitToolbar) initToolbar(!!newOptions.showToolbar);
		return newOptions;
	} catch (e$1) {
		if (ReactDevtoolInternals.options.value._debug === "verbose") console.error("[React Scan Internal Error]", "Failed to create notifications outline canvas", e$1);
	}
};
const getOptions = () => ReactDevtoolInternals.options;
let isProduction = null;
let rdtHook;
const getIsProduction = () => {
	if (isProduction !== null) return isProduction;
	rdtHook ??= getRDTHook();
	for (const renderer of rdtHook.renderers.values()) {
		const buildType = detectReactBuildType(renderer);
		if (buildType === "production") isProduction = true;
	}
	return isProduction;
};
const start = () => {
	try {
		if (!IS_CLIENT) return;
		loadOptimisticFonts();
		if (!ReactDevtoolInternals.runInAllEnvironments && getIsProduction() && !ReactDevtoolInternals.options.value.dangerouslyForceRunInProduction) return;
		const localStorageOptions = readLocalStorage("react-devtool-options");
		if (localStorageOptions) {
			const validLocalOptions = validateOptions(localStorageOptions);
			if (Object.keys(validLocalOptions).length > 0) ReactDevtoolInternals.options.value = {
				...ReactDevtoolInternals.options.value,
				...validLocalOptions
			};
		}
		const options$1 = getOptions();
		initToolbar(!!options$1.value.showToolbar);
		if (!Store.monitor.value && IS_CLIENT) setTimeout(() => {
			if (isInstrumentationActive()) return;
			console.error("[React Scan] Failed to load. Must import React Scan before React runs.");
		}, 5e3);
	} catch (e$1) {
		if (ReactDevtoolInternals.options.value._debug === "verbose") console.error("[React Scan Internal Error]", "Failed to create notifications outline canvas", e$1);
	}
};
const initToolbar = (showToolbar) => {
	window.reactDevtoolCleanupListeners?.();
	const cleanupTimingTracking = startTimingTracking();
	const cleanupOutlineCanvas = createNotificationsOutlineCanvas();
	window.reactDevtoolCleanupListeners = () => {
		cleanupTimingTracking();
		cleanupOutlineCanvas?.();
	};
	const windowToolbarContainer = window.__REACT_DEVTOOL_TOOLBAR_CONTAINER__;
	if (!showToolbar) {
		windowToolbarContainer?.remove();
		return;
	}
	windowToolbarContainer?.remove();
	const { shadowRoot: shadowRoot$1 } = initRootContainer();
	createToolbar(shadowRoot$1);
};
const createNotificationsOutlineCanvas = () => {
	try {
		const highlightRoot = document.documentElement;
		return createHighlightCanvas(highlightRoot);
	} catch (e$1) {
		if (ReactDevtoolInternals.options.value._debug === "verbose") console.error("[React Scan Internal Error]", "Failed to create notifications outline canvas", e$1);
	}
};
/**
* @public
*/
const scan = (options$1 = {}) => {
	setOptions(options$1);
	const isInIframe = Store.isInIframe.value;
	if (isInIframe && !ReactDevtoolInternals.options.value.allowInIframe && !ReactDevtoolInternals.runInAllEnvironments) return;
	if (options$1.enabled === false && options$1.showToolbar !== true) return;
	start();
};
export { cn, createPropertyRenderer, scan, userChildren };

//# sourceMappingURL=core.js.map